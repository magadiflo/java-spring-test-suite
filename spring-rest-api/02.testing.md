# üß™ Fase 2 ‚Äî Implementaci√≥n de Pruebas (JUnit & Mockito)

El objetivo de esta fase es garantizar la calidad, confiabilidad y consistencia del sistema mediante la implementaci√≥n
de pruebas unitarias e integradas, asegurando que cada componente del proyecto funcione de forma aislada y tambi√©n
correctamente en conjunto.

---

## ‚öôÔ∏è Configuraci√≥n Previa

Antes de comenzar con las pruebas, realizaremos algunos ajustes b√°sicos para preparar un entorno de test limpio,
aislado y reproducible.

### üßπ Eliminando la clase de prueba creada autom√°ticamente

Cuando generamos un nuevo proyecto con `Spring Boot`, el asistente crea por defecto una clase de prueba b√°sica como
esta:

````java

@SpringBootTest
class SpringRestApiApplicationTests {
    @Test
    void contextLoads() {
    }
}
````

üîç Detalles importantes:

- El nombre de la clase coincide con el nombre principal de la aplicaci√≥n.
- El m√©todo `contextLoads()` est√° anotado con `@Test`, indicando que es una prueba de `JUnit 5`.
- La anotaci√≥n `@SpringBootTest` indica que se cargar√° el `contexto completo de Spring` para la prueba.
  > M√°s adelante analizaremos en detalle qu√© hace exactamente esta anotaci√≥n y cu√°ndo conviene usarla.

‚ö†Ô∏è Por ahora, como vamos a enfocarnos en las `pruebas unitarias puras` (sin contexto de Spring), *eliminaremos
esta clase generada autom√°ticamente.* Esto nos permitir√° comenzar con nuestras propias clases de prueba bien
estructuradas y espec√≠ficas.

### üßæ Creando archivo de configuraci√≥n por defecto `application.yml`

Para evitar posibles conflictos con los archivos de configuraci√≥n del entorno principal (`src/main/resources`),
es recomendable definir un archivo de configuraci√≥n `por defecto para los tests`.

üìÅ Ruta recomendada: `src/test/resources/application.yml`

üß© Contenido inicial:

````yml
spring:
  application:
    name: spring-rest-api
````

üîç Explicaci√≥n:

- Este archivo define un contexto b√°sico para las pruebas.
- Si alguna prueba intenta acceder a propiedades de configuraci√≥n, `Spring Boot` tomar√° este archivo
  `desde el entorno de test`, en lugar de usar los definidos en `src/main/resources`.
- Esto previene errores por configuraciones incorrectas o no deseadas al ejecutar pruebas.

> ‚ö†Ô∏è Si no se define un archivo `application.yml` en `src/test/resources`, Spring Boot usar√° el de `src/main/resources`
> durante las pruebas. Esto puede provocar que las pruebas accedan a configuraciones reales, como bases de datos o
> servicios externos. Por eso, crear un archivo de configuraci√≥n aislado para tests es una pr√°ctica recomendada para
> proteger el entorno y evitar errores.

üí° Recomendaci√≥n:
> M√°s adelante, se puede definir un archivo `application-test.yml` con configuraciones espec√≠ficas para
> pruebas de integraci√≥n (como base de datos embebida, puerto aleatorio, etc.), y activarlo mediante
> `@ActiveProfiles("test")` en la clase de prueba o con la propiedad `spring.profiles.active=test` en el
> archivo `application.yml` del entorno de `test`. Esto permite mayor control y aislamiento por tipo de prueba.

---

# Unit Test - Test de Servicios (Mockito)

---

### üìñ Convenci√≥n de nombres para clases de prueba

Para facilitar la organizaci√≥n y comprensi√≥n de los distintos enfoques de prueba, nombraremos las clases de
test siguiendo esta estructura:

`<NombreDeLaImplementaci√≥n><TipoDeConfiguraci√≥n>Test`

Ejemplos:

- `AccountServiceImplMockitoManualTest` ‚Üí Pruebas unitarias con mocks definidos manualmente (`Mockito.mock(...)`)
- `AccountServiceImplMockitoAnnotationTest` ‚Üí Pruebas unitarias con anotaciones (`@Mock`, `@InjectMocks`)
- `AccountServiceImplSpringBootTest` ‚Üí Pruebas con contexto de Spring (`@SpringBootTest`, `@MockBean`, `@Autowired`)

> Esta convenci√≥n permite identificar r√°pidamente el enfoque utilizado y facilita la revisi√≥n y mantenimiento del
> c√≥digo de pruebas.

### üß™ Convenci√≥n de nombres para m√©todos de prueba

Adoptaremos una convenci√≥n basada en el estilo `BDD (Behavior-Driven Development)` para nombrar los m√©todos de prueba,
de modo que los nombres describan de forma clara, legible y autoexplicativa el comportamiento esperado del sistema.

````
should_<expectedBehavior>_when_<situation>
````

| Segmento             | Significado                                              | Ejemplo                                                                       |
|----------------------|----------------------------------------------------------|-------------------------------------------------------------------------------|
| `should_`            | Indica la expectativa o el comportamiento que se valida. | `shouldReturn`, `shouldThrow`, `shouldUpdate`                                 |
| `<expectedBehavior>` | Describe el resultado o acci√≥n esperada.                 | `shouldTransferBalance`, `shouldThrowException`, `shouldUpdateAccountBalance` |
| `_when_`             | Separa el comportamiento del contexto o condici√≥n.       | `whenAccountExists`, `whenAccountsAreFromSameBank`                            |
| `<situation>`        | Describe la situaci√≥n, entrada o escenario.              | `whenAccountIsNotFound`, `whenBalanceIsInsufficient`                          |

## üß™ Pruebas unitarias con Mockito manual

A continuaci√≥n se muestra la creaci√≥n de nuestra clase de prueba para el servicio `AccountServiceImpl` con la
creaci√≥n de un test unitario para el m√©todo `transfer()`.

Esta clase de prueba utiliza `Mockito.mock(...)` para simular manualmente las dependencias del servicio
`AccountServiceImpl`.

- Se usa la interfaz `AccountService` como tipo para mantener flexibilidad.
- El objeto bajo prueba se nombra como `accountServiceUnderTest` para mejorar la claridad.
- No se levanta contexto de Spring, lo que permite pruebas r√°pidas y aisladas.

> Esta estructura es ideal para validar la l√≥gica del servicio sin depender de la infraestructura.

## üß© AccountTestFactory ‚Äî Generador de datos de prueba

Esta clase se utiliza para crear objetos de dominio reutilizables en pruebas unitarias, evitando la duplicaci√≥n de
c√≥digo y manteniendo los tests limpios y consistentes.

````java

@UtilityClass
public class AccountTestFactory {
    public static Account createAccount(Long accountId, String holder, BigDecimal balance) {
        return Account.builder()
                .id(accountId)
                .holder(holder)
                .balance(balance)
                .build();
    }

    public static Bank createBank(Long bankId, String name, Account... accounts) {
        Bank bank = Bank.builder()
                .id(bankId)
                .name(name)
                .totalTransfers(0)
                .build();
        Arrays.stream(accounts).forEach(bank::addAccount);
        return bank;
    }
}
````

Buenas pr√°cticas aplicadas:

- Uso de la anotaci√≥n `@UtilityClass` de `Lombok` para declarar una clase utilitaria sin instanciaci√≥n.
- M√©todos est√°ticos y deterministas, asegurando independencia entre pruebas.
- Evita la duplicaci√≥n de c√≥digo de inicializaci√≥n en m√∫ltiples clases de prueba.
- Promueve la reutilizaci√≥n y consistencia en la creaci√≥n de entidades de dominio.

## üß™ AccountServiceImplMockitoManualTest ‚Äî Prueba unitaria de transferencia

Prueba unitaria enfocada en validar la l√≥gica del m√©todo `transfer(...)` de `AccountServiceImpl` mediante mocks
configurados manualmente.

````java
class AccountServiceImplMockitoManualTest {

    private AccountRepository accountRepository;
    private BankRepository bankRepository;
    private AccountMapper accountMapper;
    private AccountService accountServiceUnderTest;

    @BeforeEach
    void setUp() {
        this.accountRepository = Mockito.mock(AccountRepository.class);
        this.bankRepository = Mockito.mock(BankRepository.class);
        this.accountMapper = Mockito.mock(AccountMapper.class);
        this.accountServiceUnderTest = new AccountServiceImpl(this.accountRepository, this.bankRepository, this.accountMapper);
    }

    @Test
    void shouldTransferBalanceWhenAccountsAreFromSameBank() {
        // given
        TransactionRequest request = new TransactionRequest(1L, 2L, new BigDecimal("700"));
        Account sourceAccount = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Account targetAccount = AccountTestFactory.createAccount(2L, "Kiara", new BigDecimal("1000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", sourceAccount, targetAccount);

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(sourceAccount));
        Mockito.when(this.accountRepository.findById(2L)).thenReturn(Optional.of(targetAccount));

        // when
        this.accountServiceUnderTest.transfer(request);

        // then
        assertThat(sourceAccount.getBalance()).isEqualByComparingTo("1300");
        assertThat(targetAccount.getBalance()).isEqualByComparingTo("1700");
        assertThat(bank.getTotalTransfers()).isEqualTo(1);
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository).findById(2L);
        Mockito.verify(this.accountRepository, Mockito.times(2)).findById(Mockito.anyLong());
        Mockito.verify(this.bankRepository, Mockito.never()).findById(Mockito.anyLong());
        Mockito.verify(this.accountRepository).save(sourceAccount);
        Mockito.verify(this.accountRepository).save(targetAccount);
        Mockito.verify(this.accountRepository, Mockito.times(2)).save(Mockito.any(Account.class));
        Mockito.verify(this.bankRepository).save(bank);
    }
}
````

Buenas pr√°cticas aplicadas:

- Estructura clara `Given‚ÄìWhen‚ÄìThen`, que mejora la legibilidad del test.
- Uso manual de mocks (`Mockito.mock(...)`) para un control expl√≠cito de dependencias.
- Verificaci√≥n exhaustiva de interacciones (`verify(...)`) para asegurar el flujo correcto del m√©todo.
- Reutilizaci√≥n de objetos mediante `AccountTestFactory`.
- Nombrado del m√©todo de prueba siguiendo la convenci√≥n `BDD`: `should_<expectedBehavior>_when_<situation>` ‚Üí
  `shouldTransferBalanceWhenAccountsAreFromSameBank`.
- Aislamiento total del entorno (sin dependencia de base de datos ni contexto Spring).

## üß™ Escribiendo tests `assertThatThrownBy` para afirmar que la excepci√≥n lanzada sea correcta

Crearemos un test para verificar que se est√© lanzando nuestra excepci√≥n personalizada `InsufficientBalanceException`
cuando el monto a transferir sea mayor que el saldo disponible de la cuenta origen.

````java

class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowInsufficientBalanceExceptionWhenSourceAccountHasLowBalance() {
        // given
        TransactionRequest request = new TransactionRequest(1L, 2L, new BigDecimal("5000"));
        Account sourceAccount = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Account targetAccount = AccountTestFactory.createAccount(2L, "Kiara", new BigDecimal("1000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", sourceAccount, targetAccount);

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(sourceAccount));
        Mockito.when(this.accountRepository.findById(2L)).thenReturn(Optional.of(targetAccount));

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.transfer(request))
                .isInstanceOf(InsufficientBalanceException.class)
                .hasMessage("Saldo insuficiente en la cuenta del titular Milagros (ID: 1)");

        // then
        assertThat(sourceAccount.getBalance()).isEqualByComparingTo("2000");
        assertThat(targetAccount.getBalance()).isEqualByComparingTo("1000");
        assertThat(bank.getTotalTransfers()).isZero();
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository).findById(2L);
        Mockito.verify(this.accountRepository, Mockito.times(2)).findById(Mockito.anyLong());
        Mockito.verify(this.bankRepository, Mockito.never()).findById(Mockito.anyLong());
        Mockito.verify(this.accountRepository, Mockito.never()).save(sourceAccount);
        Mockito.verify(this.accountRepository, Mockito.never()).save(targetAccount);
        Mockito.verify(this.bankRepository, Mockito.never()).save(bank);
    }
}
````

üí° Ajuste aplicado

> En la implementaci√≥n real (`AccountServiceImpl`) se movi√≥ la actualizaci√≥n del contador de transferencias despu√©s de
> las operaciones de retiro y dep√≥sito exitosas.
>
> De esta manera, si ocurre una excepci√≥n (como `InsufficientBalanceException`), la variable `totalTransfers` no se ve
> afectada, manteniendo la coherencia del estado del dominio incluso sin `@Transactional`.

## üß™ Escribiendo test con el `isSameAs`

Este test valida el comportamiento del m√©todo `findAccountById(Long accountId)` del servicio `AccountServiceImpl`.
Su prop√≥sito es asegurar que, cuando se solicita una cuenta existente, el servicio:

1. Busque correctamente la cuenta en el repositorio.
2. Mapee la entidad `Account` a su DTO (`AccountResponse`) usando el `AccountMapper`.
3. Devuelva exactamente `la misma referencia del objeto mapeado`, sin alterarlo ni crear una nueva instancia.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldReturnAccountResponseWhenAccountExists() {
        // given
        Account account = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", account);
        AccountResponse accountResponse = new AccountResponse(account.getId(), account.getHolder(), account.getBalance(), account.getBank().getName());

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(account));
        Mockito.when(this.accountMapper.toAccountResponse(account)).thenReturn(accountResponse);

        // when
        AccountResponse result = this.accountServiceUnderTest.findAccountById(1L);

        // then
        assertThat(result)
                .isNotNull()
                .isSameAs(accountResponse); // Verificaci√≥n de identidad de referencia
        assertThat(result)
                .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                .containsExactly(1L, "Milagros", new BigDecimal("2000"), bank.getName());
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountMapper).toAccountResponse(account);
    }
}
````

### üß† Concepto clave: `isSameAs()` vs `isEqualTo()`

En las pruebas de objetos en Java, es importante distinguir entre identidad e igualdad:

| M√©todo        | Qu√© verifica                                                   | Equivalente en Java | Caso de uso t√≠pico                                                                                               |
|:--------------|:---------------------------------------------------------------|:--------------------|:-----------------------------------------------------------------------------------------------------------------|
| `isSameAs()`  | Que ambas variables apuntan al **mismo objeto en memoria**     | `a == b`            | Cuando queremos confirmar que el m√©todo devuelve **exactamente la misma instancia**, sin duplicarla o recrearla. |
| `isEqualTo()` | Que los objetos son **l√≥gicamente iguales** (seg√∫n `equals()`) | `a.equals(b)`       | Cuando queremos validar **contenido o valores**, sin importar si la instancia es la misma.                       |

En este test, se usa `isSameAs()` porque el mock de `AccountMapper` fue configurado para devolver una instancia
espec√≠fica de `AccountResponse`.

De esta forma, el test garantiza que el servicio no transforma ni altera la referencia devuelta por el mapper,
confirmando que el m√©todo `findAccountById()` deleg√≥ correctamente la conversi√≥n.

‚úÖ Buenas pr√°cticas aplicadas

- Uso de `AccountTestFactory` para construir objetos de dominio consistentes y expresivos.
- Uso de mocks (`Mockito`) para aislar el servicio del repositorio y el mapper.
- `Verificaci√≥n de referencia` (`isSameAs`) para validar comportamiento estructural, no solo datos.
- `Verificaci√≥n de extracci√≥n de campos` (`extracting(...)`) para asegurar integridad de los valores.

## üß™ Lanza `AccountNotFoundException` cuando se busca una cuenta que no existe

Validar que el m√©todo `findAccountById(Long accountId)` lance la excepci√≥n `AccountNotFoundException` cuando se intenta
consultar una cuenta que no existe en el repositorio.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowAccountNotFoundExceptionWhenAccountDoesNotExist() {
        // given
        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.empty());

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.findAccountById(1L))
                .isInstanceOf(AccountNotFoundException.class)
                .hasMessage("No se encontr√≥ la cuenta con ID: 1");

        // then
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountMapper, Mockito.never()).toAccountResponse(Mockito.any(Account.class));
    }
}
````

## üß™ Validar obtenci√≥n del saldo de una cuenta existente

Validar que el m√©todo `getAccountBalance(Long accountId)` retorne correctamente el saldo (`balance`) de una cuenta
existente en el repositorio.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldGetBalanceOfAnAccountWhenAccountExists() {
        // given
        Account account = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(account));

        // when
        BigDecimal result = this.accountServiceUnderTest.getAccountBalance(1L);

        // then
        assertThat(result).isEqualByComparingTo(account.getBalance());
        Mockito.verify(this.accountRepository).findById(1L);
    }
}
````
