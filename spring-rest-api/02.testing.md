# üß™ Fase 2 ‚Äî Implementaci√≥n de Pruebas (JUnit & Mockito)

El objetivo de esta fase es garantizar la calidad, confiabilidad y consistencia del sistema mediante la implementaci√≥n
de pruebas unitarias e integradas, asegurando que cada componente del proyecto funcione de forma aislada y tambi√©n
correctamente en conjunto.

---

## ‚öôÔ∏è Configuraci√≥n Previa

Antes de comenzar con las pruebas, realizaremos algunos ajustes b√°sicos para preparar un entorno de test limpio,
aislado y reproducible.

### üßπ Eliminando la clase de prueba creada autom√°ticamente

Cuando generamos un nuevo proyecto con `Spring Boot`, el asistente crea por defecto una clase de prueba b√°sica como
esta:

````java

@SpringBootTest
class SpringRestApiApplicationTests {
    @Test
    void contextLoads() {
    }
}
````

üîç Detalles importantes:

- El nombre de la clase coincide con el nombre principal de la aplicaci√≥n.
- El m√©todo `contextLoads()` est√° anotado con `@Test`, indicando que es una prueba de `JUnit 5`.
- La anotaci√≥n `@SpringBootTest` indica que se cargar√° el `contexto completo de Spring` para la prueba.
  > M√°s adelante analizaremos en detalle qu√© hace exactamente esta anotaci√≥n y cu√°ndo conviene usarla.

‚ö†Ô∏è Por ahora, como vamos a enfocarnos en las `pruebas unitarias puras` (sin contexto de Spring), *eliminaremos
esta clase generada autom√°ticamente.* Esto nos permitir√° comenzar con nuestras propias clases de prueba bien
estructuradas y espec√≠ficas.

### üßæ Creando archivo de configuraci√≥n por defecto `application.yml`

Para evitar posibles conflictos con los archivos de configuraci√≥n del entorno principal (`src/main/resources`),
es recomendable definir un archivo de configuraci√≥n `por defecto para los tests`.

üìÅ Ruta recomendada: `src/test/resources/application.yml`

üß© Contenido inicial:

````yml
spring:
  application:
    name: spring-rest-api
````

üîç Explicaci√≥n:

- Este archivo define un contexto b√°sico para las pruebas.
- Si alguna prueba intenta acceder a propiedades de configuraci√≥n, `Spring Boot` tomar√° este archivo
  `desde el entorno de test`, en lugar de usar los definidos en `src/main/resources`.
- Esto previene errores por configuraciones incorrectas o no deseadas al ejecutar pruebas.

> ‚ö†Ô∏è Si no se define un archivo `application.yml` en `src/test/resources`, Spring Boot usar√° el de `src/main/resources`
> durante las pruebas. Esto puede provocar que las pruebas accedan a configuraciones reales, como bases de datos o
> servicios externos. Por eso, crear un archivo de configuraci√≥n aislado para tests es una pr√°ctica recomendada para
> proteger el entorno y evitar errores.

üí° Recomendaci√≥n:
> M√°s adelante, se puede definir un archivo `application-test.yml` con configuraciones espec√≠ficas para
> pruebas de integraci√≥n (como base de datos embebida, puerto aleatorio, etc.), y activarlo mediante
> `@ActiveProfiles("test")` en la clase de prueba o con la propiedad `spring.profiles.active=test` en el
> archivo `application.yml` del entorno de `test`. Esto permite mayor control y aislamiento por tipo de prueba.

---

# Unit Test - Test de Servicios (Mockito)

---

### üìñ Convenci√≥n de nombres para clases de prueba

Para facilitar la organizaci√≥n y comprensi√≥n de los distintos enfoques de prueba, nombraremos las clases de
test siguiendo esta estructura:

`<NombreDeLaImplementaci√≥n><TipoDeConfiguraci√≥n>Test`

Ejemplos:

- `AccountServiceImplMockitoManualTest` ‚Üí Pruebas unitarias con mocks definidos manualmente (`Mockito.mock(...)`)
- `AccountServiceImplMockitoAnnotationTest` ‚Üí Pruebas unitarias con anotaciones (`@Mock`, `@InjectMocks`)
- `AccountServiceImplSpringBootTest` ‚Üí Pruebas con contexto de Spring (`@SpringBootTest`, `@MockBean`, `@Autowired`)

> Esta convenci√≥n permite identificar r√°pidamente el enfoque utilizado y facilita la revisi√≥n y mantenimiento del
> c√≥digo de pruebas.

### üß™ Convenci√≥n de nombres para m√©todos de prueba

Adoptaremos una convenci√≥n basada en el estilo `BDD (Behavior-Driven Development)` para nombrar los m√©todos de prueba,
de modo que los nombres describan de forma clara, legible y autoexplicativa el comportamiento esperado del sistema.

````
should_<expectedBehavior>_when_<situation>
````

| Segmento             | Significado                                              | Ejemplo                                                                       |
|----------------------|----------------------------------------------------------|-------------------------------------------------------------------------------|
| `should_`            | Indica la expectativa o el comportamiento que se valida. | `shouldReturn`, `shouldThrow`, `shouldUpdate`                                 |
| `<expectedBehavior>` | Describe el resultado o acci√≥n esperada.                 | `shouldTransferBalance`, `shouldThrowException`, `shouldUpdateAccountBalance` |
| `_when_`             | Separa el comportamiento del contexto o condici√≥n.       | `whenAccountExists`, `whenAccountsAreFromSameBank`                            |
| `<situation>`        | Describe la situaci√≥n, entrada o escenario.              | `whenAccountIsNotFound`, `whenBalanceIsInsufficient`                          |

## üß™ Pruebas unitarias con Mockito manual

A continuaci√≥n se muestra la creaci√≥n de nuestra clase de prueba para el servicio `AccountServiceImpl` con la
creaci√≥n de un test unitario para el m√©todo `transfer()`.

Esta clase de prueba utiliza `Mockito.mock(...)` para simular manualmente las dependencias del servicio
`AccountServiceImpl`.

- Se usa la interfaz `AccountService` como tipo para mantener flexibilidad.
- El objeto bajo prueba se nombra como `accountServiceUnderTest` para mejorar la claridad.
- No se levanta contexto de Spring, lo que permite pruebas r√°pidas y aisladas.

> Esta estructura es ideal para validar la l√≥gica del servicio sin depender de la infraestructura.

### üß© AccountTestFactory ‚Äî Generador de datos de prueba

Esta clase se utiliza para crear objetos de dominio reutilizables en pruebas unitarias, evitando la duplicaci√≥n de
c√≥digo y manteniendo los tests limpios y consistentes.

````java

@UtilityClass
public class AccountTestFactory {
    public static Account createAccount(Long accountId, String holder, BigDecimal balance) {
        return Account.builder()
                .id(accountId)
                .holder(holder)
                .balance(balance)
                .build();
    }

    public static Bank createBank(Long bankId, String name, Account... accounts) {
        Bank bank = Bank.builder()
                .id(bankId)
                .name(name)
                .totalTransfers(0)
                .build();
        Arrays.stream(accounts).forEach(bank::addAccount);
        return bank;
    }
}
````

Buenas pr√°cticas aplicadas:

- Uso de la anotaci√≥n `@UtilityClass` de `Lombok` para declarar una clase utilitaria sin instanciaci√≥n.
- M√©todos est√°ticos y deterministas, asegurando independencia entre pruebas.
- Evita la duplicaci√≥n de c√≥digo de inicializaci√≥n en m√∫ltiples clases de prueba.
- Promueve la reutilizaci√≥n y consistencia en la creaci√≥n de entidades de dominio.

### üß© AccountServiceImplMockitoManualTest ‚Äî Prueba unitaria de transferencia

Prueba unitaria enfocada en validar la l√≥gica del m√©todo `transfer(...)` de `AccountServiceImpl` mediante mocks
configurados manualmente.

````java
class AccountServiceImplMockitoManualTest {

    private AccountRepository accountRepository;
    private BankRepository bankRepository;
    private AccountMapper accountMapper;
    private AccountService accountServiceUnderTest;

    @BeforeEach
    void setUp() {
        this.accountRepository = Mockito.mock(AccountRepository.class);
        this.bankRepository = Mockito.mock(BankRepository.class);
        this.accountMapper = Mockito.mock(AccountMapper.class);
        this.accountServiceUnderTest = new AccountServiceImpl(this.accountRepository, this.bankRepository, this.accountMapper);
    }

    @Test
    void shouldTransferBalanceWhenAccountsAreFromSameBank() {
        // given
        TransactionRequest request = new TransactionRequest(1L, 2L, new BigDecimal("700"));
        Account sourceAccount = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Account targetAccount = AccountTestFactory.createAccount(2L, "Kiara", new BigDecimal("1000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", sourceAccount, targetAccount);

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(sourceAccount));
        Mockito.when(this.accountRepository.findById(2L)).thenReturn(Optional.of(targetAccount));

        // when
        this.accountServiceUnderTest.transfer(request);

        // then
        assertThat(sourceAccount.getBalance()).isEqualByComparingTo("1300");
        assertThat(targetAccount.getBalance()).isEqualByComparingTo("1700");
        assertThat(bank.getTotalTransfers()).isEqualTo(1);
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository).findById(2L);
        Mockito.verify(this.accountRepository, Mockito.times(2)).findById(Mockito.anyLong());
        Mockito.verify(this.bankRepository, Mockito.never()).findById(Mockito.anyLong());
        Mockito.verify(this.accountRepository).save(sourceAccount);
        Mockito.verify(this.accountRepository).save(targetAccount);
        Mockito.verify(this.accountRepository, Mockito.times(2)).save(Mockito.any(Account.class));
        Mockito.verify(this.bankRepository).save(bank);
    }
}
````

Buenas pr√°cticas aplicadas:

- Estructura clara `Given‚ÄìWhen‚ÄìThen`, que mejora la legibilidad del test.
- Uso manual de mocks (`Mockito.mock(...)`) para un control expl√≠cito de dependencias.
- Verificaci√≥n exhaustiva de interacciones (`verify(...)`) para asegurar el flujo correcto del m√©todo.
- Reutilizaci√≥n de objetos mediante `AccountTestFactory`.
- Nombrado del m√©todo de prueba siguiendo la convenci√≥n `BDD`: `should_<expectedBehavior>_when_<situation>` ‚Üí
  `shouldTransferBalanceWhenAccountsAreFromSameBank`.
- Aislamiento total del entorno (sin dependencia de base de datos ni contexto Spring).

### üß© Escribiendo tests `assertThatThrownBy` para afirmar que la excepci√≥n lanzada sea correcta

Crearemos un test para verificar que se est√© lanzando nuestra excepci√≥n personalizada `InsufficientBalanceException`
cuando el monto a transferir sea mayor que el saldo disponible de la cuenta origen.

````java

class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowInsufficientBalanceExceptionWhenSourceAccountHasLowBalance() {
        // given
        TransactionRequest request = new TransactionRequest(1L, 2L, new BigDecimal("5000"));
        Account sourceAccount = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Account targetAccount = AccountTestFactory.createAccount(2L, "Kiara", new BigDecimal("1000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", sourceAccount, targetAccount);

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(sourceAccount));
        Mockito.when(this.accountRepository.findById(2L)).thenReturn(Optional.of(targetAccount));

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.transfer(request))
                .isInstanceOf(InsufficientBalanceException.class)
                .hasMessage("Saldo insuficiente en la cuenta del titular Milagros (ID: 1)");

        // then
        assertThat(sourceAccount.getBalance()).isEqualByComparingTo("2000");
        assertThat(targetAccount.getBalance()).isEqualByComparingTo("1000");
        assertThat(bank.getTotalTransfers()).isZero();
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository).findById(2L);
        Mockito.verify(this.accountRepository, Mockito.times(2)).findById(Mockito.anyLong());
        Mockito.verify(this.bankRepository, Mockito.never()).findById(Mockito.anyLong());
        Mockito.verify(this.accountRepository, Mockito.never()).save(sourceAccount);
        Mockito.verify(this.accountRepository, Mockito.never()).save(targetAccount);
        Mockito.verify(this.bankRepository, Mockito.never()).save(bank);
    }
}
````

üí° Ajuste aplicado

> En la implementaci√≥n real (`AccountServiceImpl`) se movi√≥ la actualizaci√≥n del contador de transferencias despu√©s de
> las operaciones de retiro y dep√≥sito exitosas.
>
> De esta manera, si ocurre una excepci√≥n (como `InsufficientBalanceException`), la variable `totalTransfers` no se ve
> afectada, manteniendo la coherencia del estado del dominio incluso sin `@Transactional`.

### üß© Escribiendo test con el `isSameAs`

Este test valida el comportamiento del m√©todo `findAccountById(Long accountId)` del servicio `AccountServiceImpl`.
Su prop√≥sito es asegurar que, cuando se solicita una cuenta existente, el servicio:

1. Busque correctamente la cuenta en el repositorio.
2. Mapee la entidad `Account` a su DTO (`AccountResponse`) usando el `AccountMapper`.
3. Devuelva exactamente `la misma referencia del objeto mapeado`, sin alterarlo ni crear una nueva instancia.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldReturnAccountResponseWhenAccountExists() {
        // given
        Account account = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", account);
        AccountResponse accountResponse = new AccountResponse(account.getId(), account.getHolder(), account.getBalance(), account.getBank().getName());

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(account));
        Mockito.when(this.accountMapper.toAccountResponse(account)).thenReturn(accountResponse);

        // when
        AccountResponse result = this.accountServiceUnderTest.findAccountById(1L);

        // then
        assertThat(result)
                .isNotNull()
                .isSameAs(accountResponse); // Verificaci√≥n de identidad de referencia
        assertThat(result)
                .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                .containsExactly(1L, "Milagros", new BigDecimal("2000"), bank.getName());
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountMapper).toAccountResponse(account);
    }
}
````

### üß† Concepto clave: `isSameAs()` vs `isEqualTo()`

En las pruebas de objetos en Java, es importante distinguir entre identidad e igualdad:

| M√©todo        | Qu√© verifica                                                   | Equivalente en Java | Caso de uso t√≠pico                                                                                               |
|:--------------|:---------------------------------------------------------------|:--------------------|:-----------------------------------------------------------------------------------------------------------------|
| `isSameAs()`  | Que ambas variables apuntan al **mismo objeto en memoria**     | `a == b`            | Cuando queremos confirmar que el m√©todo devuelve **exactamente la misma instancia**, sin duplicarla o recrearla. |
| `isEqualTo()` | Que los objetos son **l√≥gicamente iguales** (seg√∫n `equals()`) | `a.equals(b)`       | Cuando queremos validar **contenido o valores**, sin importar si la instancia es la misma.                       |

En este test, se usa `isSameAs()` porque el mock de `AccountMapper` fue configurado para devolver una instancia
espec√≠fica de `AccountResponse`.

De esta forma, el test garantiza que el servicio no transforma ni altera la referencia devuelta por el mapper,
confirmando que el m√©todo `findAccountById()` deleg√≥ correctamente la conversi√≥n.

‚úÖ Buenas pr√°cticas aplicadas

- Uso de `AccountTestFactory` para construir objetos de dominio consistentes y expresivos.
- Uso de mocks (`Mockito`) para aislar el servicio del repositorio y el mapper.
- `Verificaci√≥n de referencia` (`isSameAs`) para validar comportamiento estructural, no solo datos.
- `Verificaci√≥n de extracci√≥n de campos` (`extracting(...)`) para asegurar integridad de los valores.

### üß© Lanza `AccountNotFoundException` cuando se busca una cuenta que no existe

Validar que el m√©todo `findAccountById(Long accountId)` lance la excepci√≥n `AccountNotFoundException` cuando se intenta
consultar una cuenta que no existe en el repositorio.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowAccountNotFoundExceptionWhenAccountDoesNotExist() {
        // given
        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.empty());

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.findAccountById(1L))
                .isInstanceOf(AccountNotFoundException.class)
                .hasMessage("No se encontr√≥ la cuenta con ID: 1");

        // then
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountMapper, Mockito.never()).toAccountResponse(Mockito.any(Account.class));
    }
}
````

### üß© Validar obtenci√≥n del saldo de una cuenta existente

Validar que el m√©todo `getAccountBalance(Long accountId)` retorne correctamente el saldo (`balance`) de una cuenta
existente en el repositorio.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldGetBalanceOfAnAccountWhenAccountExists() {
        // given
        Account account = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(account));

        // when
        BigDecimal result = this.accountServiceUnderTest.getAccountBalance(1L);

        // then
        assertThat(result).isEqualByComparingTo(account.getBalance());
        Mockito.verify(this.accountRepository).findById(1L);
    }
}
````

### üß© Validar la obtenci√≥n del total de transferencias registradas en un banco

Comprobar que el servicio `AccountServiceImpl` obtiene correctamente el n√∫mero total de transferencias asociadas a un
banco existente.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldGetTotalTransfersWhenBankExists() {
        // given
        Bank bank = AccountTestFactory.createBank(1L, "BCP");
        bank.setTotalTransfers(10);

        Mockito.when(this.bankRepository.findById(1L)).thenReturn(Optional.of(bank));

        // when
        int result = this.accountServiceUnderTest.countTotalTransfersToBank(1L);

        // then
        assertThat(result).isEqualTo(10);
        Mockito.verify(this.bankRepository).findById(1L);
    }
}
````

### üß© Obtiene todas las cuentas existentes

Este test valida que el m√©todo `findAllAccounts()` retorne correctamente todas las cuentas existentes cuando el
repositorio contiene datos. Se utiliza `containsExactlyElementsOf(accountResponses)` para garantizar que:

- Los elementos devueltos sean exactamente los esperados.
- Se respeten el orden y el contenido de la lista original.

Esta verificaci√≥n es suficiente porque `AccountResponse` es un `record`, por lo que su implementaci√≥n de `equals()`
y `hashCode()` compara los valores de todos sus campos y no las referencias en memoria.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldGetAllAccountsWhenAccountsExists() {
        // given
        List<AccountResponse> accountResponses = List.of(
                new AccountResponse(1L, "Milagros", new BigDecimal("2000"), "BCP"),
                new AccountResponse(2L, "Kiara", new BigDecimal("1000"), "BCP")
        );
        Mockito.when(this.accountRepository.getAllAccounts()).thenReturn(accountResponses);

        // when
        List<AccountResponse> result = this.accountServiceUnderTest.findAllAccounts();

        // then
        assertThat(result)
                .isNotEmpty()
                .hasSize(2)
                .containsExactlyElementsOf(accountResponses);
        Mockito.verify(this.accountRepository).getAllAccounts();
    }
}
````

### üß© Registro exitoso de una nueva cuenta bancaria

Este test verifica que una cuenta nueva pueda ser registrada correctamente cuando el banco asociado existe.
Adem√°s, `simula el comportamiento real de JPA` al `asignar autom√°ticamente un ID al persistir una entidad`,
garantizando que el flujo de guardado en el servicio funcione como se espera.

Antes de mostrar la implementaci√≥n de nuestro test modificaremos nuestra f√°brica de datos `AccountTestFactory`
agregando nuevos m√©todos de conversi√≥n con los que estaremos trabajando en los test.

````java

@UtilityClass
public class AccountTestFactory {

    public static Bank createBank(Long bankId, String name, Account... accounts) {
        Bank bank = Bank.builder()
                .id(bankId)
                .name(name)
                .totalTransfers(0)
                .build();
        Arrays.stream(accounts).forEach(bank::addAccount);
        return bank;
    }

    public static Account createAccount(Long accountId, String holder, BigDecimal balance) {
        return Account.builder()
                .id(accountId)
                .holder(holder)
                .balance(balance)
                .build();
    }

    public static Account createAccountWithoutId(AccountCreateRequest request, Bank bank) {
        return Account.builder()
                .holder(request.holder())
                .balance(request.balance())
                .bank(bank)
                .build();
    }

    public static Account createAccountWithId(Long expectedAccountId, AccountCreateRequest request, Bank bank) {
        return Account.builder()
                .id(expectedAccountId)
                .holder(request.holder())
                .balance(request.balance())
                .bank(bank)
                .build();
    }

    public static AccountResponse toAccountResponse(Account account) {
        return new AccountResponse(
                account.getId(),
                account.getHolder(),
                account.getBalance(),
                account.getBank().getName()
        );
    }

    public static AccountCreateRequest createAccountRequest(String holder, BigDecimal balance, Long bankId) {
        return new AccountCreateRequest(holder, balance, bankId);
    }
}
````

Finalmente, definimos nuestro test para guardar una cuenta correctamente.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldSaveNewAccountWhenBankExists() {
        // given
        AccountCreateRequest accountRequest = AccountTestFactory.createAccountRequest("Milagros", new BigDecimal("2000"), 1L);
        Bank bank = AccountTestFactory.createBank(1L, "BCP");
        Account accountWithoutId = AccountTestFactory.createAccountWithoutId(accountRequest, bank);
        Account accountWithId = AccountTestFactory.createAccountWithId(10L, accountRequest, bank);
        AccountResponse expectedResponse = AccountTestFactory.toAccountResponse(accountWithId);

        assertThat(accountWithoutId.getId()).isNull(); // Verificamos que no tenga ID antes del save

        Mockito.when(this.bankRepository.findById(1L)).thenReturn(Optional.of(bank));
        Mockito.when(this.accountMapper.toAccount(accountRequest, bank)).thenReturn(accountWithoutId);

        Mockito.doAnswer(invocation -> {
            Account saved = invocation.getArgument(0);
            saved.setId(10L); // Simula el comportamiento de JPA: asigna el ID directamente al objeto original
            return saved;
        }).when(this.accountRepository).save(accountWithoutId);

        Mockito.when(this.accountMapper.toAccountResponse(accountWithoutId)) // El objeto accountWithoutId ya tiene ID asignado
                .thenReturn(expectedResponse);

        // when
        AccountResponse actualResponse = this.accountServiceUnderTest.saveAccount(accountRequest);

        // then
        assertThat(accountWithoutId.getId())
                .isNotNull() // Verificaci√≥n expl√≠cita del cambio de estado
                .isEqualTo(10L);
        assertThat(actualResponse)
                .isNotNull()
                .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                .containsExactly(10L, "Milagros", new BigDecimal("2000"), "BCP");
        Mockito.verify(this.bankRepository).findById(1L);
        Mockito.verify(this.accountMapper).toAccount(accountRequest, bank);
        Mockito.verify(this.accountRepository).save(accountWithoutId);
        Mockito.verify(this.accountMapper).toAccountResponse(accountWithoutId);
    }
}
````

üß© Aspectos t√©cnicos destacados

- 1Ô∏è‚É£ `Simulaci√≥n realista del comportamiento de persistencia`: El uso de `Mockito.doAnswer(...)` permite emular lo que
  hace un repositorio JPA real: cuando se guarda una nueva entidad sin ID, el repositorio le asigna un identificador
  directamente sobre el mismo objeto en memoria. Esto refuerza el realismo del test sin depender de una base de datos
  en memoria ni mocks complicados.
- 2Ô∏è‚É£ `Validaci√≥n del cambio de estado`: El test no solo comprueba el resultado (`AccountResponse`), sino tambi√©n el
  efecto colateral esperado: que el objeto `accountWithoutId` haya mutado su estado asign√°ndosele un `ID`.
- 3Ô∏è‚É£ `Uso de AccountTestFactory`: La f√°brica centraliza la creaci√≥n de `entidades` y `DTOs`, reduciendo ruido en los
  tests y garantizando consistencia entre ellos. Esto hace que los casos de prueba sean m√°s expresivos, legibles y
  mantenibles.

### üß© Realiza un retiro exitoso desde una cuenta existente

Este test valida el flujo exitoso del m√©todo `withdraw(...)` en el servicio. El escenario verifica que, al realizar un
retiro:

- ‚úÖ Se encuentra la cuenta por su ID.
- ‚úÖ Se descuenta correctamente el monto solicitado del balance original.
- ‚úÖ El repositorio persiste la cuenta actualizada.
- ‚úÖ El mapper convierte la entidad resultante en un DTO de respuesta (AccountResponse).

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldWithdrawAmountSuccessfullyWhenAccountExists() {
        // given
        Account accountBeforeWithdrawal = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Account accountAfterWithdrawal = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("1500"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", accountBeforeWithdrawal, accountAfterWithdrawal);
        WithdrawalRequest request = new WithdrawalRequest(new BigDecimal("500"));
        AccountResponse expectedResponse = AccountTestFactory.toAccountResponse(accountAfterWithdrawal);

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(accountBeforeWithdrawal));
        Mockito.when(this.accountRepository.save(accountBeforeWithdrawal)).thenReturn(accountBeforeWithdrawal); // Ya mutado
        Mockito.when(this.accountMapper.toAccountResponse(accountBeforeWithdrawal)).thenReturn(expectedResponse);

        // when
        AccountResponse actualResponse = this.accountServiceUnderTest.withdraw(1L, request);

        // then
        assertThat(accountBeforeWithdrawal.getBalance())
                .isEqualByComparingTo("1500");
        assertThat(actualResponse)
                .isNotNull()
                .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                .containsExactly(1L, "Milagros", new BigDecimal("1500"), bank.getName());
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository).save(accountBeforeWithdrawal);
        Mockito.verify(this.accountMapper).toAccountResponse(accountBeforeWithdrawal);
    }
}
````

El uso de: `Mockito.when(this.accountRepository.save(accountBeforeWithdrawal)).thenReturn(accountBeforeWithdrawal)`
simula que la operaci√≥n `save()` retorna la misma instancia mutada, reflejando c√≥mo JPA administra entidades en estado
managed dentro de una transacci√≥n.

Por su parte, el `assertThat(accountBeforeWithdrawal.getBalance())` confirma la mutaci√≥n en memoria antes de que el
objeto sea devuelto como respuesta.

### üß© Falla de retiro por saldo insuficiente

Este test valida que el servicio no permita realizar un retiro cuando el saldo disponible es menor al monto solicitado,
y que se lance correctamente la excepci√≥n `InsufficientBalanceException`.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowInsufficientBalanceExceptionWhenAccountHasLowBalance() {
        // given
        Account account = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("1000"));
        WithdrawalRequest request = new WithdrawalRequest(new BigDecimal("1200"));

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(account));

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.withdraw(1L, request))
                .isInstanceOf(InsufficientBalanceException.class)
                .hasMessage("Saldo insuficiente en la cuenta del titular Milagros (ID: 1)");

        // then
        assertThat(account.getBalance()).isEqualByComparingTo("1000");
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository, Mockito.never()).save(Mockito.any());
        Mockito.verify(this.accountMapper, Mockito.never()).toAccountResponse(Mockito.any());
    }
}
````

### üß© Falla de retiro cuando la cuenta no existe

Este test valida que el servicio de retiros gestione correctamente el escenario donde la cuenta no existe, lanzando la
excepci√≥n esperada `AccountNotFoundException`.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowAccountNotFoundExceptionWhenAccountDoesNotExistDuringWithdrawal() {
        // given
        WithdrawalRequest request = new WithdrawalRequest(new BigDecimal("1200"));
        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.empty());

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.withdraw(1L, request))
                .isInstanceOf(AccountNotFoundException.class)
                .hasMessage("No se encontr√≥ la cuenta con ID: 1");

        // then
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verifyNoMoreInteractions(this.accountRepository, this.accountMapper);
    }
}
````

El `verifyNoMoreInteractions(...)` expresa la intenci√≥n de forma clara y global. En lugar de verificar uno por uno
que no se llamaron m√©todos como `save(...)` o `toAccountResponse(...)`, `verifyNoMoreInteractions(...)` declara
expl√≠citamente:

> ‚ÄúNo se debe haber llamado a nada m√°s en estos mocks.‚Äù

Esto deja el test m√°s limpio y sem√°ntico.
