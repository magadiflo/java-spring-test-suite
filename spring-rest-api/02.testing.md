# üß™ Fase 2 ‚Äî Implementaci√≥n de Pruebas (JUnit & Mockito)

El objetivo de esta fase es garantizar la calidad, confiabilidad y consistencia del sistema mediante la implementaci√≥n
de pruebas unitarias e integradas, asegurando que cada componente del proyecto funcione de forma aislada y tambi√©n
correctamente en conjunto.

---

## ‚öôÔ∏è Configuraci√≥n Previa

Antes de comenzar con las pruebas, realizaremos algunos ajustes b√°sicos para preparar un entorno de test limpio,
aislado y reproducible.

### üßπ Eliminando la clase de prueba creada autom√°ticamente

Cuando generamos un nuevo proyecto con `Spring Boot`, el asistente crea por defecto una clase de prueba b√°sica como
esta:

````java

@SpringBootTest
class SpringRestApiApplicationTests {
    @Test
    void contextLoads() {
    }
}
````

üîç Detalles importantes:

- El nombre de la clase coincide con el nombre principal de la aplicaci√≥n.
- El m√©todo `contextLoads()` est√° anotado con `@Test`, indicando que es una prueba de `JUnit 5`.
- La anotaci√≥n `@SpringBootTest` indica que se cargar√° el `contexto completo de Spring` para la prueba.
  > M√°s adelante analizaremos en detalle qu√© hace exactamente esta anotaci√≥n y cu√°ndo conviene usarla.

‚ö†Ô∏è Por ahora, como vamos a enfocarnos en las `pruebas unitarias puras` (sin contexto de Spring), *eliminaremos
esta clase generada autom√°ticamente.* Esto nos permitir√° comenzar con nuestras propias clases de prueba bien
estructuradas y espec√≠ficas.

### üßæ Creando archivo de configuraci√≥n por defecto `application.yml`

Para evitar posibles conflictos con los archivos de configuraci√≥n del entorno principal (`src/main/resources`),
es recomendable definir un archivo de configuraci√≥n `por defecto para los tests`.

üìÅ Ruta recomendada: `src/test/resources/application.yml`

üß© Contenido inicial:

````yml
spring:
  application:
    name: spring-rest-api
````

üîç Explicaci√≥n:

- Este archivo define un contexto b√°sico para las pruebas.
- Si alguna prueba intenta acceder a propiedades de configuraci√≥n, `Spring Boot` tomar√° este archivo
  `desde el entorno de test`, en lugar de usar los definidos en `src/main/resources`.
- Esto previene errores por configuraciones incorrectas o no deseadas al ejecutar pruebas.

> ‚ö†Ô∏è Si no se define un archivo `application.yml` en `src/test/resources`, Spring Boot usar√° el de `src/main/resources`
> durante las pruebas. Esto puede provocar que las pruebas accedan a configuraciones reales, como bases de datos o
> servicios externos. Por eso, crear un archivo de configuraci√≥n aislado para tests es una pr√°ctica recomendada para
> proteger el entorno y evitar errores.

üí° Recomendaci√≥n:
> M√°s adelante, se puede definir un archivo `application-test.yml` con configuraciones espec√≠ficas para
> pruebas de integraci√≥n (como base de datos embebida, puerto aleatorio, etc.), y activarlo mediante
> `@ActiveProfiles("test")` en la clase de prueba o con la propiedad `spring.profiles.active=test` en el
> archivo `application.yml` del entorno de `test`. Esto permite mayor control y aislamiento por tipo de prueba.

---

# Unit Test - Test de Servicios (Mockito)

---

### üìñ Convenci√≥n de nombres para clases de prueba

Para facilitar la organizaci√≥n y comprensi√≥n de los distintos enfoques de prueba, nombraremos las clases de
test siguiendo esta estructura:

`<NombreDeLaImplementaci√≥n><TipoDeConfiguraci√≥n>Test`

Ejemplos:

- `AccountServiceImplMockitoManualTest` ‚Üí Pruebas unitarias con mocks definidos manualmente (`Mockito.mock(...)`)
- `AccountServiceImplMockitoAnnotationTest` ‚Üí Pruebas unitarias con anotaciones (`@Mock`, `@InjectMocks`)
- `AccountServiceImplSpringBootTest` ‚Üí Pruebas con contexto de Spring (`@SpringBootTest`, `@MockBean`, `@Autowired`)

> Esta convenci√≥n permite identificar r√°pidamente el enfoque utilizado y facilita la revisi√≥n y mantenimiento del
> c√≥digo de pruebas.

### üß™ Convenci√≥n de nombres para m√©todos de prueba

Adoptaremos una convenci√≥n basada en el estilo `BDD (Behavior-Driven Development)` para nombrar los m√©todos de prueba,
de modo que los nombres describan de forma clara, legible y autoexplicativa el comportamiento esperado del sistema.

````
should_<expectedBehavior>_when_<situation>
````

| Segmento             | Significado                                              | Ejemplo                                                                       |
|----------------------|----------------------------------------------------------|-------------------------------------------------------------------------------|
| `should_`            | Indica la expectativa o el comportamiento que se valida. | `shouldReturn`, `shouldThrow`, `shouldUpdate`                                 |
| `<expectedBehavior>` | Describe el resultado o acci√≥n esperada.                 | `shouldTransferBalance`, `shouldThrowException`, `shouldUpdateAccountBalance` |
| `_when_`             | Separa el comportamiento del contexto o condici√≥n.       | `whenAccountExists`, `whenAccountsAreFromSameBank`                            |
| `<situation>`        | Describe la situaci√≥n, entrada o escenario.              | `whenAccountIsNotFound`, `whenBalanceIsInsufficient`                          |

## üß™ Pruebas unitarias con Mockito manual

A continuaci√≥n se muestra la creaci√≥n de nuestra clase de prueba para el servicio `AccountServiceImpl` con la
creaci√≥n de un test unitario para el m√©todo `transfer()`.

Esta clase de prueba utiliza `Mockito.mock(...)` para simular manualmente las dependencias del servicio
`AccountServiceImpl`.

- Se usa la interfaz `AccountService` como tipo para mantener flexibilidad.
- El objeto bajo prueba se nombra como `accountServiceUnderTest` para mejorar la claridad.
- No se levanta contexto de Spring, lo que permite pruebas r√°pidas y aisladas.

> Esta estructura es ideal para validar la l√≥gica del servicio sin depender de la infraestructura.

### üß© AccountTestFactory ‚Äî Generador de datos de prueba

Esta clase se utiliza para crear objetos de dominio reutilizables en pruebas unitarias, evitando la duplicaci√≥n de
c√≥digo y manteniendo los tests limpios y consistentes.

````java

@UtilityClass
public class AccountTestFactory {
    public static Account createAccount(Long accountId, String holder, BigDecimal balance) {
        return Account.builder()
                .id(accountId)
                .holder(holder)
                .balance(balance)
                .build();
    }

    public static Bank createBank(Long bankId, String name, Account... accounts) {
        Bank bank = Bank.builder()
                .id(bankId)
                .name(name)
                .totalTransfers(0)
                .build();
        Arrays.stream(accounts).forEach(bank::addAccount);
        return bank;
    }
}
````

Buenas pr√°cticas aplicadas:

- Uso de la anotaci√≥n `@UtilityClass` de `Lombok` para declarar una clase utilitaria sin instanciaci√≥n.
- M√©todos est√°ticos y deterministas, asegurando independencia entre pruebas.
- Evita la duplicaci√≥n de c√≥digo de inicializaci√≥n en m√∫ltiples clases de prueba.
- Promueve la reutilizaci√≥n y consistencia en la creaci√≥n de entidades de dominio.

### üß© AccountServiceImplMockitoManualTest ‚Äî Prueba unitaria de transferencia

Prueba unitaria enfocada en validar la l√≥gica del m√©todo `transfer(...)` de `AccountServiceImpl` mediante mocks
configurados manualmente.

````java
class AccountServiceImplMockitoManualTest {

    private AccountRepository accountRepository;
    private BankRepository bankRepository;
    private AccountMapper accountMapper;
    private AccountService accountServiceUnderTest;

    @BeforeEach
    void setUp() {
        this.accountRepository = Mockito.mock(AccountRepository.class);
        this.bankRepository = Mockito.mock(BankRepository.class);
        this.accountMapper = Mockito.mock(AccountMapper.class);
        this.accountServiceUnderTest = new AccountServiceImpl(this.accountRepository, this.bankRepository, this.accountMapper);
    }

    @Test
    void shouldTransferBalanceWhenAccountsAreFromSameBank() {
        // given
        TransactionRequest request = new TransactionRequest(1L, 2L, new BigDecimal("700"));
        Account sourceAccount = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Account targetAccount = AccountTestFactory.createAccount(2L, "Kiara", new BigDecimal("1000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", sourceAccount, targetAccount);

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(sourceAccount));
        Mockito.when(this.accountRepository.findById(2L)).thenReturn(Optional.of(targetAccount));

        // when
        this.accountServiceUnderTest.transfer(request);

        // then
        assertThat(sourceAccount.getBalance()).isEqualByComparingTo("1300");
        assertThat(targetAccount.getBalance()).isEqualByComparingTo("1700");
        assertThat(bank.getTotalTransfers()).isEqualTo(1);
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository).findById(2L);
        Mockito.verify(this.accountRepository, Mockito.times(2)).findById(Mockito.anyLong());
        Mockito.verify(this.bankRepository, Mockito.never()).findById(Mockito.anyLong());
        Mockito.verify(this.accountRepository).save(sourceAccount);
        Mockito.verify(this.accountRepository).save(targetAccount);
        Mockito.verify(this.accountRepository, Mockito.times(2)).save(Mockito.any(Account.class));
        Mockito.verify(this.bankRepository).save(bank);
    }
}
````

Buenas pr√°cticas aplicadas:

- Estructura clara `Given‚ÄìWhen‚ÄìThen`, que mejora la legibilidad del test.
- Uso manual de mocks (`Mockito.mock(...)`) para un control expl√≠cito de dependencias.
- Verificaci√≥n exhaustiva de interacciones (`verify(...)`) para asegurar el flujo correcto del m√©todo.
- Reutilizaci√≥n de objetos mediante `AccountTestFactory`.
- Nombrado del m√©todo de prueba siguiendo la convenci√≥n `BDD`: `should_<expectedBehavior>_when_<situation>` ‚Üí
  `shouldTransferBalanceWhenAccountsAreFromSameBank`.
- Aislamiento total del entorno (sin dependencia de base de datos ni contexto Spring).

### üß© Escribiendo tests `assertThatThrownBy` para afirmar que la excepci√≥n lanzada sea correcta

Crearemos un test para verificar que se est√© lanzando nuestra excepci√≥n personalizada `InsufficientBalanceException`
cuando el monto a transferir sea mayor que el saldo disponible de la cuenta origen.

````java

class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowInsufficientBalanceExceptionWhenSourceAccountHasLowBalance() {
        // given
        TransactionRequest request = new TransactionRequest(1L, 2L, new BigDecimal("5000"));
        Account sourceAccount = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Account targetAccount = AccountTestFactory.createAccount(2L, "Kiara", new BigDecimal("1000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", sourceAccount, targetAccount);

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(sourceAccount));
        Mockito.when(this.accountRepository.findById(2L)).thenReturn(Optional.of(targetAccount));

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.transfer(request))
                .isInstanceOf(InsufficientBalanceException.class)
                .hasMessage("Saldo insuficiente en la cuenta del titular Milagros (ID: 1)");

        // then
        assertThat(sourceAccount.getBalance()).isEqualByComparingTo("2000");
        assertThat(targetAccount.getBalance()).isEqualByComparingTo("1000");
        assertThat(bank.getTotalTransfers()).isZero();
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository).findById(2L);
        Mockito.verify(this.accountRepository, Mockito.times(2)).findById(Mockito.anyLong());
        Mockito.verify(this.bankRepository, Mockito.never()).findById(Mockito.anyLong());
        Mockito.verify(this.accountRepository, Mockito.never()).save(sourceAccount);
        Mockito.verify(this.accountRepository, Mockito.never()).save(targetAccount);
        Mockito.verify(this.bankRepository, Mockito.never()).save(bank);
    }
}
````

üí° Ajuste aplicado

> En la implementaci√≥n real (`AccountServiceImpl`) se movi√≥ la actualizaci√≥n del contador de transferencias despu√©s de
> las operaciones de retiro y dep√≥sito exitosas.
>
> De esta manera, si ocurre una excepci√≥n (como `InsufficientBalanceException`), la variable `totalTransfers` no se ve
> afectada, manteniendo la coherencia del estado del dominio incluso sin `@Transactional`.

### üß© Escribiendo test con el `isSameAs`

Este test valida el comportamiento del m√©todo `findAccountById(Long accountId)` del servicio `AccountServiceImpl`.
Su prop√≥sito es asegurar que, cuando se solicita una cuenta existente, el servicio:

1. Busque correctamente la cuenta en el repositorio.
2. Mapee la entidad `Account` a su DTO (`AccountResponse`) usando el `AccountMapper`.
3. Devuelva exactamente `la misma referencia del objeto mapeado`, sin alterarlo ni crear una nueva instancia.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldReturnAccountResponseWhenAccountExists() {
        // given
        Account account = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", account);
        AccountResponse accountResponse = new AccountResponse(account.getId(), account.getHolder(), account.getBalance(), account.getBank().getName());

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(account));
        Mockito.when(this.accountMapper.toAccountResponse(account)).thenReturn(accountResponse);

        // when
        AccountResponse result = this.accountServiceUnderTest.findAccountById(1L);

        // then
        assertThat(result)
                .isNotNull()
                .isSameAs(accountResponse); // Verificaci√≥n de identidad de referencia
        assertThat(result)
                .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                .containsExactly(1L, "Milagros", new BigDecimal("2000"), bank.getName());
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountMapper).toAccountResponse(account);
    }
}
````

### üß† Concepto clave: `isSameAs()` vs `isEqualTo()`

En las pruebas de objetos en Java, es importante distinguir entre identidad e igualdad:

| M√©todo        | Qu√© verifica                                                   | Equivalente en Java | Caso de uso t√≠pico                                                                                               |
|:--------------|:---------------------------------------------------------------|:--------------------|:-----------------------------------------------------------------------------------------------------------------|
| `isSameAs()`  | Que ambas variables apuntan al **mismo objeto en memoria**     | `a == b`            | Cuando queremos confirmar que el m√©todo devuelve **exactamente la misma instancia**, sin duplicarla o recrearla. |
| `isEqualTo()` | Que los objetos son **l√≥gicamente iguales** (seg√∫n `equals()`) | `a.equals(b)`       | Cuando queremos validar **contenido o valores**, sin importar si la instancia es la misma.                       |

En este test, se usa `isSameAs()` porque el mock de `AccountMapper` fue configurado para devolver una instancia
espec√≠fica de `AccountResponse`.

De esta forma, el test garantiza que el servicio no transforma ni altera la referencia devuelta por el mapper,
confirmando que el m√©todo `findAccountById()` deleg√≥ correctamente la conversi√≥n.

‚úÖ Buenas pr√°cticas aplicadas

- Uso de `AccountTestFactory` para construir objetos de dominio consistentes y expresivos.
- Uso de mocks (`Mockito`) para aislar el servicio del repositorio y el mapper.
- `Verificaci√≥n de referencia` (`isSameAs`) para validar comportamiento estructural, no solo datos.
- `Verificaci√≥n de extracci√≥n de campos` (`extracting(...)`) para asegurar integridad de los valores.

### üß© Lanza `AccountNotFoundException` cuando se busca una cuenta que no existe

Validar que el m√©todo `findAccountById(Long accountId)` lance la excepci√≥n `AccountNotFoundException` cuando se intenta
consultar una cuenta que no existe en el repositorio.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowAccountNotFoundExceptionWhenAccountDoesNotExist() {
        // given
        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.empty());

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.findAccountById(1L))
                .isInstanceOf(AccountNotFoundException.class)
                .hasMessage("No se encontr√≥ la cuenta con ID: 1");

        // then
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountMapper, Mockito.never()).toAccountResponse(Mockito.any(Account.class));
    }
}
````

### üß© Validar obtenci√≥n del saldo de una cuenta existente

Validar que el m√©todo `getAccountBalance(Long accountId)` retorne correctamente el saldo (`balance`) de una cuenta
existente en el repositorio.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldGetBalanceOfAnAccountWhenAccountExists() {
        // given
        Account account = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(account));

        // when
        BigDecimal result = this.accountServiceUnderTest.getAccountBalance(1L);

        // then
        assertThat(result).isEqualByComparingTo(account.getBalance());
        Mockito.verify(this.accountRepository).findById(1L);
    }
}
````

### üß© Validar la obtenci√≥n del total de transferencias registradas en un banco

Comprobar que el servicio `AccountServiceImpl` obtiene correctamente el n√∫mero total de transferencias asociadas a un
banco existente.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldGetTotalTransfersWhenBankExists() {
        // given
        Bank bank = AccountTestFactory.createBank(1L, "BCP");
        bank.setTotalTransfers(10);

        Mockito.when(this.bankRepository.findById(1L)).thenReturn(Optional.of(bank));

        // when
        int result = this.accountServiceUnderTest.countTotalTransfersToBank(1L);

        // then
        assertThat(result).isEqualTo(10);
        Mockito.verify(this.bankRepository).findById(1L);
    }
}
````

### üß© Obtiene todas las cuentas existentes

Este test valida que el m√©todo `findAllAccounts()` retorne correctamente todas las cuentas existentes cuando el
repositorio contiene datos. Se utiliza `containsExactlyElementsOf(accountResponses)` para garantizar que:

- Los elementos devueltos sean exactamente los esperados.
- Se respeten el orden y el contenido de la lista original.

Esta verificaci√≥n es suficiente porque `AccountResponse` es un `record`, por lo que su implementaci√≥n de `equals()`
y `hashCode()` compara los valores de todos sus campos y no las referencias en memoria.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldGetAllAccountsWhenAccountsExists() {
        // given
        List<AccountResponse> accountResponses = List.of(
                new AccountResponse(1L, "Milagros", new BigDecimal("2000"), "BCP"),
                new AccountResponse(2L, "Kiara", new BigDecimal("1000"), "BCP")
        );
        Mockito.when(this.accountRepository.getAllAccounts()).thenReturn(accountResponses);

        // when
        List<AccountResponse> result = this.accountServiceUnderTest.findAllAccounts();

        // then
        assertThat(result)
                .isNotEmpty()
                .hasSize(2)
                .containsExactlyElementsOf(accountResponses);
        Mockito.verify(this.accountRepository).getAllAccounts();
    }
}
````

### üß© Registro exitoso de una nueva cuenta bancaria

Este test verifica que una cuenta nueva pueda ser registrada correctamente cuando el banco asociado existe.
Adem√°s, `simula el comportamiento real de JPA` al `asignar autom√°ticamente un ID al persistir una entidad`,
garantizando que el flujo de guardado en el servicio funcione como se espera.

Antes de mostrar la implementaci√≥n de nuestro test modificaremos nuestra f√°brica de datos `AccountTestFactory`
agregando nuevos m√©todos de conversi√≥n con los que estaremos trabajando en los test.

````java

@UtilityClass
public class AccountTestFactory {

    public static Bank createBank(Long bankId, String name, Account... accounts) {
        Bank bank = Bank.builder()
                .id(bankId)
                .name(name)
                .totalTransfers(0)
                .build();
        Arrays.stream(accounts).forEach(bank::addAccount);
        return bank;
    }

    public static Account createAccount(Long accountId, String holder, BigDecimal balance) {
        return Account.builder()
                .id(accountId)
                .holder(holder)
                .balance(balance)
                .build();
    }

    public static Account createAccountWithoutId(AccountCreateRequest request, Bank bank) {
        return Account.builder()
                .holder(request.holder())
                .balance(request.balance())
                .bank(bank)
                .build();
    }

    public static Account createAccountWithId(Long expectedAccountId, AccountCreateRequest request, Bank bank) {
        return Account.builder()
                .id(expectedAccountId)
                .holder(request.holder())
                .balance(request.balance())
                .bank(bank)
                .build();
    }

    public static AccountResponse toAccountResponse(Account account) {
        return new AccountResponse(
                account.getId(),
                account.getHolder(),
                account.getBalance(),
                account.getBank().getName()
        );
    }

    public static AccountCreateRequest createAccountRequest(String holder, BigDecimal balance, Long bankId) {
        return new AccountCreateRequest(holder, balance, bankId);
    }
}
````

Finalmente, definimos nuestro test para guardar una cuenta correctamente.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldSaveNewAccountWhenBankExists() {
        // given
        AccountCreateRequest accountRequest = AccountTestFactory.createAccountRequest("Milagros", new BigDecimal("2000"), 1L);
        Bank bank = AccountTestFactory.createBank(1L, "BCP");
        Account accountWithoutId = AccountTestFactory.createAccountWithoutId(accountRequest, bank);
        Account accountWithId = AccountTestFactory.createAccountWithId(10L, accountRequest, bank);
        AccountResponse expectedResponse = AccountTestFactory.toAccountResponse(accountWithId);

        assertThat(accountWithoutId.getId()).isNull(); // Verificamos que no tenga ID antes del save

        Mockito.when(this.bankRepository.findById(1L)).thenReturn(Optional.of(bank));
        Mockito.when(this.accountMapper.toAccount(accountRequest, bank)).thenReturn(accountWithoutId);

        Mockito.doAnswer(invocation -> {
            Account saved = invocation.getArgument(0);
            saved.setId(10L); // Simula el comportamiento de JPA: asigna el ID directamente al objeto original
            return saved;
        }).when(this.accountRepository).save(accountWithoutId);

        Mockito.when(this.accountMapper.toAccountResponse(accountWithoutId)) // El objeto accountWithoutId ya tiene ID asignado
                .thenReturn(expectedResponse);

        // when
        AccountResponse actualResponse = this.accountServiceUnderTest.saveAccount(accountRequest);

        // then
        assertThat(accountWithoutId.getId())
                .isNotNull() // Verificaci√≥n expl√≠cita del cambio de estado
                .isEqualTo(10L);
        assertThat(actualResponse)
                .isNotNull()
                .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                .containsExactly(10L, "Milagros", new BigDecimal("2000"), "BCP");
        Mockito.verify(this.bankRepository).findById(1L);
        Mockito.verify(this.accountMapper).toAccount(accountRequest, bank);
        Mockito.verify(this.accountRepository).save(accountWithoutId);
        Mockito.verify(this.accountMapper).toAccountResponse(accountWithoutId);
    }
}
````

üß© Aspectos t√©cnicos destacados

- 1Ô∏è‚É£ `Simulaci√≥n realista del comportamiento de persistencia`: El uso de `Mockito.doAnswer(...)` permite emular lo que
  hace un repositorio JPA real: cuando se guarda una nueva entidad sin ID, el repositorio le asigna un identificador
  directamente sobre el mismo objeto en memoria. Esto refuerza el realismo del test sin depender de una base de datos
  en memoria ni mocks complicados.
- 2Ô∏è‚É£ `Validaci√≥n del cambio de estado`: El test no solo comprueba el resultado (`AccountResponse`), sino tambi√©n el
  efecto colateral esperado: que el objeto `accountWithoutId` haya mutado su estado asign√°ndosele un `ID`.
- 3Ô∏è‚É£ `Uso de AccountTestFactory`: La f√°brica centraliza la creaci√≥n de `entidades` y `DTOs`, reduciendo ruido en los
  tests y garantizando consistencia entre ellos. Esto hace que los casos de prueba sean m√°s expresivos, legibles y
  mantenibles.

### üß© Realiza un retiro exitoso desde una cuenta existente

Este test valida el flujo exitoso del m√©todo `withdraw(...)` en el servicio. El escenario verifica que, al realizar un
retiro:

- ‚úÖ Se encuentra la cuenta por su ID.
- ‚úÖ Se descuenta correctamente el monto solicitado del balance original.
- ‚úÖ El repositorio persiste la cuenta actualizada.
- ‚úÖ El mapper convierte la entidad resultante en un DTO de respuesta (AccountResponse).

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldWithdrawAmountSuccessfullyWhenAccountExists() {
        // given
        Account accountBeforeWithdrawal = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("2000"));
        Account accountAfterWithdrawal = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("1500"));
        Bank bank = AccountTestFactory.createBank(1L, "BCP", accountBeforeWithdrawal, accountAfterWithdrawal);
        WithdrawalRequest request = new WithdrawalRequest(new BigDecimal("500"));
        AccountResponse expectedResponse = AccountTestFactory.toAccountResponse(accountAfterWithdrawal);

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(accountBeforeWithdrawal));
        Mockito.when(this.accountRepository.save(accountBeforeWithdrawal)).thenReturn(accountBeforeWithdrawal); // Ya mutado
        Mockito.when(this.accountMapper.toAccountResponse(accountBeforeWithdrawal)).thenReturn(expectedResponse);

        // when
        AccountResponse actualResponse = this.accountServiceUnderTest.withdraw(1L, request);

        // then
        assertThat(accountBeforeWithdrawal.getBalance())
                .isEqualByComparingTo("1500");
        assertThat(actualResponse)
                .isNotNull()
                .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                .containsExactly(1L, "Milagros", new BigDecimal("1500"), bank.getName());
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository).save(accountBeforeWithdrawal);
        Mockito.verify(this.accountMapper).toAccountResponse(accountBeforeWithdrawal);
    }
}
````

El uso de: `Mockito.when(this.accountRepository.save(accountBeforeWithdrawal)).thenReturn(accountBeforeWithdrawal)`
simula que la operaci√≥n `save()` retorna la misma instancia mutada, reflejando c√≥mo JPA administra entidades en estado
managed dentro de una transacci√≥n.

Por su parte, el `assertThat(accountBeforeWithdrawal.getBalance())` confirma la mutaci√≥n en memoria antes de que el
objeto sea devuelto como respuesta.

### üß© Falla de retiro por saldo insuficiente

Este test valida que el servicio no permita realizar un retiro cuando el saldo disponible es menor al monto solicitado,
y que se lance correctamente la excepci√≥n `InsufficientBalanceException`.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowInsufficientBalanceExceptionWhenAccountHasLowBalance() {
        // given
        Account account = AccountTestFactory.createAccount(1L, "Milagros", new BigDecimal("1000"));
        WithdrawalRequest request = new WithdrawalRequest(new BigDecimal("1200"));

        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.of(account));

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.withdraw(1L, request))
                .isInstanceOf(InsufficientBalanceException.class)
                .hasMessage("Saldo insuficiente en la cuenta del titular Milagros (ID: 1)");

        // then
        assertThat(account.getBalance()).isEqualByComparingTo("1000");
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verify(this.accountRepository, Mockito.never()).save(Mockito.any());
        Mockito.verify(this.accountMapper, Mockito.never()).toAccountResponse(Mockito.any());
    }
}
````

### üß© Falla de retiro cuando la cuenta no existe

Este test valida que el servicio de retiros gestione correctamente el escenario donde la cuenta no existe, lanzando la
excepci√≥n esperada `AccountNotFoundException`.

````java
class AccountServiceImplMockitoManualTest {
    @Test
    void shouldThrowAccountNotFoundExceptionWhenAccountDoesNotExistDuringWithdrawal() {
        // given
        WithdrawalRequest request = new WithdrawalRequest(new BigDecimal("1200"));
        Mockito.when(this.accountRepository.findById(1L)).thenReturn(Optional.empty());

        // when
        assertThatThrownBy(() -> this.accountServiceUnderTest.withdraw(1L, request))
                .isInstanceOf(AccountNotFoundException.class)
                .hasMessage("No se encontr√≥ la cuenta con ID: 1");

        // then
        Mockito.verify(this.accountRepository).findById(1L);
        Mockito.verifyNoMoreInteractions(this.accountRepository, this.accountMapper);
    }
}
````

El `verifyNoMoreInteractions(...)` expresa la intenci√≥n de forma clara y global. En lugar de verificar uno por uno
que no se llamaron m√©todos como `save(...)` o `toAccountResponse(...)`, `verifyNoMoreInteractions(...)` declara
expl√≠citamente:

> ‚ÄúNo se debe haber llamado a nada m√°s en estos mocks.‚Äù

Esto deja el test m√°s limpio y sem√°ntico.

## üß™ Pruebas unitarias con anotaciones de Mockito

Crearemos una nueva clase de prueba para nuestro servicio `AccountServiceImpl`, llamada
`AccountServiceImplMockitoAnnotationTest`. Esta clase contendr√° los mismos m√©todos de prueba definidos previamente en
`AccountServiceImplMockitoManualTest`.

El objetivo es `crear los mocks utilizando las anotaciones de Mockito`, en lugar de hacerlo manualmente.
De esta manera, los mocks se instanciar√°n e inyectar√°n autom√°ticamente en el objeto bajo prueba.

````java

@ExtendWith(MockitoExtension.class) // Habilita las anotaciones de Mockito: @Mock, @InjectMocks, etc.
class AccountServiceImplMockitoAnnotationTest {
    @Mock
    private AccountRepository accountRepository;                // Interfaz simulada
    @Mock
    private BankRepository bankRepository;                      // Interfaz simulada
    @Mock
    private AccountMapper accountMapper;                        // Interfaz simulada
    @InjectMocks
    private AccountServiceImpl accountServiceUnderTest;         // Implementaci√≥n concreta a probar

    /* all test methods */
}
````

üîç Explicaci√≥n de las anotaciones

- `@ExtendWith(MockitoExtension.class)`. Es la forma est√°ndar de habilitar el soporte de `Mockito` en `JUnit 5`. Esta
  extensi√≥n permite usar las anotaciones `@Mock`, `@InjectMocks`, `@Spy`, entre otras, y gestiona autom√°ticamente la
  creaci√≥n e inicializaci√≥n de los mocks.

- `@Mock`. Indica que el campo anotado ser√° un mock. `Mockito` se encargar√° de crear una implementaci√≥n simulada de la
  interfaz o clase, que podremos controlar mediante `when(...).thenReturn(...)`, `verify(...)`, etc. En este caso, se
  crean mocks de `AccountRepository`, `BankRepository` y `AccountMapper`.

- `@InjectMocks`. Crea una instancia real del objeto bajo prueba (`AccountServiceImpl`) e inyecta autom√°ticamente los
  mocks en sus dependencias. Esto evita tener que construir el servicio manualmente o pasar los mocks en el constructor.

‚ö†Ô∏è Importante:
> La anotaci√≥n `@InjectMocks` `solo puede aplicarse a clases concretas`, no a interfaces.

Al ejecutar los tests de esta nueva clase, observaremos que todos los casos siguen pasando correctamente, pero ahora
los mocks se gestionan autom√°ticamente gracias a las anotaciones de Mockito, haciendo el c√≥digo de prueba m√°s limpio,
legible y mantenible.

## üß™ Pruebas unitarias con anotaciones de Spring Boot

`Spring Boot` permite integrar `Mockito` directamente en su contexto de pruebas, facilitando la creaci√≥n e inyecci√≥n
de mocks sin necesidad de configurarlos manualmente.

A continuaci√≥n, se presentan dos enfoques v√°lidos ‚Äîuno `legacy` y otro `moderno`‚Äî dependiendo de la versi√≥n del
framework.

### üß© Versi√≥n Legacy (`<= 3.3.x`) ‚Äî usando `@MockBean`

Este enfoque ha sido el est√°ndar durante varias versiones y sigue siendo ampliamente utilizado. Su prop√≥sito es crear
`mocks gestionados por el contexto de Spring`, reemplazando los beans reales durante la ejecuci√≥n de los tests.

````java

@SpringBootTest(classes = AccountServiceImpl.class)
class AccountServiceImplSpringBootTest {
    @MockBean
    private AccountRepository accountRepository;
    @MockBean
    private BankRepository bankRepository;
    @MockBean
    private AccountMapper accountMapper;

    @Autowired
    private AccountService accountServiceUnderTest;

    /* all test methods */
}
````

Explicaci√≥n

1. `@SpringBootTest(classes = AccountServiceImpl.class)`
    - Levanta √∫nicamente el contexto asociado al servicio `AccountServiceImpl`.
    - Evita cargar toda la aplicaci√≥n, haciendo la prueba m√°s r√°pida y enfocada.
    - Mantiene la ventaja de usar el `ApplicationContext` real de `Spring`.
2. `@MockBean`
    - Registra cada mock en el contexto de Spring, reemplazando el bean real si ya exist√≠a.
    - Spring inyecta autom√°ticamente estos mocks en `AccountServiceImpl`, garantizando un wiring real con dependencias
      simuladas.
    - Perfecto para aislar el comportamiento del servicio bajo prueba.
3. `@Autowired` sobre la interfaz (`AccountService`)
    - Inyectar la interfaz es una buena pr√°ctica que desacopla el test de la implementaci√≥n concreta.
    - Internamente, Spring resuelve el bean concreto (`AccountServiceImpl`).

### üß© Versi√≥n Moderna (`>= 3.4.0`) ‚Äî usando `@MockitoBean`

A partir de `Spring Boot 3.4.0`, la anotaci√≥n `@MockBean` fue marcada como `@Deprecated`, siendo reemplazada por la
nueva API de `bean overrides`.

El nuevo paquete `org.springframework.test.context.bean.override.mockito` introduce `@MockitoBean`, una alternativa
moderna y extensible.

````java

@SpringBootTest(classes = AccountServiceImpl.class)
class AccountServiceImplSpringBootTest {
    @MockitoBean
    private AccountRepository accountRepository;
    @MockitoBean
    private BankRepository bankRepository;
    @MockitoBean
    private AccountMapper accountMapper;

    @Autowired
    private AccountService accountServiceUnderTest;

    /* all test methods */
}
````

üîç Explicaci√≥n

- `@MockitoBean`
    - Es el reemplazo moderno de `@MockBean`.
    - Permite integrar mocks de `Mockito` con el `contexto de Spring Boot` sin usar
      `@ExtendWith(MockitoExtension.class)`.
    - Forma parte del nuevo sistema de bean overrides, que mejora la flexibilidad y mantiene la compatibilidad con
      `JUnit 5`.


- Ventajas principales:
    - Es m√°s consistente con la nueva jerarqu√≠a de anotaciones (`@BeanOverride`, `@SpyBean`, `@MockitoBean`).
    - Ofrece mayor claridad sem√°ntica al indicar expl√≠citamente que se usa Mockito.
    - Preparada para la transici√≥n hacia `Spring Boot 4.0`.

üìò Nota final

> Aunque `@MockBean` sigue funcionando, se recomienda migrar progresivamente a `@MockitoBean` si trabajas con
> `Spring Boot 3.4.0` o superior. Esto garantiza compatibilidad futura y adopta la nueva convenci√≥n de overriding
> beans propuesta por el equipo de `Spring`.

---

# Unit Test - Test de Controladores (@WebMvcTest)

---

Antes de iniciar con las pruebas unitarias de nuestros controladores, es importante entender el rol de algunas
anotaciones y clases clave del ecosistema de testing de Spring Boot.

### üß∞ `@WebMvcTest`

- Esta anotaci√≥n se utiliza para realizar pruebas enfocadas en la capa web (`Spring MVC`), sin levantar el contexto
  completo de Spring Boot.
- Al usar `@WebMvcTest`, solo se cargan los beans relacionados con `MVC`, tales como:
    - `@Controller`, `@ControllerAdvice`
    - `@JsonComponent`
    - `Converter` / `GenericConverter`
    - `Filter`
    - `WebMvcConfigurer`
    - `HandlerMethodArgumentResolver`
- Por lo tanto, **no se cargan los beans** anotados con `@Component`, `@Service` o `@Repository`.
- De forma predeterminada, tambi√©n configura autom√°ticamente `MockMvc` y, si est√° presente, `Spring Security`.
- Generalmente, se utiliza junto con `@MockBean` o `@Import` para inyectar dependencias necesarias que el
  controlador requiera.
- Si indicamos un controlador espec√≠fico, por ejemplo: `@WebMvcTest(AccountController.class)` le estamos diciendo a
  Spring que el test se centrar√° exclusivamente en ese controlador y su comportamiento HTTP.

### üß∞ `MockMvc`

- Es una herramienta que permite `simular peticiones` `HTTP (GET, POST, PUT, DELETE, etc.)` a los endpoints de un
  controlador sin necesidad de arrancar un servidor real.
- El contexto de `MockMvc` es un entorno MVC simulado, donde tanto el request como el response son objetos falsos,
  lo que permite probar la capa web de forma aislada.
- Con `MockMvc` puedes:
    - Ejecutar solicitudes contra tus endpoints.
    - Obtener respuestas simuladas.
    - Verificar c√≥digos de estado, encabezados, y cuerpos de respuesta.
- Ejemplo conceptual:
    ````bash
    mockMvc.perform(get("/api/accounts/1"))
           .andExpect(status().isOk())
           .andExpect(jsonPath("$.name").value("Mart√≠n"));
    ````

### üß∞ `@MockBean`

- Permite simular dependencias del controlador dentro del contexto de Spring Boot.
- Cuando anotas un campo con `@MockBean`, Spring reemplaza el bean real por un mock de `Mockito` durante la
  ejecuci√≥n del test.
- Es la forma m√°s com√∫n de inyectar dependencias simuladas en pruebas anotadas con `@WebMvcTest`.
- Por ejemplo:
    ````java
    @MockBean
    private AccountService accountService;
    ````

Esto hace que el `AccountController` reciba una versi√≥n simulada de `AccountService`, permitiendo controlar el
comportamiento durante la prueba.

### üß∞ `ResultActions`

- Es una clase que representa el resultado de una petici√≥n ejecutada con `MockMvc`.
- Permite aplicar acciones y validaciones sobre la respuesta.
- Por ejemplo:
    ````bash
    ResultActions response = mockMvc.perform(get("/api/accounts/1"));
    response.andExpect(status().isOk());
    response.andExpect(jsonPath("$.balance").value(1000));
    ````

### üß∞ `ObjectMapper`

- Es una clase proporcionada por `Jackson`, utilizada para convertir entre objetos Java y JSON.
- Se puede usar para:
    - `Serializar` `objetos Java` ‚Üí `JSON`.
    - `Deserializar` `JSON` ‚Üí `objetos Java`.
- En pruebas, `ObjectMapper` es muy √∫til para preparar cuerpos de solicitud (`request body`) y validar respuestas en
  formato JSON.
- Ejemplo:
    ````java
    AccountDTO dto = new AccountDTO("Mart√≠n", new BigDecimal("1000"));
    String json = objectMapper.writeValueAsString(dto);
    ````

## üß™ Pruebas unitarias del controlador `AccountController`

En esta secci√≥n abordamos las `pruebas unitarias del controlador REST` `AccountController`, utilizando el entorno de
pruebas web que nos proporciona `Spring Boot`.

A diferencia de las pruebas de servicios o componentes que usamos anteriormente con
`@ExtendWith(MockitoExtension.class)` o `@SpringBootTest`, aqu√≠ nos centraremos en validar la capa web (`controlador`)
de manera `aislada`, sin levantar un servidor HTTP real ni inicializar toda la aplicaci√≥n.

Para ello, emplearemos:

- `@WebMvcTest(AccountController.class)`. Carga solo el contexto web de `Spring MVC` para el controlador especificado.
  No levanta el contexto completo de la aplicaci√≥n, sino √∫nicamente los beans relacionados con la capa web
  (`Controller`, `ControllerAdvice`, `JsonComponent`, `Filter`, etc.).
- `@MockitoBean` (o `@MockBean` en versiones anteriores). Sustituye al bean real de `AccountService` por un mock en el
  contexto de Spring Boot (desde `Spring Boot 3.4+`). As√≠, el controlador recibe un mock inyectado.}
- `@Autowired`. Inyecta las dependencias gestionadas por `Spring` (`MockMvc` y `ObjectMapper`) en la clase de prueba.
- `MockMvc`. Simula peticiones HTTP sin necesidad de desplegar un servidor Tomcat. Permite probar controladores de
  manera r√°pida y aislada.
- `ObjectMapper`. Se usa para convertir objetos Java en JSON (y viceversa). Aqu√≠ sirve para comparar la respuesta real
  con la serializaci√≥n esperada.

Este enfoque es ideal para probar controladores REST de forma r√°pida, fiable y desacoplada del resto del sistema.

### üß© Listar todas las cuentas (`GET /api/v1/accounts`)

````java

@WebMvcTest(AccountController.class)
class AccountControllerTest {

    @MockitoBean
    private AccountService accountService;

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void shouldReturnAllAccountsWhenTheyExist() throws Exception {
        // given
        List<AccountResponse> accounts = List.of(
                new AccountResponse(1L, "Milagros", new BigDecimal("2000"), "BCP"),
                new AccountResponse(2L, "Kiara", new BigDecimal("1000"), "BCP")
        );
        Mockito.when(this.accountService.findAllAccounts()).thenReturn(accounts);

        // when
        ResultActions result = this.mockMvc.perform(get("/api/v1/accounts"));

        // then
        result.andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$", Matchers.hasSize(accounts.size())))
                .andExpect(jsonPath("$.size()", Matchers.is(accounts.size())))
                .andExpect(jsonPath("$[0].id").value(1))
                .andExpect(jsonPath("$[0].holder").value("Milagros"))
                .andExpect(jsonPath("$[0].balance").value(2000))
                .andExpect(jsonPath("$[0].bankName").value("BCP"))
                .andExpect(jsonPath("$[1].id").value(2))
                .andExpect(jsonPath("$[1].holder").value("Kiara"))
                .andExpect(jsonPath("$[1].balance").value(1000))
                .andExpect(jsonPath("$[1].bankName").value("BCP"))
                // Verifica que la respuesta completa coincida con la serializaci√≥n del objeto esperado
                .andExpect(content().json(this.objectMapper.writeValueAsString(accounts)));

        Mockito.verify(this.accountService).findAllAccounts();
        Mockito.verifyNoMoreInteractions(this.accountService);
    }
}
````

üß† ¬øQu√© hace este test?

1. Simula el comportamiento del servicio
    - Con `Mockito.when(accountService.findAllAccounts()).thenReturn(accounts)` se define la respuesta simulada que el
      servicio devolver√° cuando el controlador lo invoque.
    - De esta forma, no se consulta una base de datos real: la prueba se enfoca √∫nicamente en el comportamiento del
      controlador.

2. Ejecuta una solicitud HTTP simulada
    - `mockMvc.perform(get("/api/v1/accounts"))` env√≠a una petici√≥n `GET` al endpoint del controlador sin levantar un
      servidor web real.
    - Internamente, Spring crea un entorno simulado (`MockMvc`) que replica todo el flujo MVC: `request`, `controller`,
      `response`, etc.

3. Valida la respuesta HTTP
    - Con `andExpect(...)` se comprueban aspectos del resultado:
        - El c√≥digo de estado 200 OK
        - El `content-type application/json`
        - La estructura JSON y el contenido exacto (usando `jsonPath` y `objectMapper`)
        - Que el tama√±o del arreglo devuelto sea el esperado

4. Verifica interacciones con el servicio
    - `Mockito.verify(this.accountService).findAllAccounts()` confirma que el controlador llam√≥ exactamente una vez al
      servicio.
    - `Mockito.verifyNoMoreInteractions(...)` garantiza que no hubo llamadas adicionales inesperadas.

### üì¢ ¬øPor qu√© en el log se muestra el arranque de Spring Boot?

Aunque `@WebMvcTest` no levanta la aplicaci√≥n completa, s√≠ inicializa parcialmente el contexto de `Spring Boot`.
Por eso ves en el log algo similar a esto:

````bash
16:49:55.703 [main] INFO org.springframework.test.context.support.AnnotationConfigContextLoaderUtils -- Could not detect default configuration classes for test class [dev.magadiflo.app.unit.controller.AccountControllerTest]: AccountControllerTest does not declare any static, non-private, non-final, nested classes annotated with @Configuration.
16:49:55.927 [main] INFO org.springframework.boot.test.context.SpringBootTestContextBootstrapper -- Found @SpringBootConfiguration dev.magadiflo.app.SpringRestApiApplication for test class dev.magadiflo.app.unit.controller.AccountControllerTest

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.5.6)

2025-10-14T16:49:56.508-05:00  INFO 19348 --- [spring-rest-api] [           main] d.m.a.u.c.AccountControllerTest          : Starting AccountControllerTest using Java 21.0.6 with PID 19348 (started by magadiflo in D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api)
2025-10-14T16:49:56.510-05:00  INFO 19348 --- [spring-rest-api] [           main] d.m.a.u.c.AccountControllerTest          : No active profile set, falling back to 1 default profile: "default"
Mockito is currently self-attaching to enable the inline-mock-maker. This will no longer work in future releases of the JDK. Please add Mockito as an agent to your build as described in Mockito's documentation: https://javadoc.io/doc/org.mockito/mockito-core/latest/org.mockito/org/mockito/Mockito.html#0.3
WARNING: A Java agent has been loaded dynamically (C:\Users\magadiflo\.m2\repository\net\bytebuddy\byte-buddy-agent\1.17.7\byte-buddy-agent-1.17.7.jar)
WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
WARNING: Dynamic loading of agents will be disallowed by default in a future release
Java HotSpot(TM) 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended
2025-10-14T16:49:58.547-05:00  INFO 19348 --- [spring-rest-api] [           main] o.s.b.t.m.w.SpringBootMockServletContext : Initializing Spring TestDispatcherServlet ''
2025-10-14T16:49:58.547-05:00  INFO 19348 --- [spring-rest-api] [           main] o.s.t.web.servlet.TestDispatcherServlet  : Initializing Servlet ''
2025-10-14T16:49:58.550-05:00  INFO 19348 --- [spring-rest-api] [           main] o.s.t.web.servlet.TestDispatcherServlet  : Completed initialization in 2 ms
2025-10-14T16:49:58.580-05:00  INFO 19348 --- [spring-rest-api] [           main] d.m.a.u.c.AccountControllerTest          : Started AccountControllerTest in 2.555 seconds (process running for 3.978)
Disconnected from the target VM, address: '127.0.0.1:52362', transport: 'socket'
````

üëâ Explicaci√≥n paso a paso:

1. Spring busca la clase principal con `@SpringBootConfiguration` (`SpringRestApiApplication` en nuestro caso).
2. Crea un `contexto reducido` que contiene solo los beans web necesarios.
3. Configura un `TestDispatcherServlet`, el mismo componente que usa internamente un servidor real para despachar
   peticiones, pero aqu√≠ en modo simulado.
4. Aplica el `perfil de test` o el `perfil por defecto`, lo cual explica el mensaje
   `falling back to default profile: default`.
5. Finalmente, se registra el arranque del test (Started `AccountControllerTest...`), pero `sin iniciar Tomcat` ni
   conexiones reales.

En resumen:
> Aunque parece que la aplicaci√≥n ‚Äúse levanta‚Äù, en realidad Spring solo crea un contexto parcial y embebido del m√≥dulo
> web, sin tocar la base de datos ni otros beans del dominio.

üí° Resumen visual del flujo

````
MockMvc (solicitud GET)
      ‚Üì
AccountController
      ‚Üì
AccountService (mock)
      ‚Üì
Respuesta JSON simulada
````

- No se levanta servidor real
- No hay acceso a DB ni componentes externos
- Se prueba la l√≥gica del controlador y el formato HTTP/JSON

### üß© Registrar una cuenta (`POST /api/v1/accounts`)

En esta prueba validamos el comportamiento del endpoint `POST /api/v1/accounts`, encargado de registrar una nueva
cuenta bancaria.

````java

@WebMvcTest(AccountController.class)
class AccountControllerTest {

    // Dependencias: AccountService, MockMvc, ObjectMapper

    @Test
    void shouldCreateNewAccountSuccessfully() throws Exception {
        // given
        AccountCreateRequest request = new AccountCreateRequest("Milagros", new BigDecimal("2000"), 1L);
        AccountResponse accountResponse = new AccountResponse(1L, "Milagros", new BigDecimal("2000"), "BCP");
        Mockito.when(this.accountService.saveAccount(request)).thenReturn(accountResponse);

        // when
        ResultActions result = this.mockMvc.perform(post("/api/v1/accounts")
                .contentType(MediaType.APPLICATION_JSON)
                .content(this.objectMapper.writeValueAsString(request)));

        // then
        result.andExpect(status().isCreated())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(header().string("Location", Matchers.containsString("/api/v1/accounts/1")))
                .andExpect(jsonPath("$.id", Matchers.is(1)))
                .andExpect(jsonPath("$.holder", Matchers.is("Milagros")))
                .andExpect(jsonPath("$.balance", Matchers.is(2000)))
                .andExpect(jsonPath("$.bankName", Matchers.is("BCP")));
        Mockito.verify(this.accountService).saveAccount(Mockito.any());
        Mockito.verifyNoMoreInteractions(this.accountService);
    }
}
````
