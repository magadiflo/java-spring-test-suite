# Integration Test - Test de Repositorios (`@DataJpaTest`)

---

Los `tests de integraci√≥n` validan que los distintos componentes de la aplicaci√≥n (repositorios, servicios,
controladores, etc.) `interact√∫en correctamente entre s√≠` y con dependencias externas como `bases de datos`,
`colas de mensajes` o `servicios HTTP`.

En este caso, probaremos la integraci√≥n entre `Spring Data JPA` y una base de datos, usando primero `H2`
(`en memoria`) y m√°s adelante `MySQL`, para simular entornos m√°s realistas.

## ‚öôÔ∏è Configurar H2 como base de datos en memoria

En el proyecto `spring-rest-api`, agregamos la dependencia de `H2` en el `pom.xml` con el scope limitado a `test`.

### üì¶ Motivo

Usamos `H2` para ejecutar pruebas r√°pidas en memoria sin depender de una base real. M√°s adelante, reemplazaremos
esta configuraci√≥n por `MySQL` o `Testcontainers`, pero `H2` nos permite practicar el flujo de integraci√≥n sin
sobrecargar el entorno.

````xml

<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope> <!-- Importante: solo se usar√° durante los tests -->
</dependency>
````

üí° Nota profesional:
> Aunque `H2` es muy √∫til en fases iniciales, `no siempre refleja el comportamiento real` de `MySQL` o `PostgreSQL`,
> por lo que en entornos reales se recomienda pasar pronto a `Testcontainers` o bases de datos reales en `Docker`.

### üß± Perfiles para pruebas

En lecciones anteriores definimos un `application.yml` dentro de `/src/test/resources` para aislar la configuraci√≥n
de pruebas del entorno principal (`/src/main/resources`).

Ahora organizaremos nuestros archivos de configuraci√≥n de la siguiente manera:

üìÅ Estructura recomendada

````
src/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ       ‚îú‚îÄ‚îÄ application.yml
‚îÇ       ‚îú‚îÄ‚îÄ application-dev.yml
‚îÇ       ‚îú‚îÄ‚îÄ application-qa.yml
‚îÇ       ‚îî‚îÄ‚îÄ application-prod.yml
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ resources/
        ‚îú‚îÄ‚îÄ application.yml               # Config base com√∫n a todos los tests
        ‚îú‚îÄ‚îÄ application-test.yml          # Perfil de pruebas con MySQL real o contenedores
        ‚îî‚îÄ‚îÄ application-test-h2.yml       # Perfil alternativo con base en memoria H2
````

üß© Prop√≥sito de cada archivo

| Archivo                   | Prop√≥sito                                               | Uso t√≠pico                          |
|---------------------------|---------------------------------------------------------|-------------------------------------|
| `application.yml`         | Configuraci√≥n base (puerto aleatorio, nombre app, logs) | Se carga en todos los tests         |
| `application-test.yml`    | Configuraci√≥n de pruebas con MySQL o Testcontainers     | Ideal para CI/CD o integraci√≥n real |
| `application-test-h2.yml` | Configuraci√≥n ligera con H2                             | Ideal para pruebas locales r√°pidas  |

üí¨ Nota:
> Mantener esta separaci√≥n de perfiles te permite cambiar f√°cilmente entre entornos de prueba
> (`H2` ‚Üî `MySQL` ‚Üî `Testcontainers`) sin modificar el c√≥digo fuente, solo ajustando el perfil activo.

## üß† Autoconfiguraci√≥n de H2

Spring Boot detecta autom√°ticamente la dependencia `com.h2database:h2` y `autoconfigura el datasource`
(driver, URL y dialecto), por lo que `no es necesario` definir manualmente esas propiedades para que funcione.

Sin embargo, en entornos profesionales `s√≠ se suele personalizar` la configuraci√≥n para:

- Asignar nombres de base de datos espec√≠ficos.
- Controlar el cierre del contexto.
- Emular el comportamiento de `MySQL` (con `MODE=MySQL`).

üß© Conclusi√≥n:

- Si solo usamos `H2` para pruebas b√°sicas, basta con la dependencia.
- Pero para escenarios m√°s realistas (emulaci√≥n de MySQL, logs SQL, control de ciclo de vida), la configuraci√≥n
  personalizada es una buena pr√°ctica.

## ‚öôÔ∏è Configuraci√≥n base de pruebas (`application.yml`)

üìç Ubicaci√≥n: `/src/test/resources/application.yml`

````yml
# Configuraci√≥n BASE para todos los perfiles de test
server:
  port: 0  # Puerto aleatorio para evitar conflictos

spring:
  application:
    name: spring-rest-api
  jpa:
    hibernate:
      ddl-auto: create-drop # Crea el schema al levantar el CONTEXTO y se elimina al terminar
    properties:
      hibernate:
        format_sql: true
        show_sql: false
  sql:
    init:
      mode: never # No cargamos datos autom√°ticamente. Cada test cargar√° lo que necesite con @Sql.

# Logging para tests - queremos ver qu√© pasa pero sin saturar
logging:
  level:
    root: INFO
    dev.magadiflo.app: DEBUG
    org.hibernate.SQL: DEBUG                              # Muestra las consultas SQL
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE  # Muestra par√°metros enviados al SQL
    org.springframework.test: DEBUG                       # Informaci√≥n del contexto de test
````

üß† Explicaci√≥n de configuraci√≥n

- `ddl-auto: create-drop` ‚Üí crea el esquema al iniciar el contexto de Spring (primera vez que se necesita) y lo destruye
  al finalizarlo (cuando ya no hay m√°s tests que lo usen). Un contexto puede ser reutilizado por
  `m√∫ltiples clases de test`.
- ¬øQu√© es un "contexto de Spring? Spring cachea contextos seg√∫n:
    - Anotaciones de test (`@SpringBootTest`, `@DataJpaTest`, `@WebMvcTest`, etc.)
    - Perfiles activos (`@ActiveProfiles`)
    - Configuraciones adicionales (`@TestPropertySource`, `webEnvironment`, etc.)
- El esquema (`create-drop`) se ejecuta por cada contexto √∫nico. Si m√∫ltiples clases de test usan: la misma anotaci√≥n,
  el mismo perfil, la misma configuraci√≥n, Spring REUTILIZA el contexto (1 solo `create-drop` para todas esas clases).
  Si cambia cualquiera de esos elementos ‚Üí Se crea un nuevo contexto (nuevo `create-drop`).
- `format_sql: true` ‚Üí formatea las sentencias SQL en el log, lo que facilita su lectura.
- `show_sql: false` ‚Üí desactiva la impresi√≥n directa en consola con el prefijo `Hibernate:`. Las consultas siguen
  visibles gracias al logger `org.hibernate.SQL: DEBUG`, que ofrece m√°s control y mejor formato.
- En tests usamos `show_sql: false` para evitar duplicidad en consola, ya que el logger `org.hibernate.SQL` ya imprime
  las consultas. En desarrollo no es necesario desactivarlo porque no se activa autom√°ticamente.
- `mode: never` ‚Üí no queremos carga autom√°tica de datos. Cada test cargar√° lo que necesite con `@Sql`.
- `root: WARN` ‚Üí reduce el ruido en consola; solo se muestran advertencias o errores globales.
- `dev.magadiflo.app: DEBUG` ‚Üí habilita logs detallados para nuestras clases.
- `org.hibernate.SQL: DEBUG` ‚Üí muestra las sentencias SQL generadas.
- `org.hibernate.type.descriptor.sql.BasicBinder: TRACE` ‚Üí muestra los valores de los par√°metros enviados al SQL.
- `org.springframework.test: DEBUG` ‚Üí vemos informaci√≥n del contexto de test.

üí° Recomendaci√≥n:
> Estos niveles de log son muy √∫tiles en etapa de pruebas, pero en producci√≥n deben reducirse a `INFO` o `WARN`
> para evitar sobrecargar los logs.

## ‚öôÔ∏è Perfil `test-h2` ‚Äî Base de datos en memoria

üìç Ubicaci√≥n: `/src/test/resources/application-test-h2.yml`

````yml
spring:
  config:
    activate:
      on-profile: test-h2 # ‚Üê Opcional: el nombre del archivo ya indica el perfil
  datasource:
    url: jdbc:h2:mem:db_test;MODE=MySQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
````

üîç Notas claves

- Este archivo se aplica autom√°ticamente cuando se activa el perfil `test-h2`, por ejemplo con
  `@ActiveProfiles("test-h2")` en nuestras pruebas.
- La propiedad `spring.config.activate.on-profile: test-h2` `es opcional` en archivos que ya siguen la convenci√≥n
  `application-{profile}.yml`. Se usa principalmente en archivos con m√∫ltiples bloques de configuraci√≥n o con nombres
  personalizados.
- Podemos omitirla sin afectar el comportamiento, siempre que el nombre del archivo coincida con el perfil activo.
- `spring.datasource.url`
    - `jdbc:h2:mem:db_test_h2` ‚Üí base de datos en memoria (no persiste en disco).
    - `DB_CLOSE_ON_EXIT=FALSE` ‚Üí evita el cierre autom√°tico al terminar la JVM (√∫til para inspecci√≥n).
    - `DB_CLOSE_DELAY=-1` ‚Üí mantiene viva la BD incluso sin conexiones activas. La BD no se cierra autom√°ticamente
      cuando se cierra la √∫ltima conexi√≥n.
    - `MODE=MySQL` ‚Üí hace que `H2` interprete la sintaxis SQL como `MySQL` (√∫til para dialectos y queries nativos).
- `spring.datasource.username/password`: define credenciales de acceso al motor `H2`. Para entrar por navegador a la
  consola `H2`, necesitamos:
    - Activar la consola con `spring.h2.console.enabled=true`
    - Acceder v√≠a `http://localhost:{puerto}/h2-console`
    - Usar el mismo `jdbc:h2:mem:db_test` como `URL`
    - Username `sa` (usuario por defecto de `H2`)
    - Password (dejar vac√≠o)

‚ö†Ô∏è Importante: Acceder durante un test en ejecuci√≥n
> La BD `H2` en memoria (`mem:`) solo existe mientras la aplicaci√≥n est√° corriendo.
>
> Para inspeccionar datos durante un test podr√≠amos usar `Thread.sleep(300000);` dentro del c√≥digo del test para pausar
> por 5 minutos, por ejemplo, luego acceder a la url, consultar las tablas, etc.

## üìí Activaci√≥n de Perfiles en Tests

### ‚úèÔ∏è En `/main`

Cuando usamos la siguiente configuraci√≥n en `src/main/resources/application.yml` (desarrollo/producci√≥n):

````yml
# application.yml en /main
spring:
  profiles:
    active: dev  # ‚Üê Esto ACTIVA un perfil por defecto
````

Esto dice: `Cuando arranques la aplicaci√≥n, usa el perfil dev autom√°ticamente`. Por lo que, al ejecutar:

````bash
$ java -jar app.jar
````

Sin especificar nada, usar√° `dev` porque est√° configurado como activo por defecto. Si queremos cambiarlo, basta
con ejecutar el siguiente comando:

````bash
$ java -jar app.jar --spring.profiles.active=prod
````

### üß™ En `/test`

Cuando usamos la siguiente configuraci√≥n en `src/test/resources/application-test-h2.yml` (test, test-h2, etc):

````yml
# application-test-h2.yml en /test
spring:
  config:
    activate:
      on-profile: test-h2  # ‚Üê Esto NO activa, solo DECLARA cu√°ndo aplicar este archivo
````

La configuraci√≥n anterior `NO activa el perfil`, solo dice:
"Este archivo `application-test-h2.yml` se aplicar√° cuando el perfil `test-h2` est√© activo. Es una declaraci√≥n
condicional, no una activaci√≥n.

#### üì¢ Importante

> En archivos que siguen la convenci√≥n `application-{profile}.yml`, como `application-test-h2.yml`, esta propiedad
> es `opcional`. Spring Boot ya sabe que debe aplicar ese archivo si el perfil `test-h2` est√° activo
> (por ejemplo, con `@ActiveProfiles("test-h2")` en nuestros tests). Se recomienda usarla solo si necesitamos
> mayor control o si el archivo contiene m√∫ltiples bloques para distintos perfiles.

#### üìã Comparaci√≥n clara:

| Propiedad                           | Prop√≥sito                             | D√≥nde se usa                   |
|-------------------------------------|---------------------------------------|--------------------------------|
| `spring.profiles.active`            | `ACTIVA` un perfil por defecto        | `/main` principalmente         |
| `spring.config.activate.on-profile` | `DECLARA` cu√°ndo aplicar este archivo | Archivos espec√≠ficos de perfil |

### üîß ¬øC√≥mo se activan los perfiles en tests entonces?

Hay 3 formas:

- `Opci√≥n 1`: Con `@ActiveProfiles` (la m√°s com√∫n en tests)
    ````java
    @SpringBootTest
    @ActiveProfiles("test-h2")  // ‚Üê Activa expl√≠citamente el perfil test-h2 para este test
    class BankRepositoryTest {
        // Spring cargar√°: application.yml + application-test-h2.yml
    }
    ````
  Es la forma m√°s usada y clara. Cada clase define expl√≠citamente su perfil.


- `Opci√≥n 2`: Con `spring.profiles.active` en `application.yml` de `/test`
    ````yml
    # application.yml en src/test/resources
    spring:
      profiles:
        active: test-h2  # ‚Üê Perfil por defecto para TODOS los tests
    ````
  Si ponemos esto, `todos` los tests usar√°n `test-h2` a menos que lo sobrescribamos con `@ActiveProfiles`.


- `Opci√≥n 3`: Con Maven/Gradle al ejecutar
    ````bash
    $ mvn test -Dspring.profiles.active=test-h2
    ````

### ‚úÖ Recomendaci√≥n Empresarial

No pongamos `spring.profiles.active` en el `application.yml` de `/test`, en su lugar, usemos `@ActiveProfiles` para
cada clase de test. ¬øCu√°les son sus ventajas?

- `Flexibilidad`: Cada clase de test puede elegir su perfil con `@ActiveProfiles`.
- `Claridad`: Al leer el test, ves inmediatamente qu√© perfil usa.
- `CI/CD`: Puedes ejecutar diferentes suites con diferentes perfiles:

````bash
$ mvn test -Dtest=*RepositoryTest -Dspring.profiles.active=test-h2
$ mvn test -Dtest=*IntegrationTest -Dspring.profiles.active=test 
````

### üöÄ ¬øQu√© pasa cuando ejecutamos `mvn test`?

1. `Maven` ejecuta todos los tests.
2. Cada clase de test con `@ActiveProfiles("test-h2")` carga:
    - `application.yml` (base)
    - `application-test-h2.yml` (porque el perfil `test-h2` est√° activo)
3. Los tests sin `@ActiveProfiles` solo cargan `application.yml` (base).

> üéØ No necesitamos especificar el perfil al ejecutar `mvn test` si ya lo declaramos con `@ActiveProfiles`.

## üìÇ Scripts SQL para Tests

Definimos y organizamos los scripts SQL que inicializan y limpian la base de datos durante las pruebas de integraci√≥n,
garantizando que cada ejecuci√≥n empiece en un estado limpio y controlado.

### üß± Estructura de directorios

Ubicaci√≥n base: `/src/test/resources/`

````
src/test/resources/
‚îú‚îÄ‚îÄ application.yml                 # Configuraci√≥n base com√∫n
‚îú‚îÄ‚îÄ application-test.yml            # Configuraci√≥n con MySQL (pendiente)
‚îú‚îÄ‚îÄ application-test-h2.yml         # Configuraci√≥n con H2 (en memoria)
‚îî‚îÄ‚îÄ sql-test/
    ‚îú‚îÄ‚îÄ cleanup-h2.sql              # Limpieza espec√≠fica para H2
    ‚îú‚îÄ‚îÄ cleanup-mysql.sql           # Limpieza espec√≠fica para MySQL
    ‚îî‚îÄ‚îÄ data-test.sql               # Datos compartidos (√∫nica fuente de verdad)
````

Mantener los scripts en un subdirectorio como `sql-test/` mejora la organizaci√≥n, permite diferenciar claramente los
datos de prueba de los de desarrollo y facilita su reutilizaci√≥n en distintos perfiles (`test`, `test-h2`, etc.).

### üßº Limpieza de datos (`cleanup-h2.sql` y `cleanup-mysql.sql`)

Los scripts de limpieza eliminan datos entre ejecuciones de tests, asegurando que cada prueba comience con un estado
consistente sin depender de los resultados de ejecuciones previas.

`cleanup-h2.sql`

````sql
-- Limpieza de datos para H2
-- Desactiva temporalmente las validaciones de integridad referencial
SET REFERENTIAL_INTEGRITY FALSE;

-- Limpia las tablas en cualquier orden (sin preocuparte por FKs)
TRUNCATE TABLE accounts;
TRUNCATE TABLE banks;

-- Reactiva las validaciones
SET REFERENTIAL_INTEGRITY TRUE;
````

- `SET REFERENTIAL_INTEGRITY FALSE` desactiva temporalmente las restricciones de integridad referencial
  (`foreign keys`).
- Esto permite truncar tablas en cualquier orden sin errores.
- Se reactivan al final para restaurar la consistencia.

`cleanup-mysql.sql`

````sql
-- Limpieza de datos para MySQL
-- Desactiva temporalmente las validaciones de foreign keys
SET FOREIGN_KEY_CHECKS = 0;

-- Limpia las tablas en cualquier orden
TRUNCATE TABLE accounts;
TRUNCATE TABLE banks;

-- Reactivar verificaci√≥n de foreign keys
SET FOREIGN_KEY_CHECKS = 1;
````

- `SET FOREIGN_KEY_CHECKS = 0` desactiva la verificaci√≥n de claves for√°neas.
- Ideal cuando se tiene un modelo relacional con dependencias.
- Es equivalente al comportamiento de `SET REFERENTIAL_INTEGRITY FALSE` en `H2`.

### üíæ Carga de datos (`data-test.sql`)

`data-test.sql`

````sql
-- Datos de prueba compartidos entre H2 y MySQL
-- Este archivo es la √öNICA FUENTE DE VERDAD para los datos de test

-- Bancos
INSERT INTO banks(name, total_transfers)
VALUES('BCP', 0),
('BBVA', 0),
('Interbank', 0),
('Scotiabank', 0);

-- Cuentas
INSERT INTO accounts(holder, balance, bank_id)
VALUES('Lesly √Åguila', 3000.00, 1),
('Cielo Fern√°ndez', 2000.00, 1),
('Susana Alvarado', 5000.00, 2),
('Briela Cirilo', 1000.00, 2),
('Milagros D√≠az', 3500.00, 3),
('Kiara Lozano', 100.00, 4),
('Analuc√≠a Urbina', 4000.00, 4),
('Yrma Guerrero', 7000.00, 4);
````

- Mantener un √∫nico archivo de datos base evita duplicaci√≥n y divergencia entre entornos.
- Los IDs no se definen expl√≠citamente para aprovechar la generaci√≥n autom√°tica (`AUTO_INCREMENT` o secuencias).
- Los nombres y montos est√°n dise√±ados para permitir pruebas predecibles y consistentes.

### üß© Clase de constantes para scripts

Ubicaci√≥n: `/src/test/java/dev/magadiflo/app/constants/TestScripts.java`

````java

@UtilityClass
public class TestScripts {
    // Limpieza por BD
    public static final String CLEANUP_H2 = "/sql-test/cleanup-h2.sql";
    public static final String CLEANUP_MYSQL = "/sql-test/cleanup-mysql.sql";

    // Datos compartidos
    public static final String DATA_TEST = "/sql-test/data-test.sql";

    // Combinaci√≥n comunes
    public static final String[] H2_INIT = {CLEANUP_H2, DATA_TEST};
    public static final String[] MYSQL_INIT = {CLEANUP_MYSQL, DATA_TEST};
}
````

üìò Ventajas de esta pr√°ctica:

| ‚úÖ Beneficio                               | Descripci√≥n                                     |
|-------------------------------------------|-------------------------------------------------|
| **Centralizaci√≥n**                        | Si cambias una ruta, solo lo haces en un lugar. |
| **Autocompletado del IDE**                | Reduce errores de tipeo al usar `@Sql`.         |
| **Verificaci√≥n en tiempo de compilaci√≥n** | Evita fallos silenciosos por rutas incorrectas. |

## üß™ Pruebas de Integraci√≥n con `@DataJpaTest` usando `H2`

Antes de continuar con la implementaci√≥n, vale la pena aclarar `por qu√©` las pruebas con `@DataJpaTest` se consideran
`pruebas de integraci√≥n` y `no unitarias`.

Esta distinci√≥n es clave para entender el prop√≥sito y alcance de los tests sobre repositorios.

### üí° ¬øPor qu√© no se consideran unitarias?

Basado en una excelente explicaci√≥n de
[Stack Overflow](https://stackoverflow.com/questions/23435937/how-to-test-spring-data-repositories):

- En resumen, no hay forma razonable de realizar pruebas unitarias sobre los repositorios de Spring Data JPA,
  ya que ser√≠a demasiado complejo simular todas las partes de la API JPA necesarias para arrancar los repositorios.
- Adem√°s, `no hay c√≥digo propio que probar`, ya que los repositorios son implementaciones generadas por Spring.
- Por tanto, `las pruebas de integraci√≥n son el enfoque m√°s sensato` porque lo que realmente nos interesa validar son:
    - üß© El mapeo de entidades (`Entity mappings`)
    - ‚öôÔ∏è La sem√°ntica de las consultas (`Query semantics`)

### üß± En resumen

- `Las pruebas unitarias` verifican el comportamiento de piezas de c√≥digo aisladas, sin depender de otros m√≥dulos ni
  recursos externos. Ejemplo: probar un m√©todo de servicio o una clase utilitaria usando `Mockito`.


- `Las pruebas de integraci√≥n`, en cambio, validan la interacci√≥n entre distintos componentes del sistema (por ejemplo,
  `repositorios` + `base de datos`). En este caso, al usar una base en memoria (`H2`), nuestras pruebas est√°n
  interactuando con un m√≥dulo de persistencia real, lo que las convierte autom√°ticamente en `pruebas de integraci√≥n`.

[Fuente original en Stack Overflow](https://stackoverflow.com/questions/23435937/how-to-test-spring-data-repositories)

> Para abreviar, no hay forma de realizar `pruebas unitarias` de los repositorios `Spring Data JPA` razonablemente por
> una raz√≥n simple: es demasiado engorroso simular todas las partes de la API JPA que invocamos para arrancar los
> repositorios. De todos modos, las pruebas unitarias no tienen mucho sentido aqu√≠, ya que normalmente no est√°
> escribiendo ning√∫n c√≥digo de implementaci√≥n usted mismo, por lo que las `pruebas de integraci√≥n` son el enfoque m√°s
> razonable.
>
> Si lo piensa, **no hay c√≥digo que escriba para sus repositorios, por lo que no hay necesidad de escribir pruebas
> unitarias.** Simplemente, no hay necesidad de hacerlo, ya que puede confiar en nuestra base de prueba para detectar
> errores b√°sicos. Sin embargo, definitivamente `se necesitan pruebas de integraci√≥n` para probar dos aspectos de su
> capa de persistencia, porque son los aspectos relacionados con su dominio:
>
> * Entity mappings
> * Query semantics

### ‚ö†Ô∏è Buenas pr√°cticas

Solo tiene sentido testear los `m√©todos personalizados` que nosotros definimos en los repositorios:

- M√©todos derivados de `naming convention` (`findByEmail`, `findByBalanceGreaterThan`, etc.)
- Consultas personalizadas con `@Query`
- `Consultas nativas` o `JPQL`
- Relaciones entre entidades (joins, lazy/eager loading, etc.)

No es necesario probar los m√©todos b√°sicos como `findAll()`, `save()`, `deleteById()`, etc., ya que forman parte
de la infraestructura probada de `Spring Data JPA`.

‚úÖ **Conclusi√≥n**

Las pruebas con `@DataJpaTest` son `pruebas de integraci√≥n` enfocadas en la capa de persistencia.
Permiten verificar la correcta integraci√≥n entre `Spring Data JPA`, `Hibernate` y la `base de datos` (`H2` o `MySQL`),
asegurando que el modelo de dominio y las consultas funcionen tal como se espera en tiempo de ejecuci√≥n.

### üéØ La anotaci√≥n `@DataJpaTest`

üìò [Referencia oficial ‚Äî Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/html/boot-features-testing.html)

La anotaci√≥n `@DataJpaTest` se utiliza cuando queremos `probar la capa de persistencia` (`repositorios JPA`) de una
aplicaci√≥n Spring Boot. Por defecto, esta anotaci√≥n:

- Configura una `base de datos embebida en memoria` (como `H2`, `HSQL` o `Derby`).
- Escanea las clases anotadas con `@Entity` para registrar las entidades `JPA`.
- Configura los repositorios de `Spring Data JPA` (`@Repository`).
- Excluye el resto de los beans (`@Service`, `@Controller`, `@Component`, etc.) del contexto de pruebas.

Es decir, el contexto cargado es `parcial` y contiene `solo lo necesario` para probar la capa de acceso a datos.

### üéØ Comportamiento transaccional de la anotac√≠on `@DataJpaTest`

Los tests anotados con `@DataJpaTest` son `transaccionales por defecto`.
Esto significa que:

- Cada m√©todo de prueba se ejecuta dentro de una `transacci√≥n`.
- Al finalizar la prueba, `Spring revierte autom√°ticamente la transacci√≥n`.
- Como resultado, `la base de datos vuelve a su estado original`, garantizando un entorno limpio y repetible.

üîÅ Ejemplo conceptual

````
@BeforeEach -> Inserta datos (por SQL o @Sql)
@Test       -> Ejecuta operaciones del repositorio
@AfterEach  -> Rollback autom√°tico ‚Üí BD limpia
````

Esto evita efectos colaterales entre pruebas y permite ejecutar cada test de forma independiente.

### üö´ Lo que NO carga `@DataJpaTest`

El contexto `no incluye beans de otras capas`, como:

- `@Component`
- `@Service`
- `@Controller`

Esto tiene un prop√≥sito: `aislar la capa de persistencia` para asegurar que lo que se prueba es la interacci√≥n entre
tus repositorios y la base de datos (no la l√≥gica de negocio ni los controladores web).

Si necesitas acceder a servicios o l√≥gica adicional, puedes complementarlo con @Import o usar @SpringBootTest (para
pruebas de integraci√≥n completas).

### ‚öôÔ∏è Configuraci√≥n inicial de prueba de repositorio con `@DataJpaTest` (perfil `test-h2`)

Antes de continuar, recordemos que una `prueba de integraci√≥n` valida c√≥mo los componentes interact√∫an entre s√≠ y con
sus dependencias externas (por ejemplo, una base de datos). En este caso, verificamos la integraci√≥n entre
`Spring Data JPA` y `H2` como base de datos en memoria.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Autowired
    private DataSource dataSource;

    // Solo verificamos que estamos usando la base de datos h2
    @Test
    void shouldUseH2Database() throws SQLException {
        String url = this.dataSource.getConnection().getMetaData().getURL();
        log.info("Usando base de datos: {}", url);
        assertThat(url).contains("h2");
    }
}
````

üìò Explicaci√≥n detallada

- `@ActiveProfiles("test-h2")`. Activa expl√≠citamente el perfil `test-h2`, lo que hace que Spring cargue la combinaci√≥n
  de:
    - `application.yml` (base)
    - `application-test-h2.yml` (configuraci√≥n espec√≠fica)


- `@Sql`. Se usa para ejecutar scripts SQL antes o despu√©s de las pruebas.
    ````
    @Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
    ````
    - `TestScripts.DATA_TEST`: constante que apunta al script `/sql-test/data-test.sql`.
    - `BEFORE_TEST_CLASS`: ejecuta el script una sola vez por clase de prueba, antes de cualquier m√©todo.
    - No usamos `AFTER_TEST_METHOD` porque cada prueba con `@DataJpaTest` se ejecuta en una `transacci√≥n` con `rollback`
      autom√°tico.
    - Los datos se cargan una sola vez y cada m√©todo de prueba deja la base en su estado original gracias al rollback
      autom√°tico.


- `@DataJpaTest`. Configura autom√°ticamente solo los componentes de la capa JPA:
    - Escanea entidades `(@Entity`) y repositorios (`@Repository`).
    - Configura un `DataSource` (por defecto H2 si no se define otro).
    - Activa transacciones autom√°ticas con rollback al finalizar cada prueba.
    - Equivale a un slice test (prueba de ‚Äúrebanada‚Äù de la aplicaci√≥n).
    - No carga `@Service`, `@Controller`, ni otros beans fuera del contexto de persistencia.
    - Se usa `@DataJpaTest` para aislar la l√≥gica de persistencia, evitando el arranque completo de Spring Boot. Esto
      reduce el tiempo de ejecuci√≥n y mejora la confiabilidad de las pruebas de base de datos.

üéØ Resumen:

- `@DataJpaTest` es `@Transactional`, es decir cada test hace rollback autom√°tico.
- `BEFORE_TEST_CLASS` + `@DataJpaTest`, los datos se cargan 1 vez, permanecen intactos entre m√©todos test por el
  rollback aplicado por defecto gracias al `@DataJpaTest`.
- No necesitamos `BEFORE_TEST_METHOD` en tests de repositorio.
- No necesitamos `cleanup-h2.sql` porque el `rollback` se encarga.

El siguiente log muestra el resultado luego de ejecutar la prueba de integraci√≥n `AccountRepositoryH2Test`.

````bash
2025-10-17T14:54:41.751-05:00 DEBUG 10720 --- [spring-rest-api] [           main] sContextBeforeModesTestExecutionListener : Before test method: class [AccountRepositoryH2Test], method [shouldUseH2Database], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] t.c.t.TransactionalTestExecutionListener : Explicit transaction definition [PROPAGATION_REQUIRED,ISOLATION_DEFAULT] found for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test] and test method [shouldUseH2Database]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] org.springframework.test.context.cache   : Spring test ApplicationContext cache statistics: [DefaultContextCache@1703e50d size = 1, maxSize = 32, parentContextCount = 0, hitCount = 6, missCount = 1, failureCount = 0]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] t.c.t.TransactionalTestExecutionListener : No method-level @Rollback override: using default rollback [true] for test method [void dev.magadiflo.app.integration.repository.AccountRepositoryH2Test.shouldUseH2Database() throws java.sql.SQLException]
2025-10-17T14:54:41.761-05:00 DEBUG 10720 --- [spring-rest-api] [           main] o.s.t.c.transaction.TransactionContext   : Began transaction (1) for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test]; test method [shouldUseH2Database]; transaction manager [org.springframework.orm.jpa.JpaTransactionManager@1e4d93f7]; rollback [true]
2025-10-17T14:54:42.161-05:00  INFO 10720 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : Usando base de datos: jdbc:h2:mem:6952d30f-7a0c-463e-a2a6-37a576307e61
2025-10-17T14:54:42.221-05:00 DEBUG 10720 --- [spring-rest-api] [           main] o.s.t.c.transaction.TransactionContext   : Rolled back transaction (1) for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test]; test method [shouldUseH2Database]
2025-10-17T14:54:42.221-05:00 DEBUG 10720 --- [spring-rest-api] [           main] .c.s.DirtiesContextTestExecutionListener : After test method: class [AccountRepositoryH2Test], method [shouldUseH2Database], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null] 
````

üìñ Interpretaci√≥n:

- La prueba confirm√≥ que la BD activa es H2.
- Se abri√≥ una transacci√≥n para el test.
- Al finalizar, se ejecut√≥ el rollback autom√°tico.

### üß© Obtener todas las cuentas registradas

Este test valida que el m√©todo personalizado `getAllAccounts()` del repositorio `AccountRepository` devuelva
correctamente todas las cuentas almacenadas en la base de datos `H2` de pruebas.

Adem√°s, se verifica que la lista no est√© vac√≠a, tenga la cantidad esperada de registros (8), y contenga titulares
espec√≠ficos que se insertaron previamente mediante el script `data-test.sql`.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnAllAccountsWhenDatabaseIsInitialized() {
        // when
        List<AccountResponse> accounts = this.accountRepository.getAllAccounts();

        // then
        assertThat(accounts)
                .isNotEmpty()
                .hasSize(8)
                .extracting(AccountResponse::holder)
                .contains("Lesly √Åguila", "Briela Cirilo", "Milagros D√≠az");
    }
}
````

- Este test se ejecuta dentro de una transacci√≥n administrada por `@DataJpaTest`, por lo que cualquier modificaci√≥n se
  revierte autom√°ticamente.
- La aserci√≥n con `extracting(AccountResponse::holder)` permite validar valores de un campo espec√≠fico de todos los
  elementos de la colecci√≥n, facilitando la verificaci√≥n sem√°ntica del contenido.

### üß© Verificar que todas las cuentas tengan un banco asociado

Este test confirma que cada cuenta obtenida por el m√©todo `getAllAccounts()` tenga todos sus campos v√°lidos y, en
particular, que posea un banco asociado.

Se valida que ning√∫n registro tenga valores nulos o en blanco, y adem√°s se comprueba que al menos una cuenta pertenece
al banco BCP, garantizando que los datos fueron cargados correctamente desde el script SQL.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldHaveAssociatedBankForAllAccountsWhenFetchingAccounts() {
        // when
        List<AccountResponse> accounts = this.accountRepository.getAllAccounts();

        // then
        assertThat(accounts)
                .isNotEmpty()
                .hasSize(8)
                .allSatisfy(account -> {
                    assertThat(account.id()).isNotNull();
                    assertThat(account.holder()).isNotBlank();
                    assertThat(account.balance()).isNotNull().isPositive();
                    assertThat(account.bankName())
                            .withFailMessage("La cuenta con ID %d (titular: %s) debe tener banco asociado",
                                    account.id(), account.holder())
                            .isNotBlank();
                });

        // Verificaci√≥n adicional: Al menos una cuenta es del BCP
        assertThat(accounts)
                .extracting(AccountResponse::bankName)
                .contains("BCP");
    }
}
````

- Se usa `allSatisfy(...)` de `AssertJ` para validar que todas las cuentas cumplan simult√°neamente con las condiciones
  de integridad.
- El m√©todo `withFailMessage(...)` agrega contexto al error, mostrando exactamente cu√°l cuenta no cumple la condici√≥n,
  lo que facilita la depuraci√≥n.
- Esta prueba tambi√©n demuestra c√≥mo validar relaciones entre entidades (cuenta ‚Üí banco) sin necesidad de usar joins
  expl√≠citos en el test.

### üß© Buscar una cuenta por su ID

Este test valida que el m√©todo `findById()` del repositorio `AccountRepository` retorne correctamente una cuenta
existente en la base de datos seg√∫n su identificador.

Se verifica tanto la informaci√≥n de la cuenta (titular, balance) como la relaci√≥n con su banco asociado (Bank).

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnAccountWithBankWhenFindByIdExists() {
        // given
        Long accountId = 1L;

        // when
        Optional<Account> optionalAccount = this.accountRepository.findById(accountId);

        // then
        assertThat(optionalAccount)
                .isPresent()
                .hasValueSatisfying(account -> {
                    assertThat(account.getId()).isEqualTo(accountId);
                    assertThat(account.getHolder()).isEqualTo("Lesly √Åguila");
                    assertThat(account.getBalance()).isEqualByComparingTo("3000");
                    assertThat(account.getBank())
                            .isNotNull()
                            .extracting(Bank::getId, Bank::getName)
                            .containsExactly(1L, "BCP");
                });
    }
}
````

üß† Notas adicionales

- `isPresent()`. Verifica que el `Optional<Account>` contenga un valor, asegurando que la cuenta fue encontrada.
- `hasValueSatisfying(...)`. Permite aplicar m√∫ltiples aserciones sobre el valor contenido en el Optional sin necesidad
  de desempaquetarlo manualmente.
- `extracting(Bank::getId, Bank::getName)`. Extrae varios campos de un objeto (Bank) para validarlos en conjunto
  mediante `containsExactly(...)`.
- `isEqualByComparingTo("3000")`. Es la forma recomendada de comparar valores num√©ricos (`BigDecimal`) en `AssertJ`,
  evitando errores por escala decimal.

üìò Conclusi√≥n:
> Este test confirma la correcta integraci√≥n entre `AccountRepository` y la capa de persistencia al obtener una entidad
> `Account` con su relaci√≥n `Bank`.
>
> Adem√°s, refuerza el concepto de integraci√≥n entre entidades al validar los mapeos JPA y los valores retornados por el
> repositorio.

### üß© Retorna un Optional vac√≠o cuando la cuenta no existe

Este test valida que el m√©todo `findById()` del repositorio `AccountRepository` retorne un `Optional.empty()`
cuando se busca una cuenta con un identificador inexistente en la base de datos.

De esta forma confirmamos que el repositorio maneja correctamente los escenarios donde no se encuentran resultados, sin
lanzar excepciones ni retornar valores nulos.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnEmptyOptionalWhenAccountIdDoesNotExist() {
        // given
        Long accountId = 999L;

        // when
        Optional<Account> optionalAccount = this.accountRepository.findById(accountId);

        // then
        assertThat(optionalAccount).isEmpty();

    }
}
````

- `isEmpty()`. Verifica que el `Optional<Account>` no contenga ning√∫n valor, asegurando que el m√©todo maneja
  correctamente la ausencia de datos sin devolver `null`.
- Esta validaci√≥n previene posibles `NullPointerException` en el c√≥digo de producci√≥n, ya que `Optional` obliga al
  consumidor del m√©todo a manejar expl√≠citamente los casos donde no hay resultado.
- Es una buena pr√°ctica incluir este tipo de pruebas negativas en los repositorios, ya que validan comportamientos
  esperados ante datos inexistentes o inconsistentes.

### üß© Registra una cuenta

Este test verifica que el m√©todo `save()` del repositorio `AccountRepository` permita registrar correctamente una nueva
cuenta en la base de datos `H2`.

Se asegura que al guardar una entidad `Account`, se le asigne un identificador autogenerado, se persistan correctamente
los campos del titular, saldo y la relaci√≥n con un banco existente.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldSaveAccountWhenValidDataProvided() {
        // given
        Account newAccount = Account.builder()
                .holder("Edwin Guerrero Test")
                .balance(new BigDecimal("5000"))
                .bank(Bank.builder().id(1L).build())
                .build();

        // when
        Account savedAccount = this.accountRepository.save(newAccount);

        // then
        assertThat(savedAccount.getId())
                .isNotNull()
                .isEqualTo(9);
        assertThat(savedAccount.getHolder()).isEqualTo("Edwin Guerrero Test");
        assertThat(savedAccount.getBalance()).isEqualByComparingTo("5000");
        assertThat(savedAccount.getBank()).isNotNull();
    }
}
````
