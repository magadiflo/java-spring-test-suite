# üöÄ Integration Test - Test de Repositorios (`@DataJpaTest`)

---

Los `tests de integraci√≥n` validan que los distintos componentes de la aplicaci√≥n (repositorios, servicios,
controladores, etc.) `interact√∫en correctamente entre s√≠` y con dependencias externas como `bases de datos`,
`colas de mensajes` o `servicios HTTP`.

En este caso, probaremos la integraci√≥n entre `Spring Data JPA` y una base de datos, usando primero `H2`
(`en memoria`) y m√°s adelante `MySQL`, para simular entornos m√°s realistas.

## ‚öôÔ∏è Configurar H2 como base de datos en memoria

En el proyecto `spring-rest-api`, agregamos la dependencia de `H2` en el `pom.xml` con el scope limitado a `test`.

### üì¶ Motivo

Usamos `H2` para ejecutar pruebas r√°pidas en memoria sin depender de una base real. M√°s adelante, reemplazaremos
esta configuraci√≥n por `MySQL` o `Testcontainers`, pero `H2` nos permite practicar el flujo de integraci√≥n sin
sobrecargar el entorno.

````xml

<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope> <!-- Importante: solo se usar√° durante los tests -->
</dependency>
````

üí° Nota profesional:
> Aunque `H2` es muy √∫til en fases iniciales, `no siempre refleja el comportamiento real` de `MySQL` o `PostgreSQL`,
> por lo que en entornos reales se recomienda pasar pronto a `Testcontainers` o bases de datos reales en `Docker`.

### üß± Perfiles para pruebas

En lecciones anteriores definimos un `application.yml` dentro de `/src/test/resources` para aislar la configuraci√≥n
de pruebas del entorno principal (`/src/main/resources`).

Ahora organizaremos nuestros archivos de configuraci√≥n de la siguiente manera:

üìÅ Estructura recomendada

````
src/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ       ‚îú‚îÄ‚îÄ application.yml
‚îÇ       ‚îú‚îÄ‚îÄ application-dev.yml
‚îÇ       ‚îú‚îÄ‚îÄ application-qa.yml
‚îÇ       ‚îî‚îÄ‚îÄ application-prod.yml
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ resources/
        ‚îú‚îÄ‚îÄ application.yml               # Config base com√∫n a todos los tests
        ‚îú‚îÄ‚îÄ application-test.yml          # Perfil de pruebas con MySQL real o contenedores
        ‚îî‚îÄ‚îÄ application-test-h2.yml       # Perfil alternativo con base en memoria H2
````

üß© Prop√≥sito de cada archivo

| Archivo                   | Prop√≥sito                                               | Uso t√≠pico                          |
|---------------------------|---------------------------------------------------------|-------------------------------------|
| `application.yml`         | Configuraci√≥n base (puerto aleatorio, nombre app, logs) | Se carga en todos los tests         |
| `application-test.yml`    | Configuraci√≥n de pruebas con MySQL o Testcontainers     | Ideal para CI/CD o integraci√≥n real |
| `application-test-h2.yml` | Configuraci√≥n ligera con H2                             | Ideal para pruebas locales r√°pidas  |

üí¨ Nota:
> Mantener esta separaci√≥n de perfiles te permite cambiar f√°cilmente entre entornos de prueba
> (`H2` ‚Üî `MySQL` ‚Üî `Testcontainers`) sin modificar el c√≥digo fuente, solo ajustando el perfil activo.

## üß† Autoconfiguraci√≥n de H2

Spring Boot detecta autom√°ticamente la dependencia `com.h2database:h2` y `autoconfigura el datasource`
(driver, URL y dialecto), por lo que `no es necesario` definir manualmente esas propiedades para que funcione.

Sin embargo, en entornos profesionales `s√≠ se suele personalizar` la configuraci√≥n para:

- Asignar nombres de base de datos espec√≠ficos.
- Controlar el cierre del contexto.
- Emular el comportamiento de `MySQL` (con `MODE=MySQL`).

üß© Conclusi√≥n:

- Si solo usamos `H2` para pruebas b√°sicas, basta con la dependencia.
- Pero para escenarios m√°s realistas (emulaci√≥n de MySQL, logs SQL, control de ciclo de vida), la configuraci√≥n
  personalizada es una buena pr√°ctica.

## ‚öôÔ∏è Configuraci√≥n base (`application.yml`) en Test

üìç Ubicaci√≥n: `/src/test/resources/application.yml`

````yml
# Configuraci√≥n BASE para todos los perfiles de test
server:
  port: 0  # Puerto aleatorio para evitar conflictos

spring:
  application:
    name: spring-rest-api
  jpa:
    hibernate:
      ddl-auto: create-drop # Crea el schema al levantar el CONTEXTO y se elimina al terminar
    properties:
      hibernate:
        format_sql: true
        show_sql: false
  sql:
    init:
      mode: never # No cargamos datos autom√°ticamente. Cada test cargar√° lo que necesite con @Sql.

# Logging para tests - queremos ver qu√© pasa pero sin saturar
logging:
  level:
    root: INFO
    dev.magadiflo.app: DEBUG
    org.hibernate.SQL: DEBUG                              # Muestra las consultas SQL
    org.hibernate.orm.jdbc.bind: TRACE                    # Muestra par√°metros enviados al SQL
    org.springframework.test: DEBUG                       # Informaci√≥n del contexto de test
````

üß† Explicaci√≥n de configuraci√≥n

- `ddl-auto: create-drop` ‚Üí crea el esquema al iniciar el contexto de Spring (primera vez que se necesita) y lo destruye
  al finalizarlo (cuando ya no hay m√°s tests que lo usen). Un contexto puede ser reutilizado por
  `m√∫ltiples clases de test`.
- ¬øQu√© es un "contexto de Spring? Spring cachea contextos seg√∫n:
    - Anotaciones de test (`@SpringBootTest`, `@DataJpaTest`, `@WebMvcTest`, etc.)
    - Perfiles activos (`@ActiveProfiles`)
    - Configuraciones adicionales (`@TestPropertySource`, `webEnvironment`, etc.)
- El esquema (`create-drop`) se ejecuta por cada contexto √∫nico. Si m√∫ltiples clases de test usan: la misma anotaci√≥n,
  el mismo perfil, la misma configuraci√≥n, Spring REUTILIZA el contexto (1 solo `create-drop` para todas esas clases).
  Si cambia cualquiera de esos elementos ‚Üí Se crea un nuevo contexto (nuevo `create-drop`).
- `format_sql: true` ‚Üí formatea las sentencias SQL en el log, lo que facilita su lectura.
- `show_sql: false` ‚Üí desactiva la impresi√≥n directa en consola con el prefijo `Hibernate:`. Las consultas siguen
  visibles gracias al logger `org.hibernate.SQL: DEBUG`, que ofrece m√°s control y mejor formato.
- En tests usamos `show_sql: false` para evitar duplicidad en consola, ya que el logger `org.hibernate.SQL` ya imprime
  las consultas. En desarrollo no es necesario desactivarlo porque no se activa autom√°ticamente.
- `mode: never` ‚Üí no queremos carga autom√°tica de datos. Cada test cargar√° lo que necesite con `@Sql`.
- `root: WARN` ‚Üí reduce el ruido en consola; solo se muestran advertencias o errores globales.
- `dev.magadiflo.app: DEBUG` ‚Üí habilita logs detallados para nuestras clases.
- `org.hibernate.SQL: DEBUG` ‚Üí muestra las sentencias SQL generadas.
- `org.hibernate.orm.jdbc.bind: TRACE` ‚Üí muestra los valores de los par√°metros enviados al SQL (Hibernate 6.x)
- `org.springframework.test: DEBUG` ‚Üí vemos informaci√≥n del contexto de test.

üí° Recomendaci√≥n:
> Estos niveles de log son muy √∫tiles en etapa de pruebas, pero en producci√≥n deben reducirse a `INFO` o `WARN`
> para evitar sobrecargar los logs.

## ‚öôÔ∏è Perfil `test-h2` ‚Äî Base de datos en memoria

üìç Ubicaci√≥n: `/src/test/resources/application-test-h2.yml`

````yml
spring:
  config:
    activate:
      on-profile: test-h2 # ‚Üê Opcional: el nombre del archivo ya indica el perfil
  datasource:
    url: jdbc:h2:mem:db_test;MODE=MySQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
````

üîç Notas claves

- Este archivo se aplica autom√°ticamente cuando se activa el perfil `test-h2`, por ejemplo con
  `@ActiveProfiles("test-h2")` en nuestras pruebas.
- La propiedad `spring.config.activate.on-profile: test-h2` `es opcional` en archivos que ya siguen la convenci√≥n
  `application-{profile}.yml`. Se usa principalmente en archivos con m√∫ltiples bloques de configuraci√≥n o con nombres
  personalizados.
- Podemos omitirla sin afectar el comportamiento, siempre que el nombre del archivo coincida con el perfil activo.
- `spring.datasource.url`
    - `jdbc:h2:mem:db_test_h2` ‚Üí base de datos en memoria (no persiste en disco).
    - `DB_CLOSE_ON_EXIT=FALSE` ‚Üí evita el cierre autom√°tico al terminar la JVM (√∫til para inspecci√≥n).
    - `DB_CLOSE_DELAY=-1` ‚Üí mantiene viva la BD incluso sin conexiones activas. La BD no se cierra autom√°ticamente
      cuando se cierra la √∫ltima conexi√≥n.
    - `MODE=MySQL` ‚Üí hace que `H2` interprete la sintaxis SQL como `MySQL` (√∫til para dialectos y queries nativos).
- `spring.datasource.username/password`: define credenciales de acceso al motor `H2`. Para entrar por navegador a la
  consola `H2`, necesitamos:
    - Activar la consola con `spring.h2.console.enabled=true`
    - Acceder v√≠a `http://localhost:{puerto}/h2-console`
    - Usar el mismo `jdbc:h2:mem:db_test` como `URL`
    - Username `sa` (usuario por defecto de `H2`)
    - Password (dejar vac√≠o)

‚ö†Ô∏è Importante: Acceder durante un test en ejecuci√≥n
> La BD `H2` en memoria (`mem:`) solo existe mientras la aplicaci√≥n est√° corriendo.
>
> Para inspeccionar datos durante un test podr√≠amos usar `Thread.sleep(300000);` dentro del c√≥digo del test para pausar
> por 5 minutos, por ejemplo, luego acceder a la url, consultar las tablas, etc.

## üìí Activaci√≥n de Perfiles en Tests

### ‚úèÔ∏è En `/main`

Cuando usamos el siguiente archivo de configuraci√≥n base en `src/main/resources/application.yml`
(desarrollo/producci√≥n):

````yml
# application.yml en /main
spring:
  profiles:
    active: dev  # ‚Üê Esto ACTIVA un perfil por defecto
````

Esto dice: `Cuando arranques la aplicaci√≥n, usa el perfil dev autom√°ticamente`. Por lo tanto, al ejecutar:

````bash
$ java -jar app.jar
````

Sin especificar nada, usar√° `dev` porque est√° configurado como perfil activo por defecto. Si queremos cambiarlo, basta
con ejecutar el siguiente comando:

````bash
$ java -jar app.jar --spring.profiles.active=prod
````

### üß™ En `/test`

Tambi√©n podemos tener un archivo de configuraci√≥n base `application.yml` y archivos espec√≠ficos para distintos
perfiles (`test`, `test-h2`, `test-mysql`, etc).

Por ejemplo, en el perfil `test-h2` correspondiente al archivo `src/test/resources/application-test-h2.yml`:

````yml
# application-test-h2.yml en /test
spring:
  config:
    activate:
      on-profile: test-h2  # ‚Üê Esto NO activa, solo DECLARA cu√°ndo aplicar este archivo
````

La configuraci√≥n anterior `NO activa el perfil`, solo dice:
"Este archivo `application-test-h2.yml` se aplicar√° cuando el perfil `test-h2` est√© activo.
**Es una declaraci√≥n condicional, no una activaci√≥n.**

#### üì¢ Importante

> En archivos que siguen la convenci√≥n `application-{profile}.yml`, como `application-test-h2.yml`, la configuraci√≥n
> anterior es `opcional`.
>
> Spring Boot ya sabe que debe aplicar ese archivo si el perfil `test-h2` est√° activo
> (por ejemplo, con `@ActiveProfiles("test-h2")` en nuestros tests). Se recomienda usar la configuraci√≥n anterior
> solo si necesitamos mayor control o si el archivo contiene m√∫ltiples bloques para distintos perfiles.

#### üìã Comparaci√≥n clara

| Propiedad                           | Prop√≥sito                             | D√≥nde se usa                                                                                      |
|-------------------------------------|---------------------------------------|---------------------------------------------------------------------------------------------------|
| `spring.profiles.active`            | `ACTIVA` un perfil por defecto        | Principalmente en `/main`. Tambi√©n puede usarse en `/test`, aunque se prefiere `@ActiveProfiles`. |
| `spring.config.activate.on-profile` | `DECLARA` cu√°ndo aplicar este archivo | Archivos espec√≠ficos de perfil (`application-{profile}.yml`)                                      |

## üîß Entonces, ¬øc√≥mo se activan los perfiles en tests?

Existen tres formas principales de activar un perfil en las pruebas:

### ü•á `Opci√≥n 1`: Con `@ActiveProfiles` (la m√°s com√∫n y recomendada)

````java

@SpringBootTest
@ActiveProfiles("test-h2")  // ‚Üê Activa expl√≠citamente el perfil test-h2 para este test
class BankRepositoryTest {
    // Spring cargar√°: application.yml + application-test-h2.yml
}
````

Es la forma m√°s clara y expl√≠cita: Cada clase define qu√© perfil usar√°, lo que facilita el mantenimiento y la lectura.

### ü•à `Opci√≥n 2`: Con `spring.profiles.active` en `application.yml` de `/test`

````yml
# application.yml en src/test/resources
spring:
  profiles:
    active: test-h2  # ‚Üê Perfil por defecto para TODOS los tests
````

Con esta configuraci√≥n, todos los tests usar√°n `test-h2` a menos que lo sobrescribamos con una anotaci√≥n
`@ActiveProfiles` espec√≠fica.

### ü•â `Opci√≥n 3`: Par√°metro en l√≠nea con `Maven` (o Gradle)

````bash
$ mvn test -Dspring.profiles.active=test-h2
````

Esta opci√≥n `activa globalmente el perfil` `test-h2` durante la ejecuci√≥n del comando. Sin embargo, tiene matices
importantes:

- Se aplicar√° solo a las clases que no tengan la anotaci√≥n `@ActiveProfiles`.
- Si una clase de test ya define su perfil con `@ActiveProfiles("otro-perfil")`, esa configuraci√≥n tendr√° prioridad
  sobre el par√°metro de l√≠nea de comandos.

En resumen:
> El par√°metro `-Dspring.profiles.active=...` es √∫til para definir un perfil por defecto cuando ejecutamos una suite
> global, pero no sobrescribir√° los perfiles definidos expl√≠citamente en las clases de test.

### üì¢ Recomendaci√≥n Empresarial

> Evitemos definir `spring.profiles.active` dentro del `application.yml` de `/test`. En su lugar, usemos
> `@ActiveProfiles` en cada clase de test.
>
> Esto nos brinda:
> - `Flexibilidad`: Cada clase elige su perfil sin afectar a las dem√°s.
> - `Claridad`: Al leer el test, se ve inmediatamente qu√© perfil usa.
> - `Compatibilidad CI/CD`: Podemos ejecutar suites diferentes seg√∫n su perfil

## üöÄ ¬øQu√© pasa cuando ejecutamos `mvn test`?

Si tenemos m√∫ltiples clases de test con distintos perfiles y ejecutamos:

````bash
$ mvn test
````

1. `Maven` ejecuta todas las clases de test detectadas bajo `src/test/java`.
2. `Spring TestContext Framework` inicia un `ApplicationContext` **para cada clase de test**, a menos que pueda
   reutilizar uno con la misma configuraci√≥n.
3. En cada clase:
    - Si tiene `@ActiveProfiles("...")` ‚Üí activa ese perfil.
    - Si no tiene `@ActiveProfiles`, usa el perfil por defecto (el definido en `application.yml` o ninguno si no hay).
4. Por lo tanto:
    - Las clases con `@ActiveProfiles("test-h2")` cargar√°n: `application.yml + application-test-h2.yml`.
    - Las que tienen `@ActiveProfiles("test-mysql")` cargar√°n: `application.yml + application-test-mysql.yml`.
    - As√≠ sucesivamente.
    - Las clases sin `@ActiveProfiles` usar√°n solo: `application.yml` (base) o cualquier perfil que est√© activo
      globalmente v√≠a `spring.profiles.active` en `application.yml`, si existiera.

> üéØ No es necesario especificar el perfil con `-Dspring.profiles.active=...` al ejecutar `mvn test`, si ya hemos
> declarado ese perfil en la clase de test con `@ActiveProfiles`, porque Spring lo reconocer√° autom√°ticamente.

> üí° Los perfiles declarados mediante `@ActiveProfiles` tienen prioridad sobre aquellos definidos a trav√©s de
> propiedades del entorno, es decir, siempre tienen mayor precedencia que cualquier valor establecido externamente.
>
> En otras palabras, `@ActiveProfiles` tiene prioridad sobre `-Dspring.profiles.active=....`

## üìò Ejecutar un grupo de tests seg√∫n su perfil

En una aplicaci√≥n con m√∫ltiples clases de test que usan distintos perfiles mediante `@ActiveProfiles(...)`, es com√∫n
querer ejecutar √∫nicamente un subconjunto de pruebas ‚Äî por ejemplo, solo las de integraci√≥n que usan el perfil
`test-integration3`.

Dado que `mvn test` ejecuta `todas` las pruebas encontradas, existen dos formas recomendadas de filtrar los tests
seg√∫n su tipo o perfil asociado:

### üè∑Ô∏è Opci√≥n 1: Por nombre de clase (`-Dtest=...`)

Podemos ejecutar √∫nicamente los tests cuyo nombre coincida con un patr√≥n. Por ejemplo, si nuestras clases siguen una
convenci√≥n como:

````
AccountRepositoryH2Test.java
AccountRepositoryMysqlTest.java
BankIntegration3Test.java
BankIntegration2Test.java
````

Entonces, podemos ejecutar √∫nicamente los tests que correspondan al perfil `test-integration3` con:

````bash
$ mvn test -Dtest=*Integration3Test
````

Con este comando, en realidad no filtramos por perfil, sino por `nombre de clase`. Se asume que la clase
`BankIntegration3Test.java` tiene internamente definido el perfil `@ActiveProfiles("test-integration3");` por tanto,
al ejecutar este patr√≥n, se ejecutar√°n solo las pruebas cuyo nombre coincida y que, a su vez, usan ese perfil.

‚úÖ Ventajas:

- No depende de configuraci√≥n adicional.
- Ideal cuando las clases siguen una convenci√≥n de nombres por perfil (`*IntegrationTest`, `*RepositoryTest`,
  `*ContainerTest`, etc.).
- F√°cil de integrar en pipelines o comandos r√°pidos.

### üè∑Ô∏è Opci√≥n 2: Por etiquetas (`@Tag`)

`JUnit 5` permite clasificar y agrupar pruebas de forma l√≥gica usando la anotaci√≥n `@Tag`, sin depender del nombre de
la clase.

Esto resulta muy √∫til para ejecutar √∫nicamente subconjuntos de tests (por ejemplo, solo los de integraci√≥n,
o los lentos).

````java

@Tag("integration3")
@ActiveProfiles("test-integration3")
class BankIntegration3Test {
    /* code */
}
````

Una vez definida la etiqueta, podemos ejecutar solo los tests que coincidan con ella. El comando a usar depende de
la versi√≥n del plugin `Maven Surefire` configurado en tu proyecto:

- `Surefire "cl√°sico"` (JUnit 4 / TestNG / compatibilidad heredada). Usa la opci√≥n `-Dgroups` para filtrar por etiquetas
  o grupos.
    ````bash
    mvn test -Dgroups=integration3
    ````

- `JUnit Platform moderno` (Surefire ‚â• 2.22.0). Usa `-DincludeTags`, que es la forma nativa de `JUnit 5` para incluir
  etiquetas.
    ````bash
    $ mvn test -DincludeTags=integration3 
    ````

üí° Recomendaci√≥n oficial
> A partir de las versiones recientes de `Maven Surefire`, se recomienda usar `-DincludeTags` en lugar de `-Dgroups`,
> ya que `-Dgroups` se mantiene solo por compatibilidad con versiones anteriores.

‚ö†Ô∏è Nota pr√°ctica (entorno actual)

> En este proyecto (`Spring Boot 3.5.6` + `Surefire 3.5.4`), el comando funcional es `-Dgroups`, mientras que
> `-DincludeTags` no ejecuta los tests etiquetados.
>
> Esto indica que, aunque el plugin est√° actualizado, `Maven` sigue interpretando la configuraci√≥n con el modo de
> compatibilidad activa para `groups`.

üß† Nota importante

> El par√°metro `-Dspring.profiles.active=...` **no filtra las pruebas.** Solo define qu√© perfil se activa globalmente,
> pero no evita que se ejecuten otras clases con `@ActiveProfiles`.
>
> Por tanto, para ejecutar solo un grupo de tests, debemos filtrar expl√≠citamente con nombre (`-Dtest=...`)
> o etiqueta (`-Dgroups=...` o `-DincludeTags=...`).

## üìÇ Scripts SQL para Tests

Definimos y organizamos los scripts SQL que inicializan y limpian la base de datos durante las pruebas de integraci√≥n,
garantizando que cada ejecuci√≥n empiece en un estado limpio y controlado.

### üß± Estructura de directorios

Ubicaci√≥n base: `/src/test/resources/`

````
src/test/resources/
‚îú‚îÄ‚îÄ application.yml                 # Configuraci√≥n base com√∫n
‚îú‚îÄ‚îÄ application-test.yml            # Configuraci√≥n con MySQL (pendiente)
‚îú‚îÄ‚îÄ application-test-h2.yml         # Configuraci√≥n con H2 (en memoria)
‚îî‚îÄ‚îÄ sql-test/
    ‚îú‚îÄ‚îÄ cleanup-h2.sql              # Limpieza espec√≠fica para H2
    ‚îú‚îÄ‚îÄ cleanup-mysql.sql           # Limpieza espec√≠fica para MySQL
    ‚îî‚îÄ‚îÄ data-test.sql               # Datos compartidos (√∫nica fuente de verdad)
````

Mantener los scripts en un subdirectorio como `sql-test/` mejora la organizaci√≥n, permite diferenciar claramente los
datos de prueba de los de desarrollo y facilita su reutilizaci√≥n en distintos perfiles (`test`, `test-h2`, etc.).

### üßº Limpieza de datos (`cleanup-h2.sql` y `cleanup-mysql.sql`)

Los scripts de limpieza eliminan datos entre ejecuciones de tests, asegurando que cada prueba comience con un estado
consistente sin depender de los resultados de ejecuciones previas.

`cleanup-h2.sql`

````sql
-- Limpieza de datos para H2
-- Desactiva temporalmente las validaciones de integridad referencial
SET REFERENTIAL_INTEGRITY FALSE;

-- Limpia las tablas en cualquier orden (sin preocuparte por FKs)
TRUNCATE TABLE accounts;
TRUNCATE TABLE banks;

-- Reactiva las validaciones
SET REFERENTIAL_INTEGRITY TRUE;
````

- `SET REFERENTIAL_INTEGRITY FALSE` desactiva temporalmente las restricciones de integridad referencial
  (`foreign keys`).
- Esto permite truncar tablas en cualquier orden sin errores.
- Se reactivan al final para restaurar la consistencia.

`cleanup-mysql.sql`

````sql
-- Limpieza de datos para MySQL
-- Desactiva temporalmente las validaciones de foreign keys
SET FOREIGN_KEY_CHECKS = 0;

-- Limpia las tablas en cualquier orden
TRUNCATE TABLE accounts;
TRUNCATE TABLE banks;

-- Reactivar verificaci√≥n de foreign keys
SET FOREIGN_KEY_CHECKS = 1;
````

- `SET FOREIGN_KEY_CHECKS = 0` desactiva la verificaci√≥n de claves for√°neas.
- Ideal cuando se tiene un modelo relacional con dependencias.
- Es equivalente al comportamiento de `SET REFERENTIAL_INTEGRITY FALSE` en `H2`.

### üíæ Carga de datos (`data-test.sql`)

`data-test.sql`

````sql
-- Datos de prueba compartidos entre H2 y MySQL
-- Este archivo es la √öNICA FUENTE DE VERDAD para los datos de test

-- Bancos
INSERT INTO banks(name, total_transfers)
VALUES('BCP', 0),
('BBVA', 0),
('Interbank', 0),
('Scotiabank', 0);

-- Cuentas
INSERT INTO accounts(holder, balance, bank_id)
VALUES('Lesly √Åguila', 3000.00, 1),
('Cielo Fern√°ndez', 2000.00, 1),
('Susana Alvarado', 5000.00, 2),
('Briela Cirilo', 1000.00, 2),
('Milagros D√≠az', 3500.00, 3),
('Kiara Lozano', 100.00, 4),
('Analuc√≠a Urbina', 4000.00, 4),
('Yrma Guerrero', 7000.00, 4);
````

- Mantener un √∫nico archivo de datos base evita duplicaci√≥n y divergencia entre entornos.
- Los IDs no se definen expl√≠citamente para aprovechar la generaci√≥n autom√°tica (`AUTO_INCREMENT` o secuencias).
- Los nombres y montos est√°n dise√±ados para permitir pruebas predecibles y consistentes.

### üß© Clase de constantes para scripts

Ubicaci√≥n: `/src/test/java/dev/magadiflo/app/constants/TestScripts.java`

````java

@UtilityClass
public class TestScripts {
    // Limpieza por BD
    public static final String CLEANUP_H2 = "/sql-test/cleanup-h2.sql";
    public static final String CLEANUP_MYSQL = "/sql-test/cleanup-mysql.sql";

    // Datos compartidos
    public static final String DATA_TEST = "/sql-test/data-test.sql";

    // Combinaci√≥n comunes
    public static final String[] H2_INIT = {CLEANUP_H2, DATA_TEST};
    public static final String[] MYSQL_INIT = {CLEANUP_MYSQL, DATA_TEST};
}
````

üìò Ventajas de esta pr√°ctica:

| ‚úÖ Beneficio                               | Descripci√≥n                                     |
|-------------------------------------------|-------------------------------------------------|
| **Centralizaci√≥n**                        | Si cambias una ruta, solo lo haces en un lugar. |
| **Autocompletado del IDE**                | Reduce errores de tipeo al usar `@Sql`.         |
| **Verificaci√≥n en tiempo de compilaci√≥n** | Evita fallos silenciosos por rutas incorrectas. |

## üß™ Pruebas de Integraci√≥n con `@DataJpaTest` usando `H2`

Antes de continuar con la implementaci√≥n, vale la pena aclarar `por qu√©` las pruebas con `@DataJpaTest` se consideran
`pruebas de integraci√≥n` y `no unitarias`.

Esta distinci√≥n es clave para entender el prop√≥sito y alcance de los tests sobre repositorios.

### üí° ¬øPor qu√© no se consideran unitarias?

Basado en una excelente explicaci√≥n de
[Stack Overflow](https://stackoverflow.com/questions/23435937/how-to-test-spring-data-repositories):

- En resumen, no hay forma razonable de realizar pruebas unitarias sobre los repositorios de Spring Data JPA,
  ya que ser√≠a demasiado complejo simular todas las partes de la API JPA necesarias para arrancar los repositorios.
- Adem√°s, `no hay c√≥digo propio que probar`, ya que los repositorios son implementaciones generadas por Spring.
- Por tanto, `las pruebas de integraci√≥n son el enfoque m√°s sensato` porque lo que realmente nos interesa validar son:
    - üß© El mapeo de entidades (`Entity mappings`)
    - ‚öôÔ∏è La sem√°ntica de las consultas (`Query semantics`)

### üß± En resumen

- `Las pruebas unitarias` verifican el comportamiento de piezas de c√≥digo aisladas, sin depender de otros m√≥dulos ni
  recursos externos. Ejemplo: probar un m√©todo de servicio o una clase utilitaria usando `Mockito`.


- `Las pruebas de integraci√≥n`, en cambio, validan la interacci√≥n entre distintos componentes del sistema (por ejemplo,
  `repositorios` + `base de datos`). En este caso, al usar una base en memoria (`H2`), nuestras pruebas est√°n
  interactuando con un m√≥dulo de persistencia real, lo que las convierte autom√°ticamente en `pruebas de integraci√≥n`.

[Fuente original en Stack Overflow](https://stackoverflow.com/questions/23435937/how-to-test-spring-data-repositories)

> Para abreviar, no hay forma de realizar `pruebas unitarias` de los repositorios `Spring Data JPA` razonablemente por
> una raz√≥n simple: es demasiado engorroso simular todas las partes de la API JPA que invocamos para arrancar los
> repositorios. De todos modos, las pruebas unitarias no tienen mucho sentido aqu√≠, ya que normalmente no est√°
> escribiendo ning√∫n c√≥digo de implementaci√≥n usted mismo, por lo que las `pruebas de integraci√≥n` son el enfoque m√°s
> razonable.
>
> Si lo piensa, **no hay c√≥digo que escriba para sus repositorios, por lo que no hay necesidad de escribir pruebas
> unitarias.** Simplemente, no hay necesidad de hacerlo, ya que puede confiar en nuestra base de prueba para detectar
> errores b√°sicos. Sin embargo, definitivamente `se necesitan pruebas de integraci√≥n` para probar dos aspectos de su
> capa de persistencia, porque son los aspectos relacionados con su dominio:
>
> * Entity mappings
> * Query semantics

### ‚ö†Ô∏è Buenas pr√°cticas

Solo tiene sentido testear los `m√©todos personalizados` que nosotros definimos en los repositorios:

- M√©todos derivados de `naming convention` (`findByEmail`, `findByBalanceGreaterThan`, etc.)
- Consultas personalizadas con `@Query`
- `Consultas nativas` o `JPQL`
- Relaciones entre entidades (joins, lazy/eager loading, etc.)

No es necesario probar los m√©todos b√°sicos como `findAll()`, `save()`, `deleteById()`, etc., ya que forman parte
de la infraestructura probada de `Spring Data JPA`.

‚úÖ **Conclusi√≥n**

Las pruebas con `@DataJpaTest` son `pruebas de integraci√≥n` enfocadas en la capa de persistencia.
Permiten verificar la correcta integraci√≥n entre `Spring Data JPA`, `Hibernate` y la `base de datos` (`H2` o `MySQL`),
asegurando que el modelo de dominio y las consultas funcionen tal como se espera en tiempo de ejecuci√≥n.

### üéØ La anotaci√≥n `@DataJpaTest`

üìò [Referencia oficial ‚Äî Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/html/boot-features-testing.html)

La anotaci√≥n `@DataJpaTest` se utiliza cuando queremos `probar la capa de persistencia` (`repositorios JPA`) de una
aplicaci√≥n Spring Boot. Por defecto, esta anotaci√≥n:

- Configura una `base de datos embebida en memoria` (como `H2`, `HSQL` o `Derby`).
- Escanea las clases anotadas con `@Entity` para registrar las entidades `JPA`.
- Configura los repositorios de `Spring Data JPA` (`@Repository`).
- Excluye el resto de los beans (`@Service`, `@Controller`, `@Component`, etc.) del contexto de pruebas.

Es decir, el contexto cargado es `parcial` y contiene `solo lo necesario` para probar la capa de acceso a datos.

### üéØ Comportamiento transaccional de la anotac√≠on `@DataJpaTest`

Los tests anotados con `@DataJpaTest` son `transaccionales por defecto`.
Esto significa que:

- Cada m√©todo de prueba se ejecuta dentro de una `transacci√≥n`.
- Al finalizar la prueba, `Spring revierte autom√°ticamente la transacci√≥n`.
- Como resultado, `la base de datos vuelve a su estado original`, garantizando un entorno limpio y repetible.

üîÅ Ejemplo conceptual

````
@BeforeEach -> Inserta datos (por SQL o @Sql)
@Test       -> Ejecuta operaciones del repositorio
@AfterEach  -> Rollback autom√°tico ‚Üí BD limpia
````

Esto evita efectos colaterales entre pruebas y permite ejecutar cada test de forma independiente.

### üö´ Lo que NO carga `@DataJpaTest`

El contexto `no incluye beans de otras capas`, como:

- `@Component`
- `@Service`
- `@Controller`

Esto tiene un prop√≥sito: `aislar la capa de persistencia` para asegurar que lo que se prueba es la interacci√≥n entre
tus repositorios y la base de datos (no la l√≥gica de negocio ni los controladores web).

Si necesitas acceder a servicios o l√≥gica adicional, puedes complementarlo con @Import o usar @SpringBootTest (para
pruebas de integraci√≥n completas).

### ‚öôÔ∏è Configuraci√≥n inicial de prueba de repositorio con `@DataJpaTest` (perfil `test-h2`)

Antes de continuar, recordemos que una `prueba de integraci√≥n` valida c√≥mo los componentes interact√∫an entre s√≠ y con
sus dependencias externas (por ejemplo, una base de datos). En este caso, verificamos la integraci√≥n entre
`Spring Data JPA` y `H2` como base de datos en memoria.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Autowired
    private DataSource dataSource;

    // Solo verificamos que estamos usando la base de datos h2
    @Test
    void shouldUseH2Database() throws SQLException {
        String url = this.dataSource.getConnection().getMetaData().getURL();
        log.info("Usando base de datos: {}", url);
        assertThat(url).contains("h2");
    }
}
````

üìò Explicaci√≥n detallada

- `@ActiveProfiles("test-h2")`. Activa expl√≠citamente el perfil `test-h2`, lo que hace que Spring cargue la combinaci√≥n
  de:
    - `application.yml` (base)
    - `application-test-h2.yml` (configuraci√≥n espec√≠fica)


- `@Sql`. Se usa para ejecutar scripts SQL antes o despu√©s de las pruebas.
    ````
    @Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
    ````
    - `TestScripts.DATA_TEST`: constante que apunta al script `/sql-test/data-test.sql`.
    - `BEFORE_TEST_CLASS`: ejecuta el script una sola vez por clase de prueba, antes de cualquier m√©todo.
    - No usamos `AFTER_TEST_METHOD` porque cada prueba con `@DataJpaTest` se ejecuta en una `transacci√≥n` con `rollback`
      autom√°tico.
    - Los datos se cargan una sola vez y cada m√©todo de prueba deja la base en su estado original gracias al rollback
      autom√°tico.


- `@DataJpaTest`. Configura autom√°ticamente solo los componentes de la capa JPA:
    - Escanea entidades `(@Entity`) y repositorios (`@Repository`).
    - Configura un `DataSource` (por defecto H2 si no se define otro).
    - Activa transacciones autom√°ticas con rollback al finalizar cada prueba.
    - Equivale a un slice test (prueba de ‚Äúrebanada‚Äù de la aplicaci√≥n).
    - No carga `@Service`, `@Controller`, ni otros beans fuera del contexto de persistencia.
    - Se usa `@DataJpaTest` para aislar la l√≥gica de persistencia, evitando el arranque completo de Spring Boot. Esto
      reduce el tiempo de ejecuci√≥n y mejora la confiabilidad de las pruebas de base de datos.

üéØ Resumen:

- `@DataJpaTest` es `@Transactional`, es decir cada test hace rollback autom√°tico.
- `BEFORE_TEST_CLASS` + `@DataJpaTest`, los datos se cargan 1 vez, permanecen intactos entre m√©todos test por el
  rollback aplicado por defecto gracias al `@DataJpaTest`.
- No necesitamos `BEFORE_TEST_METHOD` en tests de repositorio.
- No necesitamos `cleanup-h2.sql` porque el `rollback` se encarga.

El siguiente log muestra el resultado luego de ejecutar la prueba de integraci√≥n `AccountRepositoryH2Test`.

````bash
2025-10-17T14:54:41.751-05:00 DEBUG 10720 --- [spring-rest-api] [           main] sContextBeforeModesTestExecutionListener : Before test method: class [AccountRepositoryH2Test], method [shouldUseH2Database], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] t.c.t.TransactionalTestExecutionListener : Explicit transaction definition [PROPAGATION_REQUIRED,ISOLATION_DEFAULT] found for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test] and test method [shouldUseH2Database]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] org.springframework.test.context.cache   : Spring test ApplicationContext cache statistics: [DefaultContextCache@1703e50d size = 1, maxSize = 32, parentContextCount = 0, hitCount = 6, missCount = 1, failureCount = 0]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] t.c.t.TransactionalTestExecutionListener : No method-level @Rollback override: using default rollback [true] for test method [void dev.magadiflo.app.integration.repository.AccountRepositoryH2Test.shouldUseH2Database() throws java.sql.SQLException]
2025-10-17T14:54:41.761-05:00 DEBUG 10720 --- [spring-rest-api] [           main] o.s.t.c.transaction.TransactionContext   : Began transaction (1) for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test]; test method [shouldUseH2Database]; transaction manager [org.springframework.orm.jpa.JpaTransactionManager@1e4d93f7]; rollback [true]
2025-10-17T14:54:42.161-05:00  INFO 10720 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : Usando base de datos: jdbc:h2:mem:6952d30f-7a0c-463e-a2a6-37a576307e61
2025-10-17T14:54:42.221-05:00 DEBUG 10720 --- [spring-rest-api] [           main] o.s.t.c.transaction.TransactionContext   : Rolled back transaction (1) for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test]; test method [shouldUseH2Database]
2025-10-17T14:54:42.221-05:00 DEBUG 10720 --- [spring-rest-api] [           main] .c.s.DirtiesContextTestExecutionListener : After test method: class [AccountRepositoryH2Test], method [shouldUseH2Database], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null] 
````

üìñ Interpretaci√≥n:

- La prueba confirm√≥ que la BD activa es H2.
- Se abri√≥ una transacci√≥n para el test.
- Al finalizar, se ejecut√≥ el rollback autom√°tico.

### üß© Obtener todas las cuentas registradas

Este test valida que el m√©todo personalizado `getAllAccounts()` del repositorio `AccountRepository` devuelva
correctamente todas las cuentas almacenadas en la base de datos `H2` de pruebas.

Adem√°s, se verifica que la lista no est√© vac√≠a, tenga la cantidad esperada de registros (8), y contenga titulares
espec√≠ficos que se insertaron previamente mediante el script `data-test.sql`.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnAllAccountsWhenDatabaseIsInitialized() {
        // when
        List<AccountResponse> accounts = this.accountRepository.getAllAccounts();

        // then
        assertThat(accounts)
                .isNotEmpty()
                .hasSize(8)
                .extracting(AccountResponse::holder)
                .contains("Lesly √Åguila", "Briela Cirilo", "Milagros D√≠az");
    }
}
````

- Este test se ejecuta dentro de una transacci√≥n administrada por `@DataJpaTest`, por lo que cualquier modificaci√≥n se
  revierte autom√°ticamente.
- La aserci√≥n con `extracting(AccountResponse::holder)` permite validar valores de un campo espec√≠fico de todos los
  elementos de la colecci√≥n, facilitando la verificaci√≥n sem√°ntica del contenido.

### üß© Verificar que todas las cuentas tengan un banco asociado

Este test confirma que cada cuenta obtenida por el m√©todo `getAllAccounts()` tenga todos sus campos v√°lidos y, en
particular, que posea un banco asociado.

Se valida que ning√∫n registro tenga valores nulos o en blanco, y adem√°s se comprueba que al menos una cuenta pertenece
al banco BCP, garantizando que los datos fueron cargados correctamente desde el script SQL.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldHaveAssociatedBankForAllAccountsWhenFetchingAccounts() {
        // when
        List<AccountResponse> accounts = this.accountRepository.getAllAccounts();

        // then
        assertThat(accounts)
                .isNotEmpty()
                .hasSize(8)
                .allSatisfy(account -> {
                    assertThat(account.id()).isNotNull();
                    assertThat(account.holder()).isNotBlank();
                    assertThat(account.balance()).isNotNull().isPositive();
                    assertThat(account.bankName())
                            .withFailMessage("La cuenta con ID %d (titular: %s) debe tener banco asociado",
                                    account.id(), account.holder())
                            .isNotBlank();
                });

        // Verificaci√≥n adicional: Al menos una cuenta es del BCP
        assertThat(accounts)
                .extracting(AccountResponse::bankName)
                .contains("BCP");
    }
}
````

- Se usa `allSatisfy(...)` de `AssertJ` para validar que todas las cuentas cumplan simult√°neamente con las condiciones
  de integridad.
- El m√©todo `withFailMessage(...)` agrega contexto al error, mostrando exactamente cu√°l cuenta no cumple la condici√≥n,
  lo que facilita la depuraci√≥n.
- Esta prueba tambi√©n demuestra c√≥mo validar relaciones entre entidades (cuenta ‚Üí banco) sin necesidad de usar joins
  expl√≠citos en el test.

### üß© Buscar una cuenta por su ID

Este test valida que el m√©todo `findById()` del repositorio `AccountRepository` retorne correctamente una cuenta
existente en la base de datos seg√∫n su identificador.

Se verifica tanto la informaci√≥n de la cuenta (titular, balance) como la relaci√≥n con su banco asociado (Bank).

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnAccountWithBankWhenFindByIdExists() {
        // given
        Long accountId = 1L;

        // when
        Optional<Account> optionalAccount = this.accountRepository.findById(accountId);

        // then
        assertThat(optionalAccount)
                .isPresent()
                .hasValueSatisfying(account -> {
                    assertThat(account.getId()).isEqualTo(accountId);
                    assertThat(account.getHolder()).isEqualTo("Lesly √Åguila");
                    assertThat(account.getBalance()).isEqualByComparingTo("3000");
                    assertThat(account.getBank())
                            .isNotNull()
                            .extracting(Bank::getId, Bank::getName)
                            .containsExactly(1L, "BCP");
                });
    }
}
````

üß† Notas adicionales

- `isPresent()`. Verifica que el `Optional<Account>` contenga un valor, asegurando que la cuenta fue encontrada.
- `hasValueSatisfying(...)`. Permite aplicar m√∫ltiples aserciones sobre el valor contenido en el Optional sin necesidad
  de desempaquetarlo manualmente.
- `extracting(Bank::getId, Bank::getName)`. Extrae varios campos de un objeto (Bank) para validarlos en conjunto
  mediante `containsExactly(...)`.
- `isEqualByComparingTo("3000")`. Es la forma recomendada de comparar valores num√©ricos (`BigDecimal`) en `AssertJ`,
  evitando errores por escala decimal.

üìò Conclusi√≥n:
> Este test confirma la correcta integraci√≥n entre `AccountRepository` y la capa de persistencia al obtener una entidad
> `Account` con su relaci√≥n `Bank`.
>
> Adem√°s, refuerza el concepto de integraci√≥n entre entidades al validar los mapeos JPA y los valores retornados por el
> repositorio.

### üß© Retorna un Optional vac√≠o cuando la cuenta no existe

Este test valida que el m√©todo `findById()` del repositorio `AccountRepository` retorne un `Optional.empty()`
cuando se busca una cuenta con un identificador inexistente en la base de datos.

De esta forma confirmamos que el repositorio maneja correctamente los escenarios donde no se encuentran resultados, sin
lanzar excepciones ni retornar valores nulos.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnEmptyOptionalWhenAccountIdDoesNotExist() {
        // given
        Long accountId = 999L;

        // when
        Optional<Account> optionalAccount = this.accountRepository.findById(accountId);

        // then
        assertThat(optionalAccount).isEmpty();

    }
}
````

- `isEmpty()`. Verifica que el `Optional<Account>` no contenga ning√∫n valor, asegurando que el m√©todo maneja
  correctamente la ausencia de datos sin devolver `null`.
- Esta validaci√≥n previene posibles `NullPointerException` en el c√≥digo de producci√≥n, ya que `Optional` obliga al
  consumidor del m√©todo a manejar expl√≠citamente los casos donde no hay resultado.
- Es una buena pr√°ctica incluir este tipo de pruebas negativas en los repositorios, ya que validan comportamientos
  esperados ante datos inexistentes o inconsistentes.

### üß© Registra una cuenta

Este test verifica que el m√©todo `save()` del repositorio `AccountRepository` permita registrar correctamente una nueva
cuenta en la base de datos `H2`.

Se asegura que al guardar una entidad `Account`, se le asigne un identificador autogenerado, se persistan correctamente
los campos del titular, saldo y la relaci√≥n con un banco existente.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldSaveAccountWhenValidDataProvided() {
        // given
        Account newAccount = Account.builder()
                .holder("Edwin Guerrero Test")
                .balance(new BigDecimal("5000"))
                .bank(Bank.builder().id(1L).build())
                .build();

        // when
        Account savedAccount = this.accountRepository.save(newAccount);

        // then
        assertThat(savedAccount.getId())
                .isNotNull()
                .isEqualTo(9);
        assertThat(savedAccount.getHolder()).isEqualTo("Edwin Guerrero Test");
        assertThat(savedAccount.getBalance()).isEqualByComparingTo("5000");
        assertThat(savedAccount.getBank()).isNotNull();
    }
}
````

### üß© Elimina una cuenta

Este test valida que el m√©todo personalizado `deleteAccountById(Long id)` del repositorio `AccountRepository` elimine
correctamente una cuenta existente en la base de datos.

El m√©todo de eliminaci√≥n utiliza una consulta nativa junto con la anotaci√≥n `@Modifying(clearAutomatically = true)`
para asegurar que el contexto de persistencia se mantenga sincronizado tras la ejecuci√≥n.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldDeleteAccountWhenExistingIdProvided() {
        // given
        long accountId = 1L;
        assertThat(this.accountRepository.findById(accountId)).isPresent();

        // when
        int affectedRows = this.accountRepository.deleteAccountById(accountId);

        // then
        assertThat(affectedRows).isEqualTo(1);
        assertThat(this.accountRepository.findById(accountId)).isEmpty();
    }
}
````

Recordar que el c√≥digo del repositorio es el siguiente.

````java
public interface AccountRepository extends JpaRepository<Account, Long> {
    @Modifying(clearAutomatically = true)
    @Query(value = """
            DELETE FROM accounts
            WHERE id = :accountId
            """, nativeQuery = true)
    int deleteAccountById(Long accountId);
}
````

üß† Notas adicionales

- `@Modifying`
    - Esta anotaci√≥n se usa en m√©todos que `modifican el estado de la base de datos` (`UPDATE`, `DELETE`, `INSERT`).
    - Por defecto, los m√©todos de repositorio en `Spring Data JPA` asumen que las consultas son solo de lectura
      (`SELECT`), por lo que esta anotaci√≥n es obligatoria para cambios.

- `clearAutomatically = true`
    - Indica a `Spring Data JPA` que, despu√©s de ejecutar la consulta, debe limpiar el contexto de persistencia
      (`EntityManager`).
    - Esto evita que queden entidades `en cach√© o en estado inconsistente` dentro del `Persistence Context`.
    - En nuestro caso, sin esta propiedad, el `EntityManager` mantendr√≠a en memoria la entidad eliminada, por lo que
      el test fallar√≠a al seguir encontr√°ndola mediante `findById(...)`.

### üß© Actualiza una cuenta

Este test valida que el m√©todo personalizado `updateAccountHolder(Account account)` del repositorio `AccountRepository`
actualice correctamente el nombre del titular (`holder`) de una cuenta existente en la base de datos.

El m√©todo de actualizaci√≥n utiliza una consulta nativa junto con la anotaci√≥n `@Modifying(clearAutomatically = true)`
para asegurar que el contexto de persistencia se mantenga sincronizado despu√©s de ejecutar la actualizaci√≥n.

Gracias a esta configuraci√≥n, el `EntityManager` limpia autom√°ticamente su cach√©, garantizando que una posterior
b√∫squeda (`findById(...)`) retorne el valor actualizado desde la base de datos.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldUpdateAccountWhenExistingIdProvided() {
        // given
        long accountId = 1L;
        Account accountToUpdate = Account.builder()
                .id(accountId)
                .holder("Lesly Katherine")
                .build();
        assertThat(this.accountRepository.findById(accountId))
                .isPresent()
                .hasValueSatisfying(account -> {
                    assertThat(account.getId()).isEqualTo(accountId);
                    assertThat(account.getHolder()).isEqualTo("Lesly √Åguila");
                    assertThat(account.getBalance()).isEqualByComparingTo("3000");
                    assertThat(account.getBank())
                            .isNotNull()
                            .extracting(Bank::getId, Bank::getName)
                            .containsExactly(1L, "BCP");
                });

        // when
        int affectedRows = this.accountRepository.updateAccountHolder(accountToUpdate);

        // then
        assertThat(affectedRows).isEqualTo(1);
        assertThat(this.accountRepository.findById(accountId))
                .isPresent()
                .hasValueSatisfying(account -> {
                    assertThat(account.getId()).isEqualTo(accountId);
                    assertThat(account.getHolder()).isEqualTo("Lesly Katherine");
                    assertThat(account.getBalance()).isEqualByComparingTo("3000");
                    assertThat(account.getBank())
                            .isNotNull()
                            .extracting(Bank::getId, Bank::getName)
                            .containsExactly(1L, "BCP");
                });
    }
}
````

üìå Nota t√©cnica
> Sin `clearAutomatically = true`, el `EntityManager` podr√≠a seguir mostrando el valor anterior del titular
> (`Lesly √Åguila`) en la segunda verificaci√≥n, ya que la entidad seguir√≠a en cach√©. Esta propiedad asegura que el
> contexto se sincronice tras el `UPDATE`, especialmente √∫til en entornos de prueba con H2 o cuando se accede a la
> entidad modificada dentro del mismo m√©todo.

## ‚öôÔ∏è Ejecutando Tests de Integraci√≥n

Hasta este punto, contamos con cuatro clases de pruebas unitarias y una clase de prueba de integraci√≥n que utiliza una
base de datos H2 en memoria.

En esta secci√≥n, ejecutaremos √∫nicamente nuestra clase de prueba de integraci√≥n `AccountRepositoryH2Test`.

### üß© Desde IntelliJ IDEA

Podemos ejecutar esta clase directamente desde el `IntelliJ IDEA`, seleccionando el archivo `AccountRepositoryH2Test` y
eligiendo la opci√≥n `Run`.

La siguiente imagen muestra la ejecuci√≥n exitosa, donde todos los tests han pasado correctamente:

![05.png](assets/05.png)

### üíª Desde la L√≠nea de Comandos con Maven

Tambi√©n podemos ejecutar esta misma clase desde la l√≠nea de comandos. Para ello, usamos la bandera `-Dtest`,
indicando el nombre exacto de la clase a ejecutar:

````bash
$ mvn test -Dtest=AccountRepositoryH2Test
````

Con este comando, Maven ejecutar√° solo la clase `AccountRepositoryH2Test` y omitir√° el resto.
Esto es √∫til cuando queremos probar un conjunto reducido de tests, sin ejecutar toda la suite.

### üè∑Ô∏è Alternativa: Ejecutar por @Tag

Otra opci√≥n es etiquetar nuestras clases o m√©todos con `@Tag`, lo que permite agrupar tests por tipo o contexto.
Por ejemplo:

````java

@Tag("integration")
@ActiveProfiles("test-h2")
@SpringBootTest
class AccountRepositoryH2Test { /* code */
}
````

Y luego ejecutarlos con Maven usando:

````bash
$ mvn test -DincludeTags=integration 
````

üîé En versiones antiguas de `Maven Surefire`, se usaba `-Dgroups=nombre_del_tag`, pero actualmente `-DincludeTags`
es la opci√≥n recomendada con `JUnit 5`.

### üß† Detalle Importante

En el log de ejecuci√≥n, podemos observar que Spring Boot detecta autom√°ticamente el perfil activo:

````bash
The following 1 profile is active: "test-h2" 
````

Esto sucede porque la clase `AccountRepositoryH2Test` est√° anotada con `@ActiveProfiles("test-h2")`.
Por lo tanto, al ejecutar `mvn test -Dtest=AccountRepositoryH2Test`, no es necesario indicar manualmente el perfil con
`-Dspring.profiles.active=test-h2`.

### ‚úÖ Resultado Final

La salida muestra una ejecuci√≥n satisfactoria, donde se carga el contexto de Spring, se crea la base de datos H2
embebida y se ejecutan correctamente los 8 tests definidos:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api (feature/spring-rest-api)
$ mvn test -Dtest=AccountRepositoryH2Test
[INFO] Scanning for projects...
[INFO]
[INFO] -------------------< dev.magadiflo:spring-rest-api >--------------------
[INFO] Building spring-rest-api 0.0.1-SNAPSHOT
[INFO]   from pom.xml
[INFO] --------------------------------[ jar ]---------------------------------
...
[INFO] --- surefire:3.5.4:test (default-test) @ spring-rest-api ---
[INFO] Using auto detected provider org.apache.maven.surefire.junitplatform.JUnitPlatformProvider
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running dev.magadiflo.app.integration.repository.AccountRepositoryH2Test
...

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.5.6)

2025-10-20T12:54:59.887-05:00  INFO 4108 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : Starting AccountRepositoryH2Test using Java 21.0.6 with PID 4108 (started by magadiflo in D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api)
2025-10-20T12:54:59.887-05:00 DEBUG 4108 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : Running with Spring Boot v3.5.6, Spring v6.2.11
2025-10-20T12:54:59.887-05:00  INFO 4108 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : The following 1 profile is active: "test-h2"
2025-10-20T12:55:00.348-05:00  INFO 4108 --- [spring-rest-api] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-10-20T12:55:00.445-05:00  INFO 4108 --- [spring-rest-api] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 82 ms. Found 2 JPA repository interfaces.
2025-10-20T12:55:00.497-05:00  INFO 4108 --- [spring-rest-api] [           main] beddedDataSourceBeanFactoryPostProcessor : Replacing 'dataSource' DataSource bean with embedded version
2025-10-20T12:55:00.611-05:00  INFO 4108 --- [spring-rest-api] [           main] o.s.j.d.e.EmbeddedDatabaseFactory        : Starting embedded database: url='jdbc:h2:mem:44d7030a-83ab-4f1a-9924-9de3bd57966a;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false', username='sa'
2025-10-20T12:55:00.867-05:00  INFO 4108 --- [spring-rest-api] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-10-20T12:55:00.917-05:00  INFO 4108 --- [spring-rest-api] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.29.Final
...
2025-10-20T12:55:01.349-05:00  WARN 4108 --- [spring-rest-api] [           main] org.hibernate.orm.deprecation            : HHH90000025: H2Dialect does not need to be specified explicitly using 'hibernate.dialect' (remove the property setting and it will be selected by default)
...
2025-10-20T12:55:04.037-05:00 DEBUG 4108 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    insert
    into
        accounts
        (balance, bank_id, holder, id)
    values
        (?, ?, ?, default)
...
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.933 s -- in dev.magadiflo.app.integration.repository.AccountRepositoryH2Test
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  7.758 s
[INFO] Finished at: 2025-10-20T12:55:04-05:00
[INFO] ------------------------------------------------------------------------
````

## ‚öôÔ∏è Perfil `test` ‚Äî Usando Base de datos MySQL

El archivo `/src/test/resources/application-test.yml` define la configuraci√≥n espec√≠fica para pruebas de integraci√≥n
usando una base de datos `MySQL real` (no embebida como H2).

Este perfil hereda todas las propiedades comunes desde `src/test/resources/application.yml`, sobrescribiendo √∫nicamente
las credenciales y la URL del `datasource` necesarias para conectarse a `MySQL`.

````yml
# src/test/resources/application-test.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3307/db_spring_rest_api_test?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=America/Lima
    username: test_user
    password: test_password
````

#### üß© Propiedades Clave

| Propiedad                      | Descripci√≥n                                                                                                                 |
|--------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| `useSSL=false`                 | En entornos de prueba locales no es necesario establecer conexiones seguras mediante SSL.                                   |
| `allowPublicKeyRetrieval=true` | Permite que el cliente MySQL obtenga la clave p√∫blica del servidor, evitando errores de autenticaci√≥n en algunas versiones. |
| `serverTimezone=America/Lima`  | Evita *warnings* o desajustes horarios al mapear tipos `DATETIME` o `TIMESTAMP`.                                            |

#### üí° Nota T√©cnica

Spring Boot fusionar√° (mergear√°) las propiedades del archivo base `application.yml` con las del perfil activo.
De esta forma, no necesitas repetir configuraciones de JPA, Hibernate, ni par√°metros comunes del datasource.

Por ejemplo, si en `src/test/resources/application.yml` tenemos:

````yml
spring:
  jpa:
    hibernate:
      ddl-auto: create-drop
    properties:
      hibernate:
        format_sql: true
        show_sql: false
````

Entonces estas configuraciones se mantendr√°n activas al ejecutar los tests con el perfil `test`.

## üê¨ Creando contenedor de base de datos MySQL para pruebas

En esta secci√≥n agregamos un nuevo servicio al archivo `compose.yml` que levantar√° un contenedor MySQL dedicado a las
pruebas de integraci√≥n.

Este contenedor ser√° utilizado √∫nicamente por el perfil `test` (definido en `application-test.yml`) para mantener
aislado el entorno de pruebas del entorno de desarrollo o producci√≥n.

````yml
services:
  s-mysql-test:
    image: mysql:8.0.41-debian
    container_name: c-mysql-test
    restart: unless-stopped
    ports:
      - '3307:3306'
    environment:
      MYSQL_ROOT_PASSWORD: magadiflo
      MYSQL_DATABASE: db_spring_rest_api_test
      MYSQL_USER: test_user
      MYSQL_PASSWORD: test_password
    networks:
      - docker-test-net
````

üß© Detalles importantes

- `ports: '3307:3306'` ‚Üí expone el puerto interno `3306` del contenedor en el `3307` de tu m√°quina local para evitar
  conflictos con tu MySQL de desarrollo.
- `MYSQL_DATABASE`, `MYSQL_USER`, `MYSQL_PASSWORD` ‚Üí las credenciales definidas en el archivo `application-test.yml`
  deben coincidir con las configuradas en este servicio del `compose.yml`.
- `restart: unless-stopped` ‚Üí reinicia el contenedor autom√°ticamente a menos que se detenga manualmente.
- `network: docker-test-net` ‚Üí permite que otros contenedores de test se comuniquen f√°cilmente si tuvieras un entorno
  m√°s complejo (por ejemplo, con Grafana, Tempo, etc.).

üí° Nota profesional
> En entornos empresariales, se recomienda `no compartir la base de datos de desarrollo` con las pruebas.
> Tener un contenedor `MySQL` exclusivo para el perfil `test` garantiza un entorno `aislado`, `reproducible` y sin
> efectos colaterales sobre datos reales.

### üê≥ Levantando contenedores

Ejecutamos el siguiente comando para levantar el contenedor correspondiente al perfil `test` definido en nuestro
archivo `compose.yml`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite (feature/spring-rest-api) 
$ docker compose -f ./docker/compose.yml up -d                                                                           
[+] Running 2/2                                                                                                          
 ‚úî Container c-mysql-test  Started                                                                                       
 ‚úî Container c-mysql       Running                                                                                        
````

üí° Aqu√≠ estamos levantando todos los servicios definidos en el archivo `compose.yml`, incluido nuestro contenedor de
pruebas `c-mysql-test`.

Una vez iniciado, verificamos que el contenedor de base de datos para nuestros tests de integraci√≥n se haya creado y
est√© en ejecuci√≥n correctamente:

````bash
docker container ls -a
CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                                         NAMES
d8d12fb0e1bf   mysql:8.0.41-debian   "docker-entrypoint.s‚Ä¶"   55 seconds ago   Up 54 seconds   0.0.0.0:3307->3306/tcp, [::]:3307->3306/tcp   c-mysql-test
d0d5997e6ff1   mysql:8.0.41-debian   "docker-entrypoint.s‚Ä¶"   10 days ago      Up 45 minutes   0.0.0.0:3306->3306/tcp, [::]:3306->3306/tcp   c-mysql 
````

‚úÖ Observa que ahora tenemos dos contenedores activos:

- `c-mysql` ‚Üí utilizado por la aplicaci√≥n principal (`dev` o `prod`).
- `c-mysql-test` ‚Üí utilizado exclusivamente para los tests de integraci√≥n bajo el perfil `test`.

Ahora podemos abrir `DBeaver` (o cualquier cliente SQL de tu preferencia) y verificar que la base de datos
`db_spring_rest_api_test` se haya creado correctamente.

Esto confirma que nuestro contenedor `c-mysql-test` est√° activo y que la base de datos est√° lista para recibir los tests
de integraci√≥n.

![06.png](assets/06.png)

## üß™ Pruebas de Integraci√≥n con `@DataJpaTest` usando `MySQL`

Este test verifica que el perfil de pruebas est√© correctamente conectado a una base de datos `MySQL` real,
en lugar de una base en memoria como `H2`. Para ello, se inspecciona la URL del `DataSource` activo y se valida que
contenga el t√©rmino `mysql`.

````java

@Slf4j
@Tag("integration")
@ActiveProfiles("test")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) // No reemplazar la BD configurada, usar la de application-test.yml
class AccountRepositoryMySQLTest {

    @Autowired
    private AccountRepository accountRepository;

    @Autowired
    private DataSource dataSource;

    @Test
    void shouldUseMySQLDatabase() throws SQLException {
        String url = this.dataSource.getConnection().getMetaData().getURL();
        log.info("Usando base de datos: {}", url);
        assertThat(url).contains("mysql");
    }
}
````

### üß∑ Explicaci√≥n de anotaciones

| Anotaci√≥n                                            | Prop√≥sito                                                               | Comentario t√©cnico                                                   |
|------------------------------------------------------|-------------------------------------------------------------------------|----------------------------------------------------------------------|
| `@Tag("integration")`                                | Clasifica el test como parte del grupo de integraci√≥n                   | √ötil para ejecutar selectivamente con `-Dgroups=integration`         |
| `@ActiveProfiles("test")`                            | Activa el perfil `application-test.yml`                                 | Carga configuraci√≥n espec√≠fica para MySQL en pruebas                 |
| `@Sql(...)`                                          | Ejecuta un script SQL antes de la clase de test                         | Prepara datos iniciales para pruebas reproducibles                   |
| `@DataJpaTest`                                       | Configura un entorno de prueba limitado a JPA                           | Incluye repositorios, EntityManager, y configuraci√≥n de persistencia |
| `@AutoConfigureTestDatabase(replace = Replace.NONE)` | Evita que Spring Boot reemplace el `DataSource` con una base en memoria | Permite usar la base de datos real definida en el perfil activo      |

### üìå Nota t√©cnica

Por defecto, `@DataJpaTest` intenta reemplazar el `DataSource` con una base de datos embebida (como `H2`). Esto es √∫til
para pruebas r√°pidas, pero no refleja el comportamiento real de `MySQL`. Para evitar ese reemplazo, usamos:

````bash
@AutoConfigureTestDatabase(replace = Replace.NONE) 
````

Esto le indica a `Spring Boot` que respete la configuraci√≥n definida en `application-test.yml`, permitiendo conectar a
`MySQL` como se espera.

### üß© Qu√© sucede al ejecutar el test

1. Spring Boot levanta el contexto de prueba con el perfil `test`.
2. Se aplica la configuraci√≥n del archivo `/src/test/resources/application-test.yml`.
3. Gracias a `@AutoConfigureTestDatabase(replace = Replace.NONE)`, no se reemplaza la fuente de datos.
4. El test valida que la conexi√≥n efectivamente apunta a un URL de tipo `mysql://...`

### üìã An√°lisis del Log ‚Äî Perfil test con MySQL

Durante la ejecuci√≥n de la clase de pruebas anterior con el perfil `test` y base de datos `MySQL`, se observa un
comportamiento particular en el log: `Hibernate` intenta eliminar √≠ndices y tablas que a√∫n no existen, lo que genera
algunos warnings iniciales (`WARN`):

````bash
2025-10-20T18:03:22.538-05:00  WARN 18292 --- [spring-rest-api] [           main] o.h.t.s.i.ExceptionHandlerLoggedImpl     : GenerationTarget encountered exception accepting command : Error executing DDL "
    alter table accounts
       drop
       foreign key FKb78evw9x9jyy66ld572kl8rgx" via JDBC [Table 'db_spring_rest_api_test.accounts' doesn't exist]
````

Estos mensajes `no representan un error funcional`, sino el comportamiento esperado cuando usamos:

````yml
spring:
  jpa:
    hibernate:
      ddl-auto: create-drop
````

Al iniciar la aplicaci√≥n, `Hibernate` intenta `eliminar estructuras previas` (√≠ndices, claves for√°neas, tablas)
antes de volver a crearlos. En una base de datos vac√≠a (como la de nuestros tests con `MySQL`), esas tablas a√∫n no
existen, lo que provoca el `warning` ‚Äîpero el proceso contin√∫a normalmente y el test se ejecuta sin problemas.

En la siguiente parte del log puede verse c√≥mo Hibernate `recrea el esquema correctamente`:

````bash
create table accounts (...)
create table banks (...)
alter table accounts add constraint ... 
````

y finalmente:

````bash
2025-10-20T18:03:24.872-05:00  INFO 18292 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryMySQLTest     : Usando base de datos: jdbc:mysql://localhost:3307/db_spring_rest_api_test?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=America/Lima
[INFO] BUILD SUCCESS
````

#### üß™ Diferencia con H2

> Este comportamiento no ocurre con `H2` porque, `H2` es una base en memoria que `se crea desde cero` en cada
> ejecuci√≥n.,
> `Hibernate` no encuentra estructuras previas que eliminar; por lo tanto, no intenta lanzar los `ALTER/DROP` iniciales.

#### ‚ö†Ô∏è Advertencia esperada en MySQL

> Al usar `ddl-auto: create-drop` con `MySQL`, es normal que Hibernate intente eliminar estructuras que a√∫n no existen.
> Esto genera advertencias en el log, pero no afecta la ejecuci√≥n de los tests. Con H2, este comportamiento no ocurre
> porque la base se crea limpia en cada ejecuci√≥n.

A continuaci√≥n se muestra el log completo al ejecutar nuestra clase de test `AccountRepositoryMySQLTest`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api (feature/spring-rest-api)
$ mvn test -Dgroups=integration
[INFO] Scanning for projects...
...
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running dev.magadiflo.app.integration.repository.AccountRepositoryMySQLTest
2025-10-20T18:03:19.293-05:00  INFO 18292 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryMySQLTest     : Starting AccountRepositoryMySQLTest using Java 21.0.6 with PID 18292 (started by magadiflo in D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api)
2025-10-20T18:03:19.294-05:00 DEBUG 18292 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryMySQLTest     : Running with Spring Boot v3.5.6, Spring v6.2.11
2025-10-20T18:03:19.295-05:00  INFO 18292 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryMySQLTest     : The following 1 profile is active: "test"
2025-10-20T18:03:19.715-05:00  INFO 18292 --- [spring-rest-api] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-10-20T18:03:19.811-05:00  INFO 18292 --- [spring-rest-api] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 83 ms. Found 2 JPA repository interfaces.
2025-10-20T18:03:20.079-05:00  INFO 18292 --- [spring-rest-api] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-10-20T18:03:20.134-05:00  INFO 18292 --- [spring-rest-api] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.29.Final
2025-10-20T18:03:20.161-05:00  INFO 18292 --- [spring-rest-api] [           main] o.h.c.internal.RegionFactoryInitiator    : HHH000026: Second-level cache disabled
2025-10-20T18:03:20.482-05:00  INFO 18292 --- [spring-rest-api] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-10-20T18:03:20.522-05:00  INFO 18292 --- [spring-rest-api] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-10-20T18:03:20.778-05:00  INFO 18292 --- [spring-rest-api] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@7871d261
...
2025-10-20T18:03:21.663-05:00  INFO 18292 --- [spring-rest-api] [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-10-20T18:03:21.674-05:00 DEBUG 18292 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    alter table accounts
       drop
       foreign key FKb78evw9x9jyy66ld572kl8rgx
2025-10-20T18:03:22.538-05:00  WARN 18292 --- [spring-rest-api] [           main] o.h.t.s.i.ExceptionHandlerLoggedImpl     : GenerationTarget encountered exception accepting command : Error executing DDL "
    alter table accounts
       drop
       foreign key FKb78evw9x9jyy66ld572kl8rgx" via JDBC [Table 'db_spring_rest_api_test.accounts' doesn't exist]
org.hibernate.tool.schema.spi.CommandAcceptanceException: Error executing DDL "
    alter table accounts
       drop
       foreign key FKb78evw9x9jyy66ld572kl8rgx" via JDBC [Table 'db_spring_rest_api_test.accounts' doesn't exist]
        at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.accept(GenerationTargetToDatabase.java:94) ~[hibernate-core-6.6.29.Final.jar:6.6.29.Final]
        ...
Caused by: java.sql.SQLSyntaxErrorException: Table 'db_spring_rest_api_test.accounts' doesn't exist
        ... 101 common frames omitted

2025-10-20T18:03:22.546-05:00 DEBUG 18292 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    drop table if exists accounts
2025-10-20T18:03:22.558-05:00 DEBUG 18292 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    drop table if exists banks
2025-10-20T18:03:22.569-05:00 DEBUG 18292 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    create table accounts (
        balance decimal(19,2) not null,
        bank_id bigint,
        id bigint not null auto_increment,
        holder varchar(100) not null,
        primary key (id)
    ) engine=InnoDB
2025-10-20T18:03:22.616-05:00 DEBUG 18292 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    create table banks (
        total_transfers integer not null,
        id bigint not null auto_increment,
        name varchar(100) not null,
        primary key (id)
    ) engine=InnoDB
2025-10-20T18:03:22.661-05:00 DEBUG 18292 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    alter table banks
       add constraint UKgfnfs2s5a771weqm28yvb2h5 unique (name)
2025-10-20T18:03:22.717-05:00 DEBUG 18292 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    alter table accounts
       add constraint FKb78evw9x9jyy66ld572kl8rgx
       foreign key (bank_id)
       references banks (id)
...
2025-10-20T18:03:24.872-05:00  INFO 18292 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryMySQLTest     : Usando base de datos: jdbc:mysql://localhost:3307/db_spring_rest_api_test?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=America/Lima
...
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.420 s -- in dev.magadiflo.app.integration.repository.AccountRepositoryMySQLTest
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  9.293 s
[INFO] Finished at: 2025-10-20T18:03:25-05:00
[INFO] ------------------------------------------------------------------------
````

### üß© Pruebas de integraci√≥n con @DataJpaTest y MySQL

A continuaci√≥n se muestran todos los tests definidos en la clase `AccountRepositoryMySQLTest`. Estos m√©todos son los
mismos que se implementaron previamente en la clase `AccountRepositoryH2Test`; la √∫nica diferencia radica en el
`datasource`: aqu√≠ utilizamos una base de datos `MySQL` real en lugar de la base en memoria `H2`.

````java

@Slf4j
@Tag("integration")
@ActiveProfiles("test")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) // No reemplazar la BD configurada, usar la de application-test.yml
class AccountRepositoryMySQLTest {

    @Autowired
    private AccountRepository accountRepository;

    @Autowired
    private DataSource dataSource;

    @Test
    void shouldUseMySQLDatabase() throws SQLException {
        String url = this.dataSource.getConnection().getMetaData().getURL();
        log.info("Usando base de datos: {}", url);
        assertThat(url).contains("mysql");
    }

    @Test
    void shouldReturnAllAccountsWhenDatabaseIsInitialized() {
        // when
        List<AccountResponse> accounts = this.accountRepository.getAllAccounts();

        // then
        assertThat(accounts)
                .isNotEmpty()
                .hasSize(8)
                .extracting(AccountResponse::holder)
                .contains("Lesly √Åguila", "Briela Cirilo", "Milagros D√≠az");
    }

    @Test
    void shouldHaveAssociatedBankForAllAccountsWhenFetchingAccounts() {/**/}

    @Test
    void shouldReturnAccountWithBankWhenFindByIdExists() {/**/}

    @Test
    void shouldReturnEmptyOptionalWhenAccountIdDoesNotExist() {/**/}

    @Test
    void shouldSaveAccountWhenValidDataProvided() {/**/}

    @Test
    void shouldDeleteAccountWhenExistingIdProvided() {/**/}

    @Test
    void shouldUpdateAccountWhenExistingIdProvided() {/**/}
}
````

### üß© Ejecutando pruebas de integraci√≥n con @DataJpaTest y MySQL

Para ejecutar las pruebas de integraci√≥n que utilizan una base de datos real (`MySQL`) en lugar de una base de datos
en memoria, podemos hacerlo directamente desde `Maven` mediante el siguiente comando: `mvn test`, o bien desde nuestro
`IntelliJ IDEA`, ejecutando la clase o el paquete de pruebas correspondiente.

La bandera `-Dgroups=integration` nos permite ejecutar √∫nicamente los tests marcados con `@Tag("integration")`.

Durante la ejecuci√≥n, `Spring Boot` inicia el contexto de prueba con el perfil activo `test`, el cual est√° configurado
para conectarse a `MySQL` en el archivo `application-test.yml`.

En el siguiente log se puede observar la secuencia normal del arranque de la aplicaci√≥n de prueba:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api (feature/spring-rest-api)
$ mvn test -Dgroups=integration
...
2025-10-21T11:07:23.112-05:00  INFO 11676 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryMySQLTest     : Starting AccountRepositoryMySQLTest using Java 21.0.6 with PID 11676 (started by magadiflo in D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api)
2025-10-21T11:07:23.114-05:00 DEBUG 11676 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryMySQLTest     : Running with Spring Boot v3.5.6, Spring v6.2.11
2025-10-21T11:07:23.114-05:00  INFO 11676 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryMySQLTest     : The following 1 profile is active: "test"
2025-10-21T11:07:23.577-05:00  INFO 11676 --- [spring-rest-api] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-10-21T11:07:23.682-05:00  INFO 11676 --- [spring-rest-api] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 85 ms. Found 2 JPA repository interfaces.
2025-10-21T11:07:23.983-05:00  INFO 11676 --- [spring-rest-api] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-10-21T11:07:24.034-05:00  INFO 11676 --- [spring-rest-api] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.29.Final
2025-10-21T11:07:24.063-05:00  INFO 11676 --- [spring-rest-api] [           main] o.h.c.internal.RegionFactoryInitiator    : HHH000026: Second-level cache disabled
2025-10-21T11:07:24.503-05:00  INFO 11676 --- [spring-rest-api] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-10-21T11:07:24.535-05:00  INFO 11676 --- [spring-rest-api] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-10-21T11:07:24.749-05:00  INFO 11676 --- [spring-rest-api] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@4438938e
2025-10-21T11:07:24.751-05:00  INFO 11676 --- [spring-rest-api] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
...
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.160 s -- in dev.magadiflo.app.integration.repository.AccountRepositoryMySQLTest
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  9.763 s
[INFO] Finished at: 2025-10-21T11:07:28-05:00
[INFO] ------------------------------------------------------------------------ 
````

#### ‚úÖ Conclusi√≥n

Las pruebas de integraci√≥n con `MySQL` se ejecutaron correctamente utilizando la configuraci√≥n del perfil `test`.
El uso de la anotaci√≥n `@AutoConfigureTestDatabase(replace = Replace.NONE)` garantiza que `Spring Boot` no reemplace
el `DataSource` definido en `application-test.yml`, permitiendo conectar los tests a la base de datos real configurada.

> üí° `Nota`: Durante el arranque inicial pueden aparecer mensajes de advertencia o errores leves de `Hibernate`
> indicando que no existen ciertas tablas o √≠ndices al intentar eliminarlos.
>
> Esto es normal cuando se usa `spring.jpa.hibernate.ddl-auto=create-drop`, ya que `Hibernate` intenta limpiar la base
> de datos antes de recrear el esquema desde cero. En bases en memoria como `H2` este proceso ocurre sin advertencias
> visibles, pero en `MySQL` s√≠ pueden mostrarse estos mensajes antes de que el contexto se inicialice correctamente.

---

# üöÄ Integration Test - Test de Controladores (`@SpringBootTest`)

---

En esta secci√≥n abordamos pruebas de integraci√≥n para nuestros controladores REST, utilizando herramientas como
`WebTestClient`, `TestRestTemplate` y `MockMvc`. Estas pruebas permiten validar el comportamiento real de los
endpoints HTTP, incluyendo el mapeo de rutas, serializaci√≥n, respuestas, y manejo de errores.

## üß™ Pruebas de integraci√≥n con `WebTestClient`

`WebTestClient` es un cliente HTTP dise√±ado especialmente para `probar aplicaciones de servidor`. Internamente,
`envuelve el WebClient de Spring`, pero expone una `fachada de prueba` que facilita la verificaci√≥n de respuestas
y comportamientos en las llamadas HTTP.

Este cliente puede utilizarse tanto para:

- Pruebas de `extremo a extremo` sobre un servidor real en ejecuci√≥n.
- Pruebas `sin servidor` (mockeando solicitudes y respuestas), ya sea en aplicaciones `Spring MVC` o `Spring WebFlux`.

### üì¶ Dependencia necesaria

Para usar `WebTestClient` en nuestras pruebas de integraci√≥n, debemos agregar la siguiente dependencia en el `pom.xml`:

````xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
    <scope>test</scope>
</dependency>
````

üí° Nota t√©cnica:

- El `scope` se declara como `test`, ya que `solo utilizaremos esta dependencia durante las pruebas`, no en la
  aplicaci√≥n principal.
- Aunque `WebFlux` es un stack reactivo, esta dependencia no convierte tu aplicaci√≥n en reactiva. Solo habilita el
  cliente de pruebas.
- Aunque `WebTestClient` fue dise√±ado para entornos `reactivos` (`WebFlux`), tambi√©n puede utilizarse con
  `Spring MVC` para probar controladores de aplicaciones bloqueantes.

### ‚öôÔ∏è Configuraci√≥n de la prueba de integraci√≥n

Este test valida el comportamiento real de los endpoints HTTP definidos en el controlador `AccountController`,
utilizando `WebTestClient` y un servidor embebido iniciado en un puerto aleatorio. Se ejecuta sobre el contexto
completo de Spring Boot, con datos precargados y limpieza previa de la base de datos.

````java

@Tag("integration2")
@ActiveProfiles("test")
@Sql(scripts = {TestScripts.CLEANUP_MYSQL, TestScripts.DATA_TEST}, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class AccountControllerWebTestClientTest {

    @Autowired
    private WebTestClient client;

    /* Aqu√≠ ir√≠an los test */
}
````

#### üß∑ Explicaci√≥n de anotaciones

| Anotaci√≥n                      | Prop√≥sito                                             | Comentario t√©cnico                                                                                          |
|:-------------------------------|-------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| `@Tag("integration2")`         | Clasifica el test como parte del grupo `integration2` | Permite ejecutar selectivamente con `-Dgroups=integration2`                                                 |
| `@ActiveProfiles("test")`      | Activa el perfil `application-test.yml`               | Carga configuraci√≥n espec√≠fica para MySQL en pruebas                                                        |
| `@Sql(...BEFORE_TEST_METHOD)`  | Ejecuta scripts SQL antes de cada m√©todo de test      | Limpia y precarga datos para garantizar consistencia. Correcto para `@SpringBootTest` (no es transaccional) |
| `CLEANUP_MYSQL + DATA_TEST`    | Scripts SQL que limpia tablas e inserta datos         | Limpia y carga datos antes de cada test                                                                     |
| `@SpringBootTest(...)`         | Levanta el contexto completo de Spring Boot           | Permite inyecci√≥n de dependencias y pruebas de integraci√≥n reales                                           |
| `webEnvironment = RANDOM_PORT` | Inicia un servidor embebido en un puerto aleatorio    | Simula un entorno web real para pruebas HTTP con `WebTestClient`                                            |

#### üîπ `@SpringBootTest`

Esta anotaci√≥n indica que la clase se ejecutar√° como una prueba de integraci√≥n completa. `Spring Boot` levantar√° el
`contexto de aplicaci√≥n real`, incluyendo todos los beans, configuraciones y dependencias necesarias.

> üí° `Nota`: Esto permite usar `@Autowired` para inyectar componentes como `WebTestClient`, servicios o repositorios,
> de la misma forma que en la aplicaci√≥n en ejecuci√≥n.

#### üîπ `webEnvironment en @SpringBootTest`

Por defecto, `@SpringBootTest` **no inicia un servidor web**. El atributo `webEnvironment` define c√≥mo se cargar√° el
entorno web durante las pruebas.

Sus valores posibles son:

| Valor                  | Descripci√≥n                                                                                                                                                                                               |
|:-----------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `MOCK` *(por defecto)* | Carga un `WebApplicationContext` simulado. No inicia un servidor embebido; ideal para pruebas con `MockMvc`.                                                                                              |
| `RANDOM_PORT`          | Inicia un `servidor embebido real` (por ejemplo, Tomcat o Jetty) y escucha en un `puerto aleatorio`. Este modo es el adecuado para pruebas de integraci√≥n reales con `WebTestClient` o `TestRestTemplate` |
| `DEFINED_PORT`         | Similar a `RANDOM_PORT`, pero usa el puerto definido en `application.yml`. √ötil si se necesita un puerto fijo.                                                                                            |
| `NONE`                 | Carga un `ApplicationContext` sin entorno web (√∫til para pruebas puramente de l√≥gica o servicios). √ötil para pruebas de l√≥gica sin web (servicios, repositorios, etc.).                                   |

#### ‚öôÔ∏è Explicaci√≥n t√©cnica:

Con `RANDOM_PORT`, Spring Boot lanza la aplicaci√≥n completa en un servidor embebido temporal, de modo que las pruebas
pueden realizar `peticiones HTTP reales` contra endpoints REST usando `WebTestClient`.

### ‚ö†Ô∏è ¬øQu√© ocurre si usamos `@SpringBootTest` sin definir `webEnvironment`?

Cuando se usa la anotaci√≥n `@SpringBootTest` sin ning√∫n atributo adicional:

````java

@SpringBootTest
class AccountControllerWebTestClientTest {
    /* code */
}
````

`Spring Boot` aplica por defecto el modo:

````java

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
class AccountControllerWebTestClientTest {
    /* code */
}
````

Esto significa:

- Se carga un `contexto web simulado` (`MockServletContext`), sin levantar un servidor embebido.
- Es compatible con herramientas como `MockMvc`, que operan sobre el stack MVC simulado.
- `No se crea un WebTestClient autoconfigurado`, ya que este requiere un entorno web real.

#### üí• Error t√≠pico al usar `WebTestClient` sin `RANDOM_PORT`

En este entorno `no existe ning√∫n bean de tipo` `WebTestClient` disponible para inyecci√≥n, ya que el servidor web no
est√° corriendo. Por eso, al ejecutar la prueba, aparece un error como este:

````bash
org.springframework.beans.factory.UnsatisfiedDependencyException: 
Error creating bean with name 'dev.magadiflo.app.integration.controller.AccountControllerWebTestClientTest': 
Unsatisfied dependency expressed through field 'client': 
No qualifying bean of type 'org.springframework.test.web.reactive.server.WebTestClient' available: 
expected at least 1 bean which qualifies as autowire candidate.
````

`Spring Boot` no puede crear ni inyectar el `WebTestClient`, porque este cliente solo se puede asociar a:

- Un servidor embebido en ejecuci√≥n (`RANDOM_PORT` o `DEFINED_PORT`), o
- Un contexto de aplicaci√≥n `Reactivo WebFlux` (en cuyo caso se crea manualmente).

### üåê Pruebas de integraci√≥n reales con `webEnvironment = RANDOM_PORT`

Para que las `pruebas de integraci√≥n` funcionen correctamente con clientes HTTP como `WebTestClient` o
`TestRestTemplate`, debemos usar un `entorno web real`. La configuraci√≥n recomendada es:

````java

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class AccountControllerWebTestClientTest {
    /* code */
}
````

Esto arranca el servidor embebido en un puerto aleatorio, lo que permite que tanto `WebTestClient` como
`TestRestTemplate` se `autoconfiguren e inyecten autom√°ticamente` en el contexto de pruebas.

> üí° `Nota`: Ambos clientes realizan peticiones HTTP reales al servidor iniciado dentro del entorno de prueba,
> lo que los convierte en herramientas ideales para pruebas de integraci√≥n de controladores REST.

### üß© Implementaci√≥n de la prueba de integraci√≥n del AccountController con WebTestClient

En esta prueba se valida el comportamiento real del controlador `AccountController`, interactuando con un servidor
embebido iniciado en un puerto aleatorio y una base de datos MySQL real.

Gracias al uso de `@SpringBootTest` con `webEnvironment = RANDOM_PORT`, las pruebas utilizan un entorno web real,
ideal para escenarios de integraci√≥n.

#### üí° Nota importante sobre el uso de `@Sql` y limpieza de la base de datos

En esta prueba usamos la anotaci√≥n `@Sql` con la configuraci√≥n:

````java

@Sql(scripts = {TestScripts.CLEANUP_MYSQL, TestScripts.DATA_TEST}, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
class AccountControllerWebTestClientTest {
    /* code */
}
````

Esto significa que `antes de cada m√©todo de prueba` se ejecutan los scripts SQL definidos, limpiando las tablas y
cargando datos iniciales.

#### ‚öôÔ∏è Explicaci√≥n t√©cnica:

La anotaci√≥n `@SpringBootTest` `no ejecuta los m√©todos de prueba dentro de una transacci√≥n`
(a diferencia de `@DataJpaTest`, que s√≠ lo hace). Por esa raz√≥n, los cambios realizados en la base de datos durante un
test no se revierten autom√°ticamente al finalizar.

Al usar `executionPhase = BEFORE_TEST_METHOD`, garantizamos que
`cada prueba inicie con una base de datos limpia y consistente`, aislando completamente los resultados de cada caso de
prueba.

> üí° De haberse usado `BEFORE_TEST_CLASS`, los scripts se ejecutar√≠an una sola vez antes de toda la clase,
> lo que podr√≠a provocar inconsistencias si un test modifica los datos que otro test espera.

#### üìå Nota t√©cnica

`WebTestClient` permite realizar pruebas HTTP reales sin necesidad de levantar manualmente el servidor. Al usar
`RANDOM_PORT`, Spring Boot inicia un servidor embebido en un puerto libre, y `WebTestClient` se autoconecta a ese
entorno para simular el comportamiento de producci√≥n.

````java

@Slf4j
@Tag("integration2")
@ActiveProfiles("test")
@Sql(scripts = {TestScripts.CLEANUP_MYSQL, TestScripts.DATA_TEST}, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class AccountControllerWebTestClientTest {

    @Autowired
    private WebTestClient client;

    @Autowired
    private DataSource dataSource;

    @Test
    void shouldUseMySQLDatabase() throws SQLException {
        String url = this.dataSource.getConnection().getMetaData().getURL();
        log.info("Usando base de datos: {}", url);
        assertThat(url).contains("mysql", "db_spring_rest_api_test");
    }

    @Test
    void shouldTransferMoneySuccessfully() {
        // given
        var request = new TransactionRequest(1L, 2L, new BigDecimal("2999"));

        // when
        WebTestClient.ResponseSpec response = this.client
                .post()
                .uri("/api/v1/accounts/transfer")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(request)
                .exchange();

        // then
        response.expectStatus().isNoContent()
                .expectBody().isEmpty();
    }

    @Test
    void shouldReturnAllAccountsWhenTheyExist() {
        // given

        // when
        WebTestClient.ResponseSpec response = this.client
                .get()
                .uri("/api/v1/accounts")
                .exchange();

        // then
        response.expectStatus().isOk()
                .expectHeader().contentType(MediaType.APPLICATION_JSON)
                .expectBodyList(AccountResponse.class)
                .consumeWith(result -> {
                    List<AccountResponse> accountResponseList = result.getResponseBody();
                    assertThat(accountResponseList)
                            .hasSize(8)
                            .extracting(AccountResponse::holder)
                            .containsExactlyInAnyOrder(
                                    "Lesly √Åguila",
                                    "Cielo Fern√°ndez",
                                    "Susana Alvarado",
                                    "Briela Cirilo",
                                    "Milagros D√≠az",
                                    "Kiara Lozano",
                                    "Analuc√≠a Urbina",
                                    "Yrma Guerrero");
                    assertThat(accountResponseList.stream().filter(a -> a.id().equals(1L)).findFirst())
                            .isPresent()
                            .hasValueSatisfying(accountResponse -> {
                                assertThat(accountResponse.holder()).isEqualTo("Lesly √Åguila");
                                assertThat(accountResponse.balance()).isEqualByComparingTo("3000");
                                assertThat(accountResponse.bankName()).isEqualTo("BCP");
                            });
                });
    }

    @Test
    void shouldCreateNewAccountSuccessfully() {
        // given
        AccountCreateRequest request = new AccountCreateRequest("Milagros", new BigDecimal("2000"), 1L);

        // when
        WebTestClient.ResponseSpec response = this.client
                .post()
                .uri("/api/v1/accounts")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(request)
                .exchange();

        // then
        response.expectStatus().isCreated()
                .expectHeader().contentType(MediaType.APPLICATION_JSON)
                .expectHeader().exists("Location")
                .expectHeader().valueMatches("Location", "http://localhost:\\d+/api/v1/accounts/\\d+")
                .expectBody(AccountResponse.class)
                .consumeWith(result -> {
                    AccountResponse accountResponse = result.getResponseBody();
                    assertThat(accountResponse)
                            .isNotNull()
                            .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                            .containsExactly(9L, request.holder(), request.balance(), "BCP");
                });
    }

    @Test
    void shouldReturnAccountDetailsWhenAccountExists() {
        // given
        long accountId = 5L;

        // when
        WebTestClient.ResponseSpec response = this.client
                .get()
                .uri("/api/v1/accounts/{accountId}", accountId)
                .exchange();

        // then
        response.expectStatus().isOk()
                .expectHeader().contentType(MediaType.APPLICATION_JSON)
                .expectBody()
                .jsonPath("$.id").isEqualTo(5L)
                .jsonPath("$.holder").isEqualTo("Milagros D√≠az")
                .jsonPath("$.balance").isEqualTo(3500)
                .jsonPath("$.bankName").isEqualTo("Interbank");
    }

    @Test
    void shouldReturn404WhenAccountNotFound() {
        // given
        long accountId = 10L;

        // when
        WebTestClient.ResponseSpec response = this.client
                .get()
                .uri("/api/v1/accounts/{accountId}", accountId)
                .exchange();

        // then
        response.expectStatus().isNotFound()
                .expectHeader().contentType(MediaType.APPLICATION_JSON)
                .expectBody()
                .jsonPath("$.timestamp").exists()
                .jsonPath("$.status").isEqualTo(404)
                .jsonPath("$.error").isEqualTo("Not Found")
                .jsonPath("$.message").isEqualTo("No se encontr√≥ la cuenta con ID: " + accountId)
                .jsonPath("$.path").isEqualTo("/api/v1/accounts/" + accountId);
    }

    @Test
    void shouldReturn400WhenBalanceIsInsufficient() {
        // given
        var request = new TransactionRequest(1L, 2L, new BigDecimal("5000"));

        // when
        WebTestClient.ResponseSpec response = this.client
                .post()
                .uri("/api/v1/accounts/transfer")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(request)
                .exchange();

        // then
        response.expectStatus().isBadRequest()
                .expectHeader().contentType(MediaType.APPLICATION_JSON)
                .expectBody()
                .jsonPath("$.timestamp").exists()
                .jsonPath("$.status").isEqualTo(400)
                .jsonPath("$.error").isEqualTo("Bad Request")
                .jsonPath("$.message").isEqualTo("Saldo insuficiente en la cuenta del titular Lesly √Åguila (ID: 1)")
                .jsonPath("$.path").isEqualTo("/api/v1/accounts/transfer");
    }
}
````

## üß™ Pruebas de integraci√≥n con `TestRestTemplate`

En esta secci√≥n realizaremos pruebas de integraci√≥n del controlador `AccountController`, pero en lugar de usar
`WebTestClient`, utilizaremos el cliente HTTP `TestRestTemplate`. La configuraci√≥n general de la clase de prueba
ser√° muy similar a la empleada en `AccountControllerWebTestClientTest`, con la diferencia principal en el tipo de
cliente que inyectaremos.

### üåê ¬øQu√© es TestRestTemplate?

`TestRestTemplate` es una alternativa especializada de `RestTemplate` dise√±ada para pruebas de integraci√≥n.
A diferencia de `RestTemplate`, est√° preparada para:

- Ser `tolerante a errores`: no lanza excepciones ante respuestas `4xx` o `5xx`, lo que permite inspeccionar
  directamente el `ResponseEntity`.
- Ser `m√°s segura para pruebas`: no sigue redirecciones ni almacena cookies por defecto.
- Ser `autoconfigurable`: si se usa `@SpringBootTest` con un servidor embebido (`RANDOM_PORT` o `DEFINED_PORT`),
  Spring Boot inyecta autom√°ticamente una instancia lista para usar.

### üìå Nota t√©cnica

- `TestRestTemplate` no extiende `RestTemplate` directamente para evitar conflictos de inyecci√≥n. Si necesitamos acceder
  al cliente subyacente, podemos usar `getRestTemplate()`.
- Cuando utilizamos `@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)` o `DEFINED_PORT`, Spring Boot
  crea autom√°ticamente un `TestRestTemplate` preconfigurado que podemos inyectar con `@Autowired`. Esto no ocurre si
  el entorno es `MOCK`, ya que en ese caso el servidor embebido no se levanta y no habr√≠a ning√∫n endpoint real al cual
  hacer peticiones HTTP.

### üì¶ Dependencia

No necesitamos agregar ninguna dependencia adicional si ya usamos `spring-boot-starter-test`, ya que
`TestRestTemplate` viene incluido.

### ‚öôÔ∏è Configuraci√≥n inicial de la clase de prueba

La siguiente clase configura la base para nuestras pruebas. Usamos el mismo esquema que en las pruebas anteriores,
manteniendo el perfil `test`, la carga de datos controlada con `@Sql`, y el entorno web aleatorio para evitar
conflictos de puerto.

````java

@Slf4j
@Tag("integration3")
@ActiveProfiles("test")
@Sql(scripts = {TestScripts.CLEANUP_MYSQL, TestScripts.DATA_TEST}, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class AccountControllerTestRestTemplateTest {

    @Autowired
    private TestRestTemplate client;

    @Autowired
    private DataSource dataSource;

    @Test
    void shouldUseMySQLDatabase() throws SQLException {
        String url = this.dataSource.getConnection().getMetaData().getURL();
        log.info("Usando base de datos: {}", url);
        assertThat(url).contains("mysql", "db_spring_rest_api_test");
    }
}
````

üí° `Nota`
> Usamos `Sql.ExecutionPhase.BEFORE_TEST_METHOD` porque, a diferencia de las pruebas unitarias con `@DataJpaTest`,
> `@SpringBootTest` no ejecuta cada m√©todo dentro de una transacci√≥n revertible. Esto significa que los cambios en la
> base de datos persisten entre pruebas, por lo que necesitamos limpiar y precargar los datos antes de cada m√©todo.

### üß© Implementaci√≥n de la prueba de integraci√≥n del AccountController con TestRestTemplate

Esta clase replica los mismos casos de prueba que la versi√≥n con `WebTestClient`, pero utilizando `TestRestTemplate`,
un cliente HTTP bloqueante ideal para pruebas de integraci√≥n en aplicaciones `Spring MVC`.

````java

@Slf4j
@Tag("integration3")
@ActiveProfiles("test")
@Sql(scripts = {TestScripts.CLEANUP_MYSQL, TestScripts.DATA_TEST}, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class AccountControllerTestRestTemplateTest {

    @Autowired
    private TestRestTemplate client;

    @Autowired
    private DataSource dataSource;

    @Test
    void shouldUseMySQLDatabase() throws SQLException {
        String url = this.dataSource.getConnection().getMetaData().getURL();
        log.info("Usando base de datos: {}", url);
        assertThat(url).contains("mysql", "db_spring_rest_api_test");
    }

    @Test
    void shouldTransferMoneySuccessfully() {
        // given
        var request = new TransactionRequest(1L, 2L, new BigDecimal("2999"));

        // when
        ResponseEntity<Void> response = this.client.postForEntity("/api/v1/accounts/transfer", request, Void.class);

        // then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);
        assertThat(response.getBody()).isNull();
    }

    @Test
    void shouldReturnAllAccountsWhenTheyExist() {
        // given

        // when
        ResponseEntity<AccountResponse[]> response = this.client.getForEntity("/api/v1/accounts", AccountResponse[].class);

        // then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getHeaders().getContentType()).isEqualTo(MediaType.APPLICATION_JSON);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody()).hasSize(8);
        assertThatList(List.of(response.getBody()))
                .hasSize(8)
                .extracting(AccountResponse::holder)
                .containsExactlyInAnyOrder(
                        "Lesly √Åguila",
                        "Cielo Fern√°ndez",
                        "Susana Alvarado",
                        "Briela Cirilo",
                        "Milagros D√≠az",
                        "Kiara Lozano",
                        "Analuc√≠a Urbina",
                        "Yrma Guerrero");
        assertThat(Stream.of(response.getBody()).filter(a -> a.id().equals(1L)).findFirst())
                .isPresent()
                .hasValueSatisfying(accountResponse -> {
                    assertThat(accountResponse.holder()).isEqualTo("Lesly √Åguila");
                    assertThat(accountResponse.balance()).isEqualByComparingTo("3000");
                    assertThat(accountResponse.bankName()).isEqualTo("BCP");
                });
    }

    @Test
    void shouldCreateNewAccountSuccessfully() {
        // given
        AccountCreateRequest request = new AccountCreateRequest("Milagros", new BigDecimal("2000"), 1L);

        // when
        ResponseEntity<AccountResponse> response = this.client.postForEntity("/api/v1/accounts", request, AccountResponse.class);

        // then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getHeaders().getContentType()).isEqualTo(MediaType.APPLICATION_JSON);
        assertThat(response.getHeaders().getLocation())
                .isNotNull()
                .asString()
                .matches("http://localhost:\\d+/api/v1/accounts/\\d+");

        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody())
                .isNotNull()
                .extracting(AccountResponse::id, AccountResponse::holder, AccountResponse::balance, AccountResponse::bankName)
                .containsExactly(9L, request.holder(), request.balance(), "BCP");
    }

    @Test
    void shouldReturnAccountDetailsWhenAccountExists() {
        // given
        long accountId = 5L;

        // when
        ResponseEntity<AccountResponse> response = this.client.getForEntity("/api/v1/accounts/{accountId}", AccountResponse.class, accountId);

        // then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getHeaders().getContentType()).isEqualTo(MediaType.APPLICATION_JSON);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(accountResponse -> {
                    assertThat(accountResponse.id()).isEqualTo(5);
                    assertThat(accountResponse.holder()).isEqualTo("Milagros D√≠az");
                    assertThat(accountResponse.balance()).isEqualByComparingTo("3500");
                    assertThat(accountResponse.bankName()).isEqualTo("Interbank");
                });
    }

    @Test
    void shouldReturn404WhenAccountNotFound() {
        // given
        long accountId = 10L;

        // when
        ResponseEntity<ErrorResponse> response = this.client.getForEntity("/api/v1/accounts/{accountId}", ErrorResponse.class, accountId);

        // then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        assertThat(response.getHeaders().getContentType()).isEqualTo(MediaType.APPLICATION_JSON);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(errorResponse -> {
                    assertThat(errorResponse.timestamp()).isNotNull();
                    assertThat(errorResponse.status()).isEqualTo(404);
                    assertThat(errorResponse.error()).isEqualTo("Not Found");
                    assertThat(errorResponse.message()).isEqualTo("No se encontr√≥ la cuenta con ID: " + accountId);
                    assertThat(errorResponse.path()).isEqualTo("/api/v1/accounts/" + accountId);
                });
    }

    @Test
    void shouldReturn400WhenBalanceIsInsufficient() {
        // given
        var request = new TransactionRequest(1L, 2L, new BigDecimal("5000"));

        // when
        ResponseEntity<ErrorResponse> response = this.client.postForEntity("/api/v1/accounts/transfer", request, ErrorResponse.class);

        // then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        assertThat(response.getHeaders().getContentType()).isEqualTo(MediaType.APPLICATION_JSON);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(errorResponse -> {
                    assertThat(errorResponse.timestamp()).isNotNull();
                    assertThat(errorResponse.status()).isEqualTo(400);
                    assertThat(errorResponse.error()).isEqualTo("Bad Request");
                    assertThat(errorResponse.message()).isEqualTo("Saldo insuficiente en la cuenta del titular Lesly √Åguila (ID: 1)");
                    assertThat(errorResponse.path()).isEqualTo("/api/v1/accounts/transfer");
                });
    }
}
````
