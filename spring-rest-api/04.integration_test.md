# Integration Test - Test de Repositorios (`@DataJpaTest`)

---

Los `tests de integraci√≥n` validan que los distintos componentes de la aplicaci√≥n (repositorios, servicios,
controladores, etc.) `interact√∫en correctamente entre s√≠` y con dependencias externas como `bases de datos`,
`colas de mensajes` o `servicios HTTP`.

En este caso, probaremos la integraci√≥n entre `Spring Data JPA` y una base de datos, usando primero `H2`
(`en memoria`) y m√°s adelante `MySQL`, para simular entornos m√°s realistas.

## ‚öôÔ∏è Configurar H2 como base de datos en memoria

En el proyecto `spring-rest-api`, agregamos la dependencia de `H2` en el `pom.xml` con el scope limitado a `test`.

### üì¶ Motivo

Usamos `H2` para ejecutar pruebas r√°pidas en memoria sin depender de una base real. M√°s adelante, reemplazaremos
esta configuraci√≥n por `MySQL` o `Testcontainers`, pero `H2` nos permite practicar el flujo de integraci√≥n sin
sobrecargar el entorno.

````xml

<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope> <!-- Importante: solo se usar√° durante los tests -->
</dependency>
````

üí° Nota profesional:
> Aunque `H2` es muy √∫til en fases iniciales, `no siempre refleja el comportamiento real` de `MySQL` o `PostgreSQL`,
> por lo que en entornos reales se recomienda pasar pronto a `Testcontainers` o bases de datos reales en `Docker`.

### üß± Perfiles para pruebas

En lecciones anteriores definimos un `application.yml` dentro de `/src/test/resources` para aislar la configuraci√≥n
de pruebas del entorno principal (`/src/main/resources`).

Ahora organizaremos nuestros archivos de configuraci√≥n de la siguiente manera:

üìÅ Estructura recomendada

````
src/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ       ‚îú‚îÄ‚îÄ application.yml
‚îÇ       ‚îú‚îÄ‚îÄ application-dev.yml
‚îÇ       ‚îú‚îÄ‚îÄ application-qa.yml
‚îÇ       ‚îî‚îÄ‚îÄ application-prod.yml
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ resources/
        ‚îú‚îÄ‚îÄ application.yml               # Config base com√∫n a todos los tests
        ‚îú‚îÄ‚îÄ application-test.yml          # Perfil de pruebas con MySQL real o contenedores
        ‚îî‚îÄ‚îÄ application-test-h2.yml       # Perfil alternativo con base en memoria H2
````

üß© Prop√≥sito de cada archivo

| Archivo                   | Prop√≥sito                                               | Uso t√≠pico                          |
|---------------------------|---------------------------------------------------------|-------------------------------------|
| `application.yml`         | Configuraci√≥n base (puerto aleatorio, nombre app, logs) | Se carga en todos los tests         |
| `application-test.yml`    | Configuraci√≥n de pruebas con MySQL o Testcontainers     | Ideal para CI/CD o integraci√≥n real |
| `application-test-h2.yml` | Configuraci√≥n ligera con H2                             | Ideal para pruebas locales r√°pidas  |

üí¨ Nota:
> Mantener esta separaci√≥n de perfiles te permite cambiar f√°cilmente entre entornos de prueba
> (`H2` ‚Üî `MySQL` ‚Üî `Testcontainers`) sin modificar el c√≥digo fuente, solo ajustando el perfil activo.

## üß† Autoconfiguraci√≥n de H2

Spring Boot detecta autom√°ticamente la dependencia `com.h2database:h2` y `autoconfigura el datasource`
(driver, URL y dialecto), por lo que `no es necesario` definir manualmente esas propiedades para que funcione.

Sin embargo, en entornos profesionales `s√≠ se suele personalizar` la configuraci√≥n para:

- Asignar nombres de base de datos espec√≠ficos.
- Controlar el cierre del contexto.
- Emular el comportamiento de `MySQL` (con `MODE=MySQL`).

üß© Conclusi√≥n:

- Si solo usamos `H2` para pruebas b√°sicas, basta con la dependencia.
- Pero para escenarios m√°s realistas (emulaci√≥n de MySQL, logs SQL, control de ciclo de vida), la configuraci√≥n
  personalizada es una buena pr√°ctica.

## ‚öôÔ∏è Configuraci√≥n base de pruebas (`application.yml`)

üìç Ubicaci√≥n: `/src/test/resources/application.yml`

````yml
# Configuraci√≥n BASE para todos los perfiles de test
server:
  port: 0  # Puerto aleatorio para evitar conflictos

spring:
  application:
    name: spring-rest-api
  jpa:
    hibernate:
      ddl-auto: create-drop # Crea el schema al levantar el CONTEXTO y se elimina al terminar
    properties:
      hibernate:
        format_sql: true
  sql:
    init:
      mode: never # No cargamos datos autom√°ticamente. Cada test cargar√° lo que necesite con @Sql.

# Logging para tests - queremos ver qu√© pasa pero sin saturar
logging:
  level:
    root: INFO
    dev.magadiflo.app: DEBUG
    org.hibernate.SQL: DEBUG                              # Muestra las consultas SQL
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE  # Muestra par√°metros enviados al SQL
    org.springframework.test: DEBUG                       # Informaci√≥n del contexto de test
````

üß† Explicaci√≥n de configuraci√≥n

- `ddl-auto: create-drop` ‚Üí crea el esquema al iniciar el contexto de Spring (primera vez que se necesita) y lo destruye
  al finalizarlo (cuando ya no hay m√°s tests que lo usen). Un contexto puede ser reutilizado por
  `m√∫ltiples clases de test`.
- ¬øQu√© es un "contexto de Spring? Spring cachea contextos seg√∫n:
    - Anotaciones de test (`@SpringBootTest`, `@DataJpaTest`, `@WebMvcTest`, etc.)
    - Perfiles activos (`@ActiveProfiles`)
    - Configuraciones adicionales (`@TestPropertySource`, `webEnvironment`, etc.)
- El esquema (`create-drop`) se ejecuta por cada contexto √∫nico. Si m√∫ltiples clases de test usan: la misma anotaci√≥n,
  el mismo perfil, la misma configuraci√≥n, Spring REUTILIZA el contexto (1 solo `create-drop` para todas esas clases).
  Si cambia cualquiera de esos elementos ‚Üí Se crea un nuevo contexto (nuevo `create-drop`).
- `format_sql: true` ‚Üí formatea las sentencias SQL en el log, lo que facilita su lectura.
- `mode: never` ‚Üí no queremos carga autom√°tica de datos. Cada test cargar√° lo que necesite con `@Sql`.
- `root: WARN` ‚Üí reduce el ruido en consola; solo se muestran advertencias o errores globales.
- `dev.magadiflo.app: DEBUG` ‚Üí habilita logs detallados para nuestras clases.
- `org.hibernate.SQL: DEBUG` ‚Üí muestra las sentencias SQL generadas.
- `org.hibernate.type.descriptor.sql.BasicBinder: TRACE` ‚Üí muestra los valores de los par√°metros enviados al SQL.
- `org.springframework.test: DEBUG` ‚Üí vemos informaci√≥n del contexto de test.

üí° Recomendaci√≥n:
> Estos niveles de log son muy √∫tiles en etapa de pruebas, pero en producci√≥n deben reducirse a `INFO` o `WARN`
> para evitar sobrecargar los logs.

## ‚öôÔ∏è Perfil `test-h2` ‚Äî Base de datos en memoria

üìç Ubicaci√≥n: `/src/test/resources/application-test-h2.yml`

````yml
spring:
  config:
    activate:
      on-profile: test-h2 # ‚Üê Opcional: el nombre del archivo ya indica el perfil
  datasource:
    url: jdbc:h2:mem:db_test;MODE=MySQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
````

üîç Notas claves

- Este archivo se aplica autom√°ticamente cuando se activa el perfil `test-h2`, por ejemplo con
  `@ActiveProfiles("test-h2")` en nuestras pruebas.
- La propiedad `spring.config.activate.on-profile: test-h2` `es opcional` en archivos que ya siguen la convenci√≥n
  `application-{profile}.yml`. Se usa principalmente en archivos con m√∫ltiples bloques de configuraci√≥n o con nombres
  personalizados.
- Podemos omitirla sin afectar el comportamiento, siempre que el nombre del archivo coincida con el perfil activo.
- `spring.datasource.url`
    - `jdbc:h2:mem:db_test_h2` ‚Üí base de datos en memoria (no persiste en disco).
    - `DB_CLOSE_ON_EXIT=FALSE` ‚Üí evita el cierre autom√°tico al terminar la JVM (√∫til para inspecci√≥n).
    - `DB_CLOSE_DELAY=-1` ‚Üí mantiene viva la BD incluso sin conexiones activas. La BD no se cierra autom√°ticamente
      cuando se cierra la √∫ltima conexi√≥n.
    - `MODE=MySQL` ‚Üí hace que `H2` interprete la sintaxis SQL como `MySQL` (√∫til para dialectos y queries nativos).
- `spring.datasource.username/password`: define credenciales de acceso al motor `H2`. Para entrar por navegador a la
  consola `H2`, necesitamos:
    - Activar la consola con `spring.h2.console.enabled=true`
    - Acceder v√≠a `http://localhost:{puerto}/h2-console`
    - Usar el mismo `jdbc:h2:mem:db_test` como `URL`
    - Username `sa` (usuario por defecto de `H2`)
    - Password (dejar vac√≠o)

‚ö†Ô∏è Importante: Acceder durante un test en ejecuci√≥n
> La BD `H2` en memoria (`mem:`) solo existe mientras la aplicaci√≥n est√° corriendo.
>
> Para inspeccionar datos durante un test podr√≠amos usar `Thread.sleep(300000);` dentro del c√≥digo del test para pausar
> por 5 minutos, por ejemplo, luego acceder a la url, consultar las tablas, etc.

## üìí Activaci√≥n de Perfiles en Tests

### ‚úèÔ∏è En `/main`

Cuando usamos la siguiente configuraci√≥n en `src/main/resources/application.yml` (desarrollo/producci√≥n):

````yml
# application.yml en /main
spring:
  profiles:
    active: dev  # ‚Üê Esto ACTIVA un perfil por defecto
````

Esto dice: `Cuando arranques la aplicaci√≥n, usa el perfil dev autom√°ticamente`. Por lo que, al ejecutar:

````bash
$ java -jar app.jar
````

Sin especificar nada, usar√° `dev` porque est√° configurado como activo por defecto. Si queremos cambiarlo, basta
con ejecutar el siguiente comando:

````bash
$ java -jar app.jar --spring.profiles.active=prod
````

### üß™ En `/test`

Cuando usamos la siguiente configuraci√≥n en `src/test/resources/application-test-h2.yml` (test, test-h2, etc):

````yml
# application-test-h2.yml en /test
spring:
  config:
    activate:
      on-profile: test-h2  # ‚Üê Esto NO activa, solo DECLARA cu√°ndo aplicar este archivo
````

La configuraci√≥n anterior `NO activa el perfil`, solo dice:
"Este archivo `application-test-h2.yml` se aplicar√° cuando el perfil `test-h2` est√© activo. Es una declaraci√≥n
condicional, no una activaci√≥n.

#### üì¢ Importante

> En archivos que siguen la convenci√≥n `application-{profile}.yml`, como `application-test-h2.yml`, esta propiedad
> es `opcional`. Spring Boot ya sabe que debe aplicar ese archivo si el perfil `test-h2` est√° activo
> (por ejemplo, con `@ActiveProfiles("test-h2")` en nuestros tests). Se recomienda usarla solo si necesitamos
> mayor control o si el archivo contiene m√∫ltiples bloques para distintos perfiles.

#### üìã Comparaci√≥n clara:

| Propiedad                           | Prop√≥sito                             | D√≥nde se usa                   |
|-------------------------------------|---------------------------------------|--------------------------------|
| `spring.profiles.active`            | `ACTIVA` un perfil por defecto        | `/main` principalmente         |
| `spring.config.activate.on-profile` | `DECLARA` cu√°ndo aplicar este archivo | Archivos espec√≠ficos de perfil |

### üîß ¬øC√≥mo se activan los perfiles en tests entonces?

Hay 3 formas:

- `Opci√≥n 1`: Con `@ActiveProfiles` (la m√°s com√∫n en tests)
    ````java
    @SpringBootTest
    @ActiveProfiles("test-h2")  // ‚Üê Activa expl√≠citamente el perfil test-h2 para este test
    class BankRepositoryTest {
        // Spring cargar√°: application.yml + application-test-h2.yml
    }
    ````
  Es la forma m√°s usada y clara. Cada clase define expl√≠citamente su perfil.


- `Opci√≥n 2`: Con `spring.profiles.active` en `application.yml` de `/test`
    ````yml
    # application.yml en src/test/resources
    spring:
      profiles:
        active: test-h2  # ‚Üê Perfil por defecto para TODOS los tests
    ````
  Si ponemos esto, `todos` los tests usar√°n `test-h2` a menos que lo sobrescribamos con `@ActiveProfiles`.


- `Opci√≥n 3`: Con Maven/Gradle al ejecutar
    ````bash
    $ mvn test -Dspring.profiles.active=test-h2
    ````

### ‚úÖ Recomendaci√≥n Empresarial

No pongamos `spring.profiles.active` en el `application.yml` de `/test`, en su lugar, usemos `@ActiveProfiles` para
cada clase de test. ¬øCu√°les son sus ventajas?

- `Flexibilidad`: Cada clase de test puede elegir su perfil con `@ActiveProfiles`.
- `Claridad`: Al leer el test, ves inmediatamente qu√© perfil usa.
- `CI/CD`: Puedes ejecutar diferentes suites con diferentes perfiles:

````bash
$ mvn test -Dtest=*RepositoryTest -Dspring.profiles.active=test-h2
$ mvn test -Dtest=*IntegrationTest -Dspring.profiles.active=test 
````

### üöÄ ¬øQu√© pasa cuando ejecutamos `mvn test`?

1. `Maven` ejecuta todos los tests.
2. Cada clase de test con `@ActiveProfiles("test-h2")` carga:
    - `application.yml` (base)
    - `application-test-h2.yml` (porque el perfil `test-h2` est√° activo)
3. Los tests sin `@ActiveProfiles` solo cargan `application.yml` (base).

> üéØ No necesitamos especificar el perfil al ejecutar `mvn test` si ya lo declaramos con `@ActiveProfiles`.

## üìÇ Scripts SQL para Tests

Definimos y organizamos los scripts SQL que inicializan y limpian la base de datos durante las pruebas de integraci√≥n,
garantizando que cada ejecuci√≥n empiece en un estado limpio y controlado.

### üß± Estructura de directorios

Ubicaci√≥n base: `/src/test/resources/`

````
src/test/resources/
‚îú‚îÄ‚îÄ application.yml                 # Configuraci√≥n base com√∫n
‚îú‚îÄ‚îÄ application-test.yml            # Configuraci√≥n con MySQL (pendiente)
‚îú‚îÄ‚îÄ application-test-h2.yml         # Configuraci√≥n con H2 (en memoria)
‚îî‚îÄ‚îÄ sql-test/
    ‚îú‚îÄ‚îÄ cleanup-h2.sql              # Limpieza espec√≠fica para H2
    ‚îú‚îÄ‚îÄ cleanup-mysql.sql           # Limpieza espec√≠fica para MySQL
    ‚îî‚îÄ‚îÄ data-test.sql               # Datos compartidos (√∫nica fuente de verdad)
````

Mantener los scripts en un subdirectorio como `sql-test/` mejora la organizaci√≥n, permite diferenciar claramente los
datos de prueba de los de desarrollo y facilita su reutilizaci√≥n en distintos perfiles (`test`, `test-h2`, etc.).

### üßº Limpieza de datos (`cleanup-h2.sql` y `cleanup-mysql.sql`)

Los scripts de limpieza eliminan datos entre ejecuciones de tests, asegurando que cada prueba comience con un estado
consistente sin depender de los resultados de ejecuciones previas.

`cleanup-h2.sql`

````sql
-- Limpieza de datos para H2
-- Desactiva temporalmente las validaciones de integridad referencial
SET REFERENTIAL_INTEGRITY FALSE;

-- Limpia las tablas en cualquier orden (sin preocuparte por FKs)
TRUNCATE TABLE accounts;
TRUNCATE TABLE banks;

-- Reactiva las validaciones
SET REFERENTIAL_INTEGRITY TRUE;
````

- `SET REFERENTIAL_INTEGRITY FALSE` desactiva temporalmente las restricciones de integridad referencial
  (`foreign keys`).
- Esto permite truncar tablas en cualquier orden sin errores.
- Se reactivan al final para restaurar la consistencia.

`cleanup-mysql.sql`

````sql
-- Limpieza de datos para MySQL
-- Desactiva temporalmente las validaciones de foreign keys
SET FOREIGN_KEY_CHECKS = 0;

-- Limpia las tablas en cualquier orden
TRUNCATE TABLE accounts;
TRUNCATE TABLE banks;

-- Reactivar verificaci√≥n de foreign keys
SET FOREIGN_KEY_CHECKS = 1;
````

- `SET FOREIGN_KEY_CHECKS = 0` desactiva la verificaci√≥n de claves for√°neas.
- Ideal cuando se tiene un modelo relacional con dependencias.
- Es equivalente al comportamiento de `SET REFERENTIAL_INTEGRITY FALSE` en `H2`.

### üíæ Carga de datos (`data-test.sql`)

`data-test.sql`

````sql
-- Datos de prueba compartidos entre H2 y MySQL
-- Este archivo es la √öNICA FUENTE DE VERDAD para los datos de test

-- Bancos
INSERT INTO banks(name, total_transfers)
VALUES('BCP', 0),
('BBVA', 0),
('Interbank', 0),
('Scotiabank', 0);

-- Cuentas
INSERT INTO accounts(holder, balance, bank_id)
VALUES('Lesly √Åguila', 3000.00, 1),
('Cielo Fern√°ndez', 2000.00, 1),
('Susana Alvarado', 5000.00, 2),
('Briela Cirilo', 1000.00, 2),
('Milagros D√≠az', 3500.00, 3),
('Kiara Lozano', 100.00, 4),
('Analuc√≠a Urbina', 4000.00, 4),
('Yrma Guerrero', 7000.00, 4);
````

- Mantener un √∫nico archivo de datos base evita duplicaci√≥n y divergencia entre entornos.
- Los IDs no se definen expl√≠citamente para aprovechar la generaci√≥n autom√°tica (`AUTO_INCREMENT` o secuencias).
- Los nombres y montos est√°n dise√±ados para permitir pruebas predecibles y consistentes.

### üß© Clase de constantes para scripts

Ubicaci√≥n: `/src/test/java/dev/magadiflo/app/constants/TestScripts.java`

````java

@UtilityClass
public class TestScripts {
    // Limpieza por BD
    public static final String CLEANUP_H2 = "/sql-test/cleanup-h2.sql";
    public static final String CLEANUP_MYSQL = "/sql-test/cleanup-mysql.sql";

    // Datos compartidos
    public static final String DATA_TEST = "/sql-test/data-test.sql";

    // Combinaci√≥n comunes
    public static final String[] H2_INIT = {CLEANUP_H2, DATA_TEST};
    public static final String[] MYSQL_INIT = {CLEANUP_MYSQL, DATA_TEST};
}
````

üìò Ventajas de esta pr√°ctica:

| ‚úÖ Beneficio                               | Descripci√≥n                                     |
|-------------------------------------------|-------------------------------------------------|
| **Centralizaci√≥n**                        | Si cambias una ruta, solo lo haces en un lugar. |
| **Autocompletado del IDE**                | Reduce errores de tipeo al usar `@Sql`.         |
| **Verificaci√≥n en tiempo de compilaci√≥n** | Evita fallos silenciosos por rutas incorrectas. |

## üß™ Pruebas de Integraci√≥n con `@DataJpaTest` usando `H2`

Antes de continuar con la implementaci√≥n, vale la pena aclarar `por qu√©` las pruebas con `@DataJpaTest` se consideran
`pruebas de integraci√≥n` y `no unitarias`.

Esta distinci√≥n es clave para entender el prop√≥sito y alcance de los tests sobre repositorios.

### üí° ¬øPor qu√© no se consideran unitarias?

Basado en una excelente explicaci√≥n de
[Stack Overflow](https://stackoverflow.com/questions/23435937/how-to-test-spring-data-repositories):

- En resumen, no hay forma razonable de realizar pruebas unitarias sobre los repositorios de Spring Data JPA,
  ya que ser√≠a demasiado complejo simular todas las partes de la API JPA necesarias para arrancar los repositorios.
- Adem√°s, `no hay c√≥digo propio que probar`, ya que los repositorios son implementaciones generadas por Spring.
- Por tanto, `las pruebas de integraci√≥n son el enfoque m√°s sensato` porque lo que realmente nos interesa validar son:
    - üß© El mapeo de entidades (`Entity mappings`)
    - ‚öôÔ∏è La sem√°ntica de las consultas (`Query semantics`)

### üß± En resumen

- `Las pruebas unitarias` verifican el comportamiento de piezas de c√≥digo aisladas, sin depender de otros m√≥dulos ni
  recursos externos. Ejemplo: probar un m√©todo de servicio o una clase utilitaria usando `Mockito`.


- `Las pruebas de integraci√≥n`, en cambio, validan la interacci√≥n entre distintos componentes del sistema (por ejemplo,
  `repositorios` + `base de datos`). En este caso, al usar una base en memoria (`H2`), nuestras pruebas est√°n
  interactuando con un m√≥dulo de persistencia real, lo que las convierte autom√°ticamente en `pruebas de integraci√≥n`.

[Fuente original en Stack Overflow](https://stackoverflow.com/questions/23435937/how-to-test-spring-data-repositories)

> Para abreviar, no hay forma de realizar `pruebas unitarias` de los repositorios `Spring Data JPA` razonablemente por
> una raz√≥n simple: es demasiado engorroso simular todas las partes de la API JPA que invocamos para arrancar los
> repositorios. De todos modos, las pruebas unitarias no tienen mucho sentido aqu√≠, ya que normalmente no est√°
> escribiendo ning√∫n c√≥digo de implementaci√≥n usted mismo, por lo que las `pruebas de integraci√≥n` son el enfoque m√°s
> razonable.
>
> Si lo piensa, **no hay c√≥digo que escriba para sus repositorios, por lo que no hay necesidad de escribir pruebas
> unitarias.** Simplemente, no hay necesidad de hacerlo, ya que puede confiar en nuestra base de prueba para detectar
> errores b√°sicos. Sin embargo, definitivamente `se necesitan pruebas de integraci√≥n` para probar dos aspectos de su
> capa de persistencia, porque son los aspectos relacionados con su dominio:
>
> * Entity mappings
> * Query semantics

### ‚ö†Ô∏è Buenas pr√°cticas

Solo tiene sentido testear los `m√©todos personalizados` que nosotros definimos en los repositorios:

- M√©todos derivados de `naming convention` (`findByEmail`, `findByBalanceGreaterThan`, etc.)
- Consultas personalizadas con `@Query`
- `Consultas nativas` o `JPQL`
- Relaciones entre entidades (joins, lazy/eager loading, etc.)

No es necesario probar los m√©todos b√°sicos como `findAll()`, `save()`, `deleteById()`, etc., ya que forman parte
de la infraestructura probada de `Spring Data JPA`.

‚úÖ **Conclusi√≥n**

Las pruebas con `@DataJpaTest` son `pruebas de integraci√≥n` enfocadas en la capa de persistencia.
Permiten verificar la correcta integraci√≥n entre `Spring Data JPA`, `Hibernate` y la `base de datos` (`H2` o `MySQL`),
asegurando que el modelo de dominio y las consultas funcionen tal como se espera en tiempo de ejecuci√≥n.

### üéØ La anotaci√≥n `@DataJpaTest`

üìò [Referencia oficial ‚Äî Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/html/boot-features-testing.html)

La anotaci√≥n `@DataJpaTest` se utiliza cuando queremos `probar la capa de persistencia` (`repositorios JPA`) de una
aplicaci√≥n Spring Boot. Por defecto, esta anotaci√≥n:

- Configura una `base de datos embebida en memoria` (como `H2`, `HSQL` o `Derby`).
- Escanea las clases anotadas con `@Entity` para registrar las entidades `JPA`.
- Configura los repositorios de `Spring Data JPA` (`@Repository`).
- Excluye el resto de los beans (`@Service`, `@Controller`, `@Component`, etc.) del contexto de pruebas.

Es decir, el contexto cargado es `parcial` y contiene `solo lo necesario` para probar la capa de acceso a datos.

### üéØ Comportamiento transaccional de la anotac√≠on `@DataJpaTest`

Los tests anotados con `@DataJpaTest` son `transaccionales por defecto`.
Esto significa que:

- Cada m√©todo de prueba se ejecuta dentro de una `transacci√≥n`.
- Al finalizar la prueba, `Spring revierte autom√°ticamente la transacci√≥n`.
- Como resultado, `la base de datos vuelve a su estado original`, garantizando un entorno limpio y repetible.

üîÅ Ejemplo conceptual

````
@BeforeEach -> Inserta datos (por SQL o @Sql)
@Test       -> Ejecuta operaciones del repositorio
@AfterEach  -> Rollback autom√°tico ‚Üí BD limpia
````

Esto evita efectos colaterales entre pruebas y permite ejecutar cada test de forma independiente.

### üö´ Lo que NO carga `@DataJpaTest`

El contexto `no incluye beans de otras capas`, como:

- `@Component`
- `@Service`
- `@Controller`

Esto tiene un prop√≥sito: `aislar la capa de persistencia` para asegurar que lo que se prueba es la interacci√≥n entre
tus repositorios y la base de datos (no la l√≥gica de negocio ni los controladores web).

Si necesitas acceder a servicios o l√≥gica adicional, puedes complementarlo con @Import o usar @SpringBootTest (para
pruebas de integraci√≥n completas).

