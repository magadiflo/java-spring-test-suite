# Integration Test - Test de Repositorios (`@DataJpaTest`)

---

Los `tests de integraci√≥n` validan que los distintos componentes de la aplicaci√≥n (repositorios, servicios,
controladores, etc.) `interact√∫en correctamente entre s√≠` y con dependencias externas como `bases de datos`,
`colas de mensajes` o `servicios HTTP`.

En este caso, probaremos la integraci√≥n entre `Spring Data JPA` y una base de datos, usando primero `H2`
(`en memoria`) y m√°s adelante `MySQL`, para simular entornos m√°s realistas.

## ‚öôÔ∏è Configurar H2 como base de datos en memoria

En el proyecto `spring-rest-api`, agregamos la dependencia de `H2` en el `pom.xml` con el scope limitado a `test`.

### üì¶ Motivo

Usamos `H2` para ejecutar pruebas r√°pidas en memoria sin depender de una base real. M√°s adelante, reemplazaremos
esta configuraci√≥n por `MySQL` o `Testcontainers`, pero `H2` nos permite practicar el flujo de integraci√≥n sin
sobrecargar el entorno.

````xml

<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope> <!-- Importante: solo se usar√° durante los tests -->
</dependency>
````

üí° Nota profesional:
> Aunque `H2` es muy √∫til en fases iniciales, `no siempre refleja el comportamiento real` de `MySQL` o `PostgreSQL`,
> por lo que en entornos reales se recomienda pasar pronto a `Testcontainers` o bases de datos reales en `Docker`.

### üß± Perfiles para pruebas

En lecciones anteriores definimos un `application.yml` dentro de `/src/test/resources` para aislar la configuraci√≥n
de pruebas del entorno principal (`/src/main/resources`).

Ahora organizaremos nuestros archivos de configuraci√≥n de la siguiente manera:

üìÅ Estructura recomendada

````
src/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ       ‚îú‚îÄ‚îÄ application.yml
‚îÇ       ‚îú‚îÄ‚îÄ application-dev.yml
‚îÇ       ‚îú‚îÄ‚îÄ application-qa.yml
‚îÇ       ‚îî‚îÄ‚îÄ application-prod.yml
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ resources/
        ‚îú‚îÄ‚îÄ application.yml               # Config base com√∫n a todos los tests
        ‚îú‚îÄ‚îÄ application-test.yml          # Perfil de pruebas con MySQL real o contenedores
        ‚îî‚îÄ‚îÄ application-test-h2.yml       # Perfil alternativo con base en memoria H2
````

üß© Prop√≥sito de cada archivo

| Archivo                   | Prop√≥sito                                               | Uso t√≠pico                          |
|---------------------------|---------------------------------------------------------|-------------------------------------|
| `application.yml`         | Configuraci√≥n base (puerto aleatorio, nombre app, logs) | Se carga en todos los tests         |
| `application-test.yml`    | Configuraci√≥n de pruebas con MySQL o Testcontainers     | Ideal para CI/CD o integraci√≥n real |
| `application-test-h2.yml` | Configuraci√≥n ligera con H2                             | Ideal para pruebas locales r√°pidas  |

üí¨ Nota:
> Mantener esta separaci√≥n de perfiles te permite cambiar f√°cilmente entre entornos de prueba
> (`H2` ‚Üî `MySQL` ‚Üî `Testcontainers`) sin modificar el c√≥digo fuente, solo ajustando el perfil activo.

## üß† Autoconfiguraci√≥n de H2

Spring Boot detecta autom√°ticamente la dependencia `com.h2database:h2` y `autoconfigura el datasource`
(driver, URL y dialecto), por lo que `no es necesario` definir manualmente esas propiedades para que funcione.

Sin embargo, en entornos profesionales `s√≠ se suele personalizar` la configuraci√≥n para:

- Asignar nombres de base de datos espec√≠ficos.
- Controlar el cierre del contexto.
- Emular el comportamiento de `MySQL` (con `MODE=MySQL`).

üß© Conclusi√≥n:

- Si solo usamos `H2` para pruebas b√°sicas, basta con la dependencia.
- Pero para escenarios m√°s realistas (emulaci√≥n de MySQL, logs SQL, control de ciclo de vida), la configuraci√≥n
  personalizada es una buena pr√°ctica.

## ‚öôÔ∏è Configuraci√≥n base (`application.yml`) en Test

üìç Ubicaci√≥n: `/src/test/resources/application.yml`

````yml
# Configuraci√≥n BASE para todos los perfiles de test
server:
  port: 0  # Puerto aleatorio para evitar conflictos

spring:
  application:
    name: spring-rest-api
  jpa:
    hibernate:
      ddl-auto: create-drop # Crea el schema al levantar el CONTEXTO y se elimina al terminar
    properties:
      hibernate:
        format_sql: true
        show_sql: false
  sql:
    init:
      mode: never # No cargamos datos autom√°ticamente. Cada test cargar√° lo que necesite con @Sql.

# Logging para tests - queremos ver qu√© pasa pero sin saturar
logging:
  level:
    root: INFO
    dev.magadiflo.app: DEBUG
    org.hibernate.SQL: DEBUG                              # Muestra las consultas SQL
    org.hibernate.orm.jdbc.bind: TRACE                    # Muestra par√°metros enviados al SQL
    org.springframework.test: DEBUG                       # Informaci√≥n del contexto de test
````

üß† Explicaci√≥n de configuraci√≥n

- `ddl-auto: create-drop` ‚Üí crea el esquema al iniciar el contexto de Spring (primera vez que se necesita) y lo destruye
  al finalizarlo (cuando ya no hay m√°s tests que lo usen). Un contexto puede ser reutilizado por
  `m√∫ltiples clases de test`.
- ¬øQu√© es un "contexto de Spring? Spring cachea contextos seg√∫n:
    - Anotaciones de test (`@SpringBootTest`, `@DataJpaTest`, `@WebMvcTest`, etc.)
    - Perfiles activos (`@ActiveProfiles`)
    - Configuraciones adicionales (`@TestPropertySource`, `webEnvironment`, etc.)
- El esquema (`create-drop`) se ejecuta por cada contexto √∫nico. Si m√∫ltiples clases de test usan: la misma anotaci√≥n,
  el mismo perfil, la misma configuraci√≥n, Spring REUTILIZA el contexto (1 solo `create-drop` para todas esas clases).
  Si cambia cualquiera de esos elementos ‚Üí Se crea un nuevo contexto (nuevo `create-drop`).
- `format_sql: true` ‚Üí formatea las sentencias SQL en el log, lo que facilita su lectura.
- `show_sql: false` ‚Üí desactiva la impresi√≥n directa en consola con el prefijo `Hibernate:`. Las consultas siguen
  visibles gracias al logger `org.hibernate.SQL: DEBUG`, que ofrece m√°s control y mejor formato.
- En tests usamos `show_sql: false` para evitar duplicidad en consola, ya que el logger `org.hibernate.SQL` ya imprime
  las consultas. En desarrollo no es necesario desactivarlo porque no se activa autom√°ticamente.
- `mode: never` ‚Üí no queremos carga autom√°tica de datos. Cada test cargar√° lo que necesite con `@Sql`.
- `root: WARN` ‚Üí reduce el ruido en consola; solo se muestran advertencias o errores globales.
- `dev.magadiflo.app: DEBUG` ‚Üí habilita logs detallados para nuestras clases.
- `org.hibernate.SQL: DEBUG` ‚Üí muestra las sentencias SQL generadas.
- `org.hibernate.orm.jdbc.bind: TRACE` ‚Üí muestra los valores de los par√°metros enviados al SQL (Hibernate 6.x)
- `org.springframework.test: DEBUG` ‚Üí vemos informaci√≥n del contexto de test.

üí° Recomendaci√≥n:
> Estos niveles de log son muy √∫tiles en etapa de pruebas, pero en producci√≥n deben reducirse a `INFO` o `WARN`
> para evitar sobrecargar los logs.

## ‚öôÔ∏è Perfil `test-h2` ‚Äî Base de datos en memoria

üìç Ubicaci√≥n: `/src/test/resources/application-test-h2.yml`

````yml
spring:
  config:
    activate:
      on-profile: test-h2 # ‚Üê Opcional: el nombre del archivo ya indica el perfil
  datasource:
    url: jdbc:h2:mem:db_test;MODE=MySQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
````

üîç Notas claves

- Este archivo se aplica autom√°ticamente cuando se activa el perfil `test-h2`, por ejemplo con
  `@ActiveProfiles("test-h2")` en nuestras pruebas.
- La propiedad `spring.config.activate.on-profile: test-h2` `es opcional` en archivos que ya siguen la convenci√≥n
  `application-{profile}.yml`. Se usa principalmente en archivos con m√∫ltiples bloques de configuraci√≥n o con nombres
  personalizados.
- Podemos omitirla sin afectar el comportamiento, siempre que el nombre del archivo coincida con el perfil activo.
- `spring.datasource.url`
    - `jdbc:h2:mem:db_test_h2` ‚Üí base de datos en memoria (no persiste en disco).
    - `DB_CLOSE_ON_EXIT=FALSE` ‚Üí evita el cierre autom√°tico al terminar la JVM (√∫til para inspecci√≥n).
    - `DB_CLOSE_DELAY=-1` ‚Üí mantiene viva la BD incluso sin conexiones activas. La BD no se cierra autom√°ticamente
      cuando se cierra la √∫ltima conexi√≥n.
    - `MODE=MySQL` ‚Üí hace que `H2` interprete la sintaxis SQL como `MySQL` (√∫til para dialectos y queries nativos).
- `spring.datasource.username/password`: define credenciales de acceso al motor `H2`. Para entrar por navegador a la
  consola `H2`, necesitamos:
    - Activar la consola con `spring.h2.console.enabled=true`
    - Acceder v√≠a `http://localhost:{puerto}/h2-console`
    - Usar el mismo `jdbc:h2:mem:db_test` como `URL`
    - Username `sa` (usuario por defecto de `H2`)
    - Password (dejar vac√≠o)

‚ö†Ô∏è Importante: Acceder durante un test en ejecuci√≥n
> La BD `H2` en memoria (`mem:`) solo existe mientras la aplicaci√≥n est√° corriendo.
>
> Para inspeccionar datos durante un test podr√≠amos usar `Thread.sleep(300000);` dentro del c√≥digo del test para pausar
> por 5 minutos, por ejemplo, luego acceder a la url, consultar las tablas, etc.

## üìí Activaci√≥n de Perfiles en Tests

### ‚úèÔ∏è En `/main`

Cuando usamos el siguiente archivo de configuraci√≥n base en `src/main/resources/application.yml`
(desarrollo/producci√≥n):

````yml
# application.yml en /main
spring:
  profiles:
    active: dev  # ‚Üê Esto ACTIVA un perfil por defecto
````

Esto dice: `Cuando arranques la aplicaci√≥n, usa el perfil dev autom√°ticamente`. Por lo tanto, al ejecutar:

````bash
$ java -jar app.jar
````

Sin especificar nada, usar√° `dev` porque est√° configurado como perfil activo por defecto. Si queremos cambiarlo, basta
con ejecutar el siguiente comando:

````bash
$ java -jar app.jar --spring.profiles.active=prod
````

### üß™ En `/test`

Tambi√©n podemos tener un archivo de configuraci√≥n base `application.yml` y archivos espec√≠ficos para distintos
perfiles (`test`, `test-h2`, `test-mysql`, etc).

Por ejemplo, en el perfil `test-h2` correspondiente al archivo `src/test/resources/application-test-h2.yml`:

````yml
# application-test-h2.yml en /test
spring:
  config:
    activate:
      on-profile: test-h2  # ‚Üê Esto NO activa, solo DECLARA cu√°ndo aplicar este archivo
````

La configuraci√≥n anterior `NO activa el perfil`, solo dice:
"Este archivo `application-test-h2.yml` se aplicar√° cuando el perfil `test-h2` est√© activo.
**Es una declaraci√≥n condicional, no una activaci√≥n.**

#### üì¢ Importante

> En archivos que siguen la convenci√≥n `application-{profile}.yml`, como `application-test-h2.yml`, la configuraci√≥n
> anterior es `opcional`.
>
> Spring Boot ya sabe que debe aplicar ese archivo si el perfil `test-h2` est√° activo
> (por ejemplo, con `@ActiveProfiles("test-h2")` en nuestros tests). Se recomienda usar la configuraci√≥n anterior
> solo si necesitamos mayor control o si el archivo contiene m√∫ltiples bloques para distintos perfiles.

#### üìã Comparaci√≥n clara

| Propiedad                           | Prop√≥sito                             | D√≥nde se usa                                                                                      |
|-------------------------------------|---------------------------------------|---------------------------------------------------------------------------------------------------|
| `spring.profiles.active`            | `ACTIVA` un perfil por defecto        | Principalmente en `/main`. Tambi√©n puede usarse en `/test`, aunque se prefiere `@ActiveProfiles`. |
| `spring.config.activate.on-profile` | `DECLARA` cu√°ndo aplicar este archivo | Archivos espec√≠ficos de perfil (`application-{profile}.yml`)                                      |

## üîß Entonces, ¬øc√≥mo se activan los perfiles en tests?

Existen tres formas principales de activar un perfil en las pruebas:

### ü•á `Opci√≥n 1`: Con `@ActiveProfiles` (la m√°s com√∫n y recomendada)

````java

@SpringBootTest
@ActiveProfiles("test-h2")  // ‚Üê Activa expl√≠citamente el perfil test-h2 para este test
class BankRepositoryTest {
    // Spring cargar√°: application.yml + application-test-h2.yml
}
````

Es la forma m√°s clara y expl√≠cita: Cada clase define qu√© perfil usar√°, lo que facilita el mantenimiento y la lectura.

### ü•à `Opci√≥n 2`: Con `spring.profiles.active` en `application.yml` de `/test`

````yml
# application.yml en src/test/resources
spring:
  profiles:
    active: test-h2  # ‚Üê Perfil por defecto para TODOS los tests
````

Con esta configuraci√≥n, todos los tests usar√°n `test-h2` a menos que lo sobrescribamos con una anotaci√≥n
`@ActiveProfiles` espec√≠fica.

### ü•â `Opci√≥n 3`: Par√°metro en l√≠nea con `Maven` (o Gradle)

````bash
$ mvn test -Dspring.profiles.active=test-h2
````

Esta opci√≥n `activa globalmente el perfil` `test-h2` durante la ejecuci√≥n del comando. Sin embargo, tiene matices
importantes:

- Se aplicar√° solo a las clases que no tengan la anotaci√≥n `@ActiveProfiles`.
- Si una clase de test ya define su perfil con `@ActiveProfiles("otro-perfil")`, esa configuraci√≥n tendr√° prioridad
  sobre el par√°metro de l√≠nea de comandos.

En resumen:
> El par√°metro `-Dspring.profiles.active=...` es √∫til para definir un perfil por defecto cuando ejecutamos una suite
> global, pero no sobrescribir√° los perfiles definidos expl√≠citamente en las clases de test.

### üì¢ Recomendaci√≥n Empresarial

> Evitemos definir `spring.profiles.active` dentro del `application.yml` de `/test`. En su lugar, usemos
> `@ActiveProfiles` en cada clase de test.
>
> Esto nos brinda:
> - `Flexibilidad`: Cada clase elige su perfil sin afectar a las dem√°s.
> - `Claridad`: Al leer el test, se ve inmediatamente qu√© perfil usa.
> - `Compatibilidad CI/CD`: Podemos ejecutar suites diferentes seg√∫n su perfil

## üöÄ ¬øQu√© pasa cuando ejecutamos `mvn test`?

Si tenemos m√∫ltiples clases de test con distintos perfiles y ejecutamos:

````bash
$ mvn test
````

1. `Maven` ejecuta todas las clases de test detectadas bajo `src/test/java`.
2. `Spring TestContext Framework` inicia un `ApplicationContext` **para cada clase de test**, a menos que pueda
   reutilizar uno con la misma configuraci√≥n.
3. En cada clase:
    - Si tiene `@ActiveProfiles("...")` ‚Üí activa ese perfil.
    - Si no tiene `@ActiveProfiles`, usa el perfil por defecto (el definido en `application.yml` o ninguno si no hay).
4. Por lo tanto:
    - Las clases con `@ActiveProfiles("test-h2")` cargar√°n: `application.yml + application-test-h2.yml`.
    - Las que tienen `@ActiveProfiles("test-mysql")` cargar√°n: `application.yml + application-test-mysql.yml`.
    - As√≠ sucesivamente.
    - Las clases sin `@ActiveProfiles` usar√°n solo: `application.yml` (base) o cualquier perfil que est√© activo
      globalmente v√≠a `spring.profiles.active` en `application.yml`, si existiera.

> üéØ No es necesario especificar el perfil con `-Dspring.profiles.active=...` al ejecutar `mvn test`, si ya hemos
> declarado ese perfil en la clase de test con `@ActiveProfiles`, porque Spring lo reconocer√° autom√°ticamente.

> üí° Los perfiles declarados mediante `@ActiveProfiles` tienen prioridad sobre aquellos definidos a trav√©s de
> propiedades del entorno, es decir, siempre tienen mayor precedencia que cualquier valor establecido externamente.
>
> En otras palabras, `@ActiveProfiles` tiene prioridad sobre `-Dspring.profiles.active=....`

## üìò Ejecutar un grupo de tests seg√∫n su perfil

En una aplicaci√≥n con m√∫ltiples clases de test que usan distintos perfiles mediante `@ActiveProfiles(...)`, es com√∫n
querer ejecutar √∫nicamente un subconjunto de pruebas ‚Äî por ejemplo, solo las de integraci√≥n que usan el perfil
`test-integration3`.

Dado que `mvn test` ejecuta `todas` las pruebas encontradas, existen dos formas recomendadas de filtrar los tests
seg√∫n su tipo o perfil asociado:

### Opci√≥n 1: Por nombre de clase (`-Dtest=...`)

Podemos ejecutar √∫nicamente los tests cuyo nombre coincida con un patr√≥n. Por ejemplo, si nuestras clases siguen una
convenci√≥n como:

````
AccountRepositoryH2Test.java
AccountRepositoryMysqlTest.java
BankIntegration3Test.java
BankIntegration2Test.java
````

Entonces, podemos ejecutar √∫nicamente los tests que correspondan al perfil `test-integration3` con:

````bash
$ mvn test -Dtest=*Integration3Test
````

Con este comando, en realidad no filtramos por perfil, sino por `nombre de clase`. Se asume que la clase
`BankIntegration3Test.java` tiene internamente definido el perfil `@ActiveProfiles("test-integration3");` por tanto,
al ejecutar este patr√≥n, se ejecutar√°n solo las pruebas cuyo nombre coincida y que, a su vez, usan ese perfil.

‚úÖ Ventajas:

- No depende de configuraci√≥n adicional.
- Ideal cuando las clases siguen una convenci√≥n de nombres por perfil (`*IntegrationTest`, `*RepositoryTest`,
  `*ContainerTest`, etc.).
- F√°cil de integrar en pipelines o comandos r√°pidos.

### Opci√≥n 2: Por etiquetas (@Tag)

`JUnit 5` permite usar la anotaci√≥n `@Tag` para clasificar tests de forma l√≥gica, independientemente del nombre de la
clase.

````java

@Tag("integration3")
@ActiveProfiles("test-integration3")
class BankIntegration3Test {
    /* code */
}
````

Luego, ejecutamos solo los tests que tengan esa etiqueta:

````bash
# Para surefire antiguo:
mvn test -Dgroups=integration3
        
# O con JUnit Platform moderno:
mvn test -DincludeTags=integration3
````

‚úÖ Ventajas:

- Permite agrupar varias clases bajo la misma categor√≠a sin depender de su nombre.
- Puede combinarse con diferentes perfiles (`@ActiveProfiles`) seg√∫n el tipo de test.
- Muy √∫til cuando una suite contiene muchos tipos de tests y se requiere ejecutar subconjuntos espec√≠ficos.

üß† Nota importante

> El par√°metro `-Dspring.profiles.active=...` **no filtra las pruebas.** Solo define qu√© perfil se activa globalmente,
> pero no evita que se ejecuten otras clases con `@ActiveProfiles`.
>
> Por tanto, para ejecutar solo un grupo de tests, debemos filtrar expl√≠citamente con nombre (`-Dtest=...`)
> o etiqueta (`-DincludeTags=...`).

## üìÇ Scripts SQL para Tests

Definimos y organizamos los scripts SQL que inicializan y limpian la base de datos durante las pruebas de integraci√≥n,
garantizando que cada ejecuci√≥n empiece en un estado limpio y controlado.

### üß± Estructura de directorios

Ubicaci√≥n base: `/src/test/resources/`

````
src/test/resources/
‚îú‚îÄ‚îÄ application.yml                 # Configuraci√≥n base com√∫n
‚îú‚îÄ‚îÄ application-test.yml            # Configuraci√≥n con MySQL (pendiente)
‚îú‚îÄ‚îÄ application-test-h2.yml         # Configuraci√≥n con H2 (en memoria)
‚îî‚îÄ‚îÄ sql-test/
    ‚îú‚îÄ‚îÄ cleanup-h2.sql              # Limpieza espec√≠fica para H2
    ‚îú‚îÄ‚îÄ cleanup-mysql.sql           # Limpieza espec√≠fica para MySQL
    ‚îî‚îÄ‚îÄ data-test.sql               # Datos compartidos (√∫nica fuente de verdad)
````

Mantener los scripts en un subdirectorio como `sql-test/` mejora la organizaci√≥n, permite diferenciar claramente los
datos de prueba de los de desarrollo y facilita su reutilizaci√≥n en distintos perfiles (`test`, `test-h2`, etc.).

### üßº Limpieza de datos (`cleanup-h2.sql` y `cleanup-mysql.sql`)

Los scripts de limpieza eliminan datos entre ejecuciones de tests, asegurando que cada prueba comience con un estado
consistente sin depender de los resultados de ejecuciones previas.

`cleanup-h2.sql`

````sql
-- Limpieza de datos para H2
-- Desactiva temporalmente las validaciones de integridad referencial
SET REFERENTIAL_INTEGRITY FALSE;

-- Limpia las tablas en cualquier orden (sin preocuparte por FKs)
TRUNCATE TABLE accounts;
TRUNCATE TABLE banks;

-- Reactiva las validaciones
SET REFERENTIAL_INTEGRITY TRUE;
````

- `SET REFERENTIAL_INTEGRITY FALSE` desactiva temporalmente las restricciones de integridad referencial
  (`foreign keys`).
- Esto permite truncar tablas en cualquier orden sin errores.
- Se reactivan al final para restaurar la consistencia.

`cleanup-mysql.sql`

````sql
-- Limpieza de datos para MySQL
-- Desactiva temporalmente las validaciones de foreign keys
SET FOREIGN_KEY_CHECKS = 0;

-- Limpia las tablas en cualquier orden
TRUNCATE TABLE accounts;
TRUNCATE TABLE banks;

-- Reactivar verificaci√≥n de foreign keys
SET FOREIGN_KEY_CHECKS = 1;
````

- `SET FOREIGN_KEY_CHECKS = 0` desactiva la verificaci√≥n de claves for√°neas.
- Ideal cuando se tiene un modelo relacional con dependencias.
- Es equivalente al comportamiento de `SET REFERENTIAL_INTEGRITY FALSE` en `H2`.

### üíæ Carga de datos (`data-test.sql`)

`data-test.sql`

````sql
-- Datos de prueba compartidos entre H2 y MySQL
-- Este archivo es la √öNICA FUENTE DE VERDAD para los datos de test

-- Bancos
INSERT INTO banks(name, total_transfers)
VALUES('BCP', 0),
('BBVA', 0),
('Interbank', 0),
('Scotiabank', 0);

-- Cuentas
INSERT INTO accounts(holder, balance, bank_id)
VALUES('Lesly √Åguila', 3000.00, 1),
('Cielo Fern√°ndez', 2000.00, 1),
('Susana Alvarado', 5000.00, 2),
('Briela Cirilo', 1000.00, 2),
('Milagros D√≠az', 3500.00, 3),
('Kiara Lozano', 100.00, 4),
('Analuc√≠a Urbina', 4000.00, 4),
('Yrma Guerrero', 7000.00, 4);
````

- Mantener un √∫nico archivo de datos base evita duplicaci√≥n y divergencia entre entornos.
- Los IDs no se definen expl√≠citamente para aprovechar la generaci√≥n autom√°tica (`AUTO_INCREMENT` o secuencias).
- Los nombres y montos est√°n dise√±ados para permitir pruebas predecibles y consistentes.

### üß© Clase de constantes para scripts

Ubicaci√≥n: `/src/test/java/dev/magadiflo/app/constants/TestScripts.java`

````java

@UtilityClass
public class TestScripts {
    // Limpieza por BD
    public static final String CLEANUP_H2 = "/sql-test/cleanup-h2.sql";
    public static final String CLEANUP_MYSQL = "/sql-test/cleanup-mysql.sql";

    // Datos compartidos
    public static final String DATA_TEST = "/sql-test/data-test.sql";

    // Combinaci√≥n comunes
    public static final String[] H2_INIT = {CLEANUP_H2, DATA_TEST};
    public static final String[] MYSQL_INIT = {CLEANUP_MYSQL, DATA_TEST};
}
````

üìò Ventajas de esta pr√°ctica:

| ‚úÖ Beneficio                               | Descripci√≥n                                     |
|-------------------------------------------|-------------------------------------------------|
| **Centralizaci√≥n**                        | Si cambias una ruta, solo lo haces en un lugar. |
| **Autocompletado del IDE**                | Reduce errores de tipeo al usar `@Sql`.         |
| **Verificaci√≥n en tiempo de compilaci√≥n** | Evita fallos silenciosos por rutas incorrectas. |

## üß™ Pruebas de Integraci√≥n con `@DataJpaTest` usando `H2`

Antes de continuar con la implementaci√≥n, vale la pena aclarar `por qu√©` las pruebas con `@DataJpaTest` se consideran
`pruebas de integraci√≥n` y `no unitarias`.

Esta distinci√≥n es clave para entender el prop√≥sito y alcance de los tests sobre repositorios.

### üí° ¬øPor qu√© no se consideran unitarias?

Basado en una excelente explicaci√≥n de
[Stack Overflow](https://stackoverflow.com/questions/23435937/how-to-test-spring-data-repositories):

- En resumen, no hay forma razonable de realizar pruebas unitarias sobre los repositorios de Spring Data JPA,
  ya que ser√≠a demasiado complejo simular todas las partes de la API JPA necesarias para arrancar los repositorios.
- Adem√°s, `no hay c√≥digo propio que probar`, ya que los repositorios son implementaciones generadas por Spring.
- Por tanto, `las pruebas de integraci√≥n son el enfoque m√°s sensato` porque lo que realmente nos interesa validar son:
    - üß© El mapeo de entidades (`Entity mappings`)
    - ‚öôÔ∏è La sem√°ntica de las consultas (`Query semantics`)

### üß± En resumen

- `Las pruebas unitarias` verifican el comportamiento de piezas de c√≥digo aisladas, sin depender de otros m√≥dulos ni
  recursos externos. Ejemplo: probar un m√©todo de servicio o una clase utilitaria usando `Mockito`.


- `Las pruebas de integraci√≥n`, en cambio, validan la interacci√≥n entre distintos componentes del sistema (por ejemplo,
  `repositorios` + `base de datos`). En este caso, al usar una base en memoria (`H2`), nuestras pruebas est√°n
  interactuando con un m√≥dulo de persistencia real, lo que las convierte autom√°ticamente en `pruebas de integraci√≥n`.

[Fuente original en Stack Overflow](https://stackoverflow.com/questions/23435937/how-to-test-spring-data-repositories)

> Para abreviar, no hay forma de realizar `pruebas unitarias` de los repositorios `Spring Data JPA` razonablemente por
> una raz√≥n simple: es demasiado engorroso simular todas las partes de la API JPA que invocamos para arrancar los
> repositorios. De todos modos, las pruebas unitarias no tienen mucho sentido aqu√≠, ya que normalmente no est√°
> escribiendo ning√∫n c√≥digo de implementaci√≥n usted mismo, por lo que las `pruebas de integraci√≥n` son el enfoque m√°s
> razonable.
>
> Si lo piensa, **no hay c√≥digo que escriba para sus repositorios, por lo que no hay necesidad de escribir pruebas
> unitarias.** Simplemente, no hay necesidad de hacerlo, ya que puede confiar en nuestra base de prueba para detectar
> errores b√°sicos. Sin embargo, definitivamente `se necesitan pruebas de integraci√≥n` para probar dos aspectos de su
> capa de persistencia, porque son los aspectos relacionados con su dominio:
>
> * Entity mappings
> * Query semantics

### ‚ö†Ô∏è Buenas pr√°cticas

Solo tiene sentido testear los `m√©todos personalizados` que nosotros definimos en los repositorios:

- M√©todos derivados de `naming convention` (`findByEmail`, `findByBalanceGreaterThan`, etc.)
- Consultas personalizadas con `@Query`
- `Consultas nativas` o `JPQL`
- Relaciones entre entidades (joins, lazy/eager loading, etc.)

No es necesario probar los m√©todos b√°sicos como `findAll()`, `save()`, `deleteById()`, etc., ya que forman parte
de la infraestructura probada de `Spring Data JPA`.

‚úÖ **Conclusi√≥n**

Las pruebas con `@DataJpaTest` son `pruebas de integraci√≥n` enfocadas en la capa de persistencia.
Permiten verificar la correcta integraci√≥n entre `Spring Data JPA`, `Hibernate` y la `base de datos` (`H2` o `MySQL`),
asegurando que el modelo de dominio y las consultas funcionen tal como se espera en tiempo de ejecuci√≥n.

### üéØ La anotaci√≥n `@DataJpaTest`

üìò [Referencia oficial ‚Äî Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/html/boot-features-testing.html)

La anotaci√≥n `@DataJpaTest` se utiliza cuando queremos `probar la capa de persistencia` (`repositorios JPA`) de una
aplicaci√≥n Spring Boot. Por defecto, esta anotaci√≥n:

- Configura una `base de datos embebida en memoria` (como `H2`, `HSQL` o `Derby`).
- Escanea las clases anotadas con `@Entity` para registrar las entidades `JPA`.
- Configura los repositorios de `Spring Data JPA` (`@Repository`).
- Excluye el resto de los beans (`@Service`, `@Controller`, `@Component`, etc.) del contexto de pruebas.

Es decir, el contexto cargado es `parcial` y contiene `solo lo necesario` para probar la capa de acceso a datos.

### üéØ Comportamiento transaccional de la anotac√≠on `@DataJpaTest`

Los tests anotados con `@DataJpaTest` son `transaccionales por defecto`.
Esto significa que:

- Cada m√©todo de prueba se ejecuta dentro de una `transacci√≥n`.
- Al finalizar la prueba, `Spring revierte autom√°ticamente la transacci√≥n`.
- Como resultado, `la base de datos vuelve a su estado original`, garantizando un entorno limpio y repetible.

üîÅ Ejemplo conceptual

````
@BeforeEach -> Inserta datos (por SQL o @Sql)
@Test       -> Ejecuta operaciones del repositorio
@AfterEach  -> Rollback autom√°tico ‚Üí BD limpia
````

Esto evita efectos colaterales entre pruebas y permite ejecutar cada test de forma independiente.

### üö´ Lo que NO carga `@DataJpaTest`

El contexto `no incluye beans de otras capas`, como:

- `@Component`
- `@Service`
- `@Controller`

Esto tiene un prop√≥sito: `aislar la capa de persistencia` para asegurar que lo que se prueba es la interacci√≥n entre
tus repositorios y la base de datos (no la l√≥gica de negocio ni los controladores web).

Si necesitas acceder a servicios o l√≥gica adicional, puedes complementarlo con @Import o usar @SpringBootTest (para
pruebas de integraci√≥n completas).

### ‚öôÔ∏è Configuraci√≥n inicial de prueba de repositorio con `@DataJpaTest` (perfil `test-h2`)

Antes de continuar, recordemos que una `prueba de integraci√≥n` valida c√≥mo los componentes interact√∫an entre s√≠ y con
sus dependencias externas (por ejemplo, una base de datos). En este caso, verificamos la integraci√≥n entre
`Spring Data JPA` y `H2` como base de datos en memoria.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Autowired
    private DataSource dataSource;

    // Solo verificamos que estamos usando la base de datos h2
    @Test
    void shouldUseH2Database() throws SQLException {
        String url = this.dataSource.getConnection().getMetaData().getURL();
        log.info("Usando base de datos: {}", url);
        assertThat(url).contains("h2");
    }
}
````

üìò Explicaci√≥n detallada

- `@ActiveProfiles("test-h2")`. Activa expl√≠citamente el perfil `test-h2`, lo que hace que Spring cargue la combinaci√≥n
  de:
    - `application.yml` (base)
    - `application-test-h2.yml` (configuraci√≥n espec√≠fica)


- `@Sql`. Se usa para ejecutar scripts SQL antes o despu√©s de las pruebas.
    ````
    @Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
    ````
    - `TestScripts.DATA_TEST`: constante que apunta al script `/sql-test/data-test.sql`.
    - `BEFORE_TEST_CLASS`: ejecuta el script una sola vez por clase de prueba, antes de cualquier m√©todo.
    - No usamos `AFTER_TEST_METHOD` porque cada prueba con `@DataJpaTest` se ejecuta en una `transacci√≥n` con `rollback`
      autom√°tico.
    - Los datos se cargan una sola vez y cada m√©todo de prueba deja la base en su estado original gracias al rollback
      autom√°tico.


- `@DataJpaTest`. Configura autom√°ticamente solo los componentes de la capa JPA:
    - Escanea entidades `(@Entity`) y repositorios (`@Repository`).
    - Configura un `DataSource` (por defecto H2 si no se define otro).
    - Activa transacciones autom√°ticas con rollback al finalizar cada prueba.
    - Equivale a un slice test (prueba de ‚Äúrebanada‚Äù de la aplicaci√≥n).
    - No carga `@Service`, `@Controller`, ni otros beans fuera del contexto de persistencia.
    - Se usa `@DataJpaTest` para aislar la l√≥gica de persistencia, evitando el arranque completo de Spring Boot. Esto
      reduce el tiempo de ejecuci√≥n y mejora la confiabilidad de las pruebas de base de datos.

üéØ Resumen:

- `@DataJpaTest` es `@Transactional`, es decir cada test hace rollback autom√°tico.
- `BEFORE_TEST_CLASS` + `@DataJpaTest`, los datos se cargan 1 vez, permanecen intactos entre m√©todos test por el
  rollback aplicado por defecto gracias al `@DataJpaTest`.
- No necesitamos `BEFORE_TEST_METHOD` en tests de repositorio.
- No necesitamos `cleanup-h2.sql` porque el `rollback` se encarga.

El siguiente log muestra el resultado luego de ejecutar la prueba de integraci√≥n `AccountRepositoryH2Test`.

````bash
2025-10-17T14:54:41.751-05:00 DEBUG 10720 --- [spring-rest-api] [           main] sContextBeforeModesTestExecutionListener : Before test method: class [AccountRepositoryH2Test], method [shouldUseH2Database], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] t.c.t.TransactionalTestExecutionListener : Explicit transaction definition [PROPAGATION_REQUIRED,ISOLATION_DEFAULT] found for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test] and test method [shouldUseH2Database]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] org.springframework.test.context.cache   : Spring test ApplicationContext cache statistics: [DefaultContextCache@1703e50d size = 1, maxSize = 32, parentContextCount = 0, hitCount = 6, missCount = 1, failureCount = 0]
2025-10-17T14:54:41.753-05:00 DEBUG 10720 --- [spring-rest-api] [           main] t.c.t.TransactionalTestExecutionListener : No method-level @Rollback override: using default rollback [true] for test method [void dev.magadiflo.app.integration.repository.AccountRepositoryH2Test.shouldUseH2Database() throws java.sql.SQLException]
2025-10-17T14:54:41.761-05:00 DEBUG 10720 --- [spring-rest-api] [           main] o.s.t.c.transaction.TransactionContext   : Began transaction (1) for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test]; test method [shouldUseH2Database]; transaction manager [org.springframework.orm.jpa.JpaTransactionManager@1e4d93f7]; rollback [true]
2025-10-17T14:54:42.161-05:00  INFO 10720 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : Usando base de datos: jdbc:h2:mem:6952d30f-7a0c-463e-a2a6-37a576307e61
2025-10-17T14:54:42.221-05:00 DEBUG 10720 --- [spring-rest-api] [           main] o.s.t.c.transaction.TransactionContext   : Rolled back transaction (1) for test class [dev.magadiflo.app.integration.repository.AccountRepositoryH2Test]; test method [shouldUseH2Database]
2025-10-17T14:54:42.221-05:00 DEBUG 10720 --- [spring-rest-api] [           main] .c.s.DirtiesContextTestExecutionListener : After test method: class [AccountRepositoryH2Test], method [shouldUseH2Database], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null] 
````

üìñ Interpretaci√≥n:

- La prueba confirm√≥ que la BD activa es H2.
- Se abri√≥ una transacci√≥n para el test.
- Al finalizar, se ejecut√≥ el rollback autom√°tico.

### üß© Obtener todas las cuentas registradas

Este test valida que el m√©todo personalizado `getAllAccounts()` del repositorio `AccountRepository` devuelva
correctamente todas las cuentas almacenadas en la base de datos `H2` de pruebas.

Adem√°s, se verifica que la lista no est√© vac√≠a, tenga la cantidad esperada de registros (8), y contenga titulares
espec√≠ficos que se insertaron previamente mediante el script `data-test.sql`.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnAllAccountsWhenDatabaseIsInitialized() {
        // when
        List<AccountResponse> accounts = this.accountRepository.getAllAccounts();

        // then
        assertThat(accounts)
                .isNotEmpty()
                .hasSize(8)
                .extracting(AccountResponse::holder)
                .contains("Lesly √Åguila", "Briela Cirilo", "Milagros D√≠az");
    }
}
````

- Este test se ejecuta dentro de una transacci√≥n administrada por `@DataJpaTest`, por lo que cualquier modificaci√≥n se
  revierte autom√°ticamente.
- La aserci√≥n con `extracting(AccountResponse::holder)` permite validar valores de un campo espec√≠fico de todos los
  elementos de la colecci√≥n, facilitando la verificaci√≥n sem√°ntica del contenido.

### üß© Verificar que todas las cuentas tengan un banco asociado

Este test confirma que cada cuenta obtenida por el m√©todo `getAllAccounts()` tenga todos sus campos v√°lidos y, en
particular, que posea un banco asociado.

Se valida que ning√∫n registro tenga valores nulos o en blanco, y adem√°s se comprueba que al menos una cuenta pertenece
al banco BCP, garantizando que los datos fueron cargados correctamente desde el script SQL.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldHaveAssociatedBankForAllAccountsWhenFetchingAccounts() {
        // when
        List<AccountResponse> accounts = this.accountRepository.getAllAccounts();

        // then
        assertThat(accounts)
                .isNotEmpty()
                .hasSize(8)
                .allSatisfy(account -> {
                    assertThat(account.id()).isNotNull();
                    assertThat(account.holder()).isNotBlank();
                    assertThat(account.balance()).isNotNull().isPositive();
                    assertThat(account.bankName())
                            .withFailMessage("La cuenta con ID %d (titular: %s) debe tener banco asociado",
                                    account.id(), account.holder())
                            .isNotBlank();
                });

        // Verificaci√≥n adicional: Al menos una cuenta es del BCP
        assertThat(accounts)
                .extracting(AccountResponse::bankName)
                .contains("BCP");
    }
}
````

- Se usa `allSatisfy(...)` de `AssertJ` para validar que todas las cuentas cumplan simult√°neamente con las condiciones
  de integridad.
- El m√©todo `withFailMessage(...)` agrega contexto al error, mostrando exactamente cu√°l cuenta no cumple la condici√≥n,
  lo que facilita la depuraci√≥n.
- Esta prueba tambi√©n demuestra c√≥mo validar relaciones entre entidades (cuenta ‚Üí banco) sin necesidad de usar joins
  expl√≠citos en el test.

### üß© Buscar una cuenta por su ID

Este test valida que el m√©todo `findById()` del repositorio `AccountRepository` retorne correctamente una cuenta
existente en la base de datos seg√∫n su identificador.

Se verifica tanto la informaci√≥n de la cuenta (titular, balance) como la relaci√≥n con su banco asociado (Bank).

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnAccountWithBankWhenFindByIdExists() {
        // given
        Long accountId = 1L;

        // when
        Optional<Account> optionalAccount = this.accountRepository.findById(accountId);

        // then
        assertThat(optionalAccount)
                .isPresent()
                .hasValueSatisfying(account -> {
                    assertThat(account.getId()).isEqualTo(accountId);
                    assertThat(account.getHolder()).isEqualTo("Lesly √Åguila");
                    assertThat(account.getBalance()).isEqualByComparingTo("3000");
                    assertThat(account.getBank())
                            .isNotNull()
                            .extracting(Bank::getId, Bank::getName)
                            .containsExactly(1L, "BCP");
                });
    }
}
````

üß† Notas adicionales

- `isPresent()`. Verifica que el `Optional<Account>` contenga un valor, asegurando que la cuenta fue encontrada.
- `hasValueSatisfying(...)`. Permite aplicar m√∫ltiples aserciones sobre el valor contenido en el Optional sin necesidad
  de desempaquetarlo manualmente.
- `extracting(Bank::getId, Bank::getName)`. Extrae varios campos de un objeto (Bank) para validarlos en conjunto
  mediante `containsExactly(...)`.
- `isEqualByComparingTo("3000")`. Es la forma recomendada de comparar valores num√©ricos (`BigDecimal`) en `AssertJ`,
  evitando errores por escala decimal.

üìò Conclusi√≥n:
> Este test confirma la correcta integraci√≥n entre `AccountRepository` y la capa de persistencia al obtener una entidad
> `Account` con su relaci√≥n `Bank`.
>
> Adem√°s, refuerza el concepto de integraci√≥n entre entidades al validar los mapeos JPA y los valores retornados por el
> repositorio.

### üß© Retorna un Optional vac√≠o cuando la cuenta no existe

Este test valida que el m√©todo `findById()` del repositorio `AccountRepository` retorne un `Optional.empty()`
cuando se busca una cuenta con un identificador inexistente en la base de datos.

De esta forma confirmamos que el repositorio maneja correctamente los escenarios donde no se encuentran resultados, sin
lanzar excepciones ni retornar valores nulos.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldReturnEmptyOptionalWhenAccountIdDoesNotExist() {
        // given
        Long accountId = 999L;

        // when
        Optional<Account> optionalAccount = this.accountRepository.findById(accountId);

        // then
        assertThat(optionalAccount).isEmpty();

    }
}
````

- `isEmpty()`. Verifica que el `Optional<Account>` no contenga ning√∫n valor, asegurando que el m√©todo maneja
  correctamente la ausencia de datos sin devolver `null`.
- Esta validaci√≥n previene posibles `NullPointerException` en el c√≥digo de producci√≥n, ya que `Optional` obliga al
  consumidor del m√©todo a manejar expl√≠citamente los casos donde no hay resultado.
- Es una buena pr√°ctica incluir este tipo de pruebas negativas en los repositorios, ya que validan comportamientos
  esperados ante datos inexistentes o inconsistentes.

### üß© Registra una cuenta

Este test verifica que el m√©todo `save()` del repositorio `AccountRepository` permita registrar correctamente una nueva
cuenta en la base de datos `H2`.

Se asegura que al guardar una entidad `Account`, se le asigne un identificador autogenerado, se persistan correctamente
los campos del titular, saldo y la relaci√≥n con un banco existente.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldSaveAccountWhenValidDataProvided() {
        // given
        Account newAccount = Account.builder()
                .holder("Edwin Guerrero Test")
                .balance(new BigDecimal("5000"))
                .bank(Bank.builder().id(1L).build())
                .build();

        // when
        Account savedAccount = this.accountRepository.save(newAccount);

        // then
        assertThat(savedAccount.getId())
                .isNotNull()
                .isEqualTo(9);
        assertThat(savedAccount.getHolder()).isEqualTo("Edwin Guerrero Test");
        assertThat(savedAccount.getBalance()).isEqualByComparingTo("5000");
        assertThat(savedAccount.getBank()).isNotNull();
    }
}
````

### üß© Elimina una cuenta

Este test valida que el m√©todo personalizado `deleteAccountById(Long id)` del repositorio `AccountRepository` elimine
correctamente una cuenta existente en la base de datos.

El m√©todo de eliminaci√≥n utiliza una consulta nativa junto con la anotaci√≥n `@Modifying(clearAutomatically = true)`
para asegurar que el contexto de persistencia se mantenga sincronizado tras la ejecuci√≥n.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldDeleteAccountWhenExistingIdProvided() {
        // given
        long accountId = 1L;
        assertThat(this.accountRepository.findById(accountId)).isPresent();

        // when
        int affectedRows = this.accountRepository.deleteAccountById(accountId);

        // then
        assertThat(affectedRows).isEqualTo(1);
        assertThat(this.accountRepository.findById(accountId)).isEmpty();
    }
}
````

Recordar que el c√≥digo del repositorio es el siguiente.

````java
public interface AccountRepository extends JpaRepository<Account, Long> {
    @Modifying(clearAutomatically = true)
    @Query(value = """
            DELETE FROM accounts
            WHERE id = :accountId
            """, nativeQuery = true)
    int deleteAccountById(Long accountId);
}
````

üß† Notas adicionales

- `@Modifying`
    - Esta anotaci√≥n se usa en m√©todos que `modifican el estado de la base de datos` (`UPDATE`, `DELETE`, `INSERT`).
    - Por defecto, los m√©todos de repositorio en `Spring Data JPA` asumen que las consultas son solo de lectura
      (`SELECT`), por lo que esta anotaci√≥n es obligatoria para cambios.

- `clearAutomatically = true`
    - Indica a `Spring Data JPA` que, despu√©s de ejecutar la consulta, debe limpiar el contexto de persistencia
      (`EntityManager`).
    - Esto evita que queden entidades `en cach√© o en estado inconsistente` dentro del `Persistence Context`.
    - En nuestro caso, sin esta propiedad, el `EntityManager` mantendr√≠a en memoria la entidad eliminada, por lo que
      el test fallar√≠a al seguir encontr√°ndola mediante `findById(...)`.

### üß© Actualiza una cuenta

Este test valida que el m√©todo personalizado `updateAccountHolder(Account account)` del repositorio `AccountRepository`
actualice correctamente el nombre del titular (`holder`) de una cuenta existente en la base de datos.

El m√©todo de actualizaci√≥n utiliza una consulta nativa junto con la anotaci√≥n `@Modifying(clearAutomatically = true)`
para asegurar que el contexto de persistencia se mantenga sincronizado despu√©s de ejecutar la actualizaci√≥n.

Gracias a esta configuraci√≥n, el `EntityManager` limpia autom√°ticamente su cach√©, garantizando que una posterior
b√∫squeda (`findById(...)`) retorne el valor actualizado desde la base de datos.

````java

@Slf4j
@ActiveProfiles("test-h2")
@Sql(scripts = TestScripts.DATA_TEST, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS)
@DataJpaTest
class AccountRepositoryH2Test {

    @Autowired
    private AccountRepository accountRepository;

    @Test
    void shouldUpdateAccountWhenExistingIdProvided() {
        // given
        long accountId = 1L;
        Account accountToUpdate = Account.builder()
                .id(accountId)
                .holder("Lesly Katherine")
                .build();
        assertThat(this.accountRepository.findById(accountId))
                .isPresent()
                .hasValueSatisfying(account -> {
                    assertThat(account.getId()).isEqualTo(accountId);
                    assertThat(account.getHolder()).isEqualTo("Lesly √Åguila");
                    assertThat(account.getBalance()).isEqualByComparingTo("3000");
                    assertThat(account.getBank())
                            .isNotNull()
                            .extracting(Bank::getId, Bank::getName)
                            .containsExactly(1L, "BCP");
                });

        // when
        int affectedRows = this.accountRepository.updateAccountHolder(accountToUpdate);

        // then
        assertThat(affectedRows).isEqualTo(1);
        assertThat(this.accountRepository.findById(accountId))
                .isPresent()
                .hasValueSatisfying(account -> {
                    assertThat(account.getId()).isEqualTo(accountId);
                    assertThat(account.getHolder()).isEqualTo("Lesly Katherine");
                    assertThat(account.getBalance()).isEqualByComparingTo("3000");
                    assertThat(account.getBank())
                            .isNotNull()
                            .extracting(Bank::getId, Bank::getName)
                            .containsExactly(1L, "BCP");
                });
    }
}
````

üìå Nota t√©cnica
> Sin `clearAutomatically = true`, el `EntityManager` podr√≠a seguir mostrando el valor anterior del titular
> (`Lesly √Åguila`) en la segunda verificaci√≥n, ya que la entidad seguir√≠a en cach√©. Esta propiedad asegura que el
> contexto se sincronice tras el `UPDATE`, especialmente √∫til en entornos de prueba con H2 o cuando se accede a la
> entidad modificada dentro del mismo m√©todo.

## ‚öôÔ∏è Ejecutando Tests de Integraci√≥n

Hasta este punto, contamos con cuatro clases de pruebas unitarias y una clase de prueba de integraci√≥n que utiliza una
base de datos H2 en memoria.

En esta secci√≥n, ejecutaremos √∫nicamente nuestra clase de prueba de integraci√≥n `AccountRepositoryH2Test`.

### üß© Desde IntelliJ IDEA

Podemos ejecutar esta clase directamente desde el `IntelliJ IDEA`, seleccionando el archivo `AccountRepositoryH2Test` y
eligiendo la opci√≥n `Run`.

La siguiente imagen muestra la ejecuci√≥n exitosa, donde todos los tests han pasado correctamente:

![05.png](assets/05.png)

### üíª Desde la L√≠nea de Comandos con Maven

Tambi√©n podemos ejecutar esta misma clase desde la l√≠nea de comandos. Para ello, usamos la bandera `-Dtest`,
indicando el nombre exacto de la clase a ejecutar:

````bash
$ mvn test -Dtest=AccountRepositoryH2Test
````

Con este comando, Maven ejecutar√° solo la clase `AccountRepositoryH2Test` y omitir√° el resto.
Esto es √∫til cuando queremos probar un conjunto reducido de tests, sin ejecutar toda la suite.

### üè∑Ô∏è Alternativa: Ejecutar por @Tag

Otra opci√≥n es etiquetar nuestras clases o m√©todos con `@Tag`, lo que permite agrupar tests por tipo o contexto.
Por ejemplo:

````java

@Tag("integration")
@ActiveProfiles("test-h2")
@SpringBootTest
class AccountRepositoryH2Test { /* code */
}
````

Y luego ejecutarlos con Maven usando:

````bash
$ mvn test -DincludeTags=integration 
````

üîé En versiones antiguas de `Maven Surefire`, se usaba `-Dgroups=nombre_del_tag`, pero actualmente `-DincludeTags`
es la opci√≥n recomendada con `JUnit 5`.

### üß† Detalle Importante

En el log de ejecuci√≥n, podemos observar que Spring Boot detecta autom√°ticamente el perfil activo:

````bash
The following 1 profile is active: "test-h2" 
````

Esto sucede porque la clase `AccountRepositoryH2Test` est√° anotada con `@ActiveProfiles("test-h2")`.
Por lo tanto, al ejecutar `mvn test -Dtest=AccountRepositoryH2Test`, no es necesario indicar manualmente el perfil con
`-Dspring.profiles.active=test-h2`.

### ‚úÖ Resultado Final

La salida muestra una ejecuci√≥n satisfactoria, donde se carga el contexto de Spring, se crea la base de datos H2
embebida y se ejecutan correctamente los 8 tests definidos:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api (feature/spring-rest-api)
$ mvn test -Dtest=AccountRepositoryH2Test
[INFO] Scanning for projects...
[INFO]
[INFO] -------------------< dev.magadiflo:spring-rest-api >--------------------
[INFO] Building spring-rest-api 0.0.1-SNAPSHOT
[INFO]   from pom.xml
[INFO] --------------------------------[ jar ]---------------------------------
...
[INFO] --- surefire:3.5.4:test (default-test) @ spring-rest-api ---
[INFO] Using auto detected provider org.apache.maven.surefire.junitplatform.JUnitPlatformProvider
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running dev.magadiflo.app.integration.repository.AccountRepositoryH2Test
...

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.5.6)

2025-10-20T12:54:59.887-05:00  INFO 4108 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : Starting AccountRepositoryH2Test using Java 21.0.6 with PID 4108 (started by magadiflo in D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite\spring-rest-api)
2025-10-20T12:54:59.887-05:00 DEBUG 4108 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : Running with Spring Boot v3.5.6, Spring v6.2.11
2025-10-20T12:54:59.887-05:00  INFO 4108 --- [spring-rest-api] [           main] d.m.a.i.r.AccountRepositoryH2Test        : The following 1 profile is active: "test-h2"
2025-10-20T12:55:00.348-05:00  INFO 4108 --- [spring-rest-api] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-10-20T12:55:00.445-05:00  INFO 4108 --- [spring-rest-api] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 82 ms. Found 2 JPA repository interfaces.
2025-10-20T12:55:00.497-05:00  INFO 4108 --- [spring-rest-api] [           main] beddedDataSourceBeanFactoryPostProcessor : Replacing 'dataSource' DataSource bean with embedded version
2025-10-20T12:55:00.611-05:00  INFO 4108 --- [spring-rest-api] [           main] o.s.j.d.e.EmbeddedDatabaseFactory        : Starting embedded database: url='jdbc:h2:mem:44d7030a-83ab-4f1a-9924-9de3bd57966a;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false', username='sa'
2025-10-20T12:55:00.867-05:00  INFO 4108 --- [spring-rest-api] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-10-20T12:55:00.917-05:00  INFO 4108 --- [spring-rest-api] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.29.Final
...
2025-10-20T12:55:01.349-05:00  WARN 4108 --- [spring-rest-api] [           main] org.hibernate.orm.deprecation            : HHH90000025: H2Dialect does not need to be specified explicitly using 'hibernate.dialect' (remove the property setting and it will be selected by default)
...
2025-10-20T12:55:04.037-05:00 DEBUG 4108 --- [spring-rest-api] [           main] org.hibernate.SQL                        :
    insert
    into
        accounts
        (balance, bank_id, holder, id)
    values
        (?, ?, ?, default)
...
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.933 s -- in dev.magadiflo.app.integration.repository.AccountRepositoryH2Test
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  7.758 s
[INFO] Finished at: 2025-10-20T12:55:04-05:00
[INFO] ------------------------------------------------------------------------
````

## ‚öôÔ∏è Perfil `test` ‚Äî Usando Base de datos MySQL

El archivo `/src/test/resources/application-test.yml` define la configuraci√≥n espec√≠fica para pruebas de integraci√≥n
usando una base de datos `MySQL real` (no embebida como H2).

Este perfil hereda todas las propiedades comunes desde `src/test/resources/application.yml`, sobrescribiendo √∫nicamente
las credenciales y la URL del `datasource` necesarias para conectarse a `MySQL`.

````yml
# src/test/resources/application-test.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3307/db_spring_rest_api_test?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=America/Lima
    username: test_user
    password: test_password
````

#### üß© Propiedades Clave

| Propiedad                      | Descripci√≥n                                                                                                                 |
|--------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| `useSSL=false`                 | En entornos de prueba locales no es necesario establecer conexiones seguras mediante SSL.                                   |
| `allowPublicKeyRetrieval=true` | Permite que el cliente MySQL obtenga la clave p√∫blica del servidor, evitando errores de autenticaci√≥n en algunas versiones. |
| `serverTimezone=America/Lima`  | Evita *warnings* o desajustes horarios al mapear tipos `DATETIME` o `TIMESTAMP`.                                            |

#### üí° Nota T√©cnica

Spring Boot fusionar√° (mergear√°) las propiedades del archivo base `application.yml` con las del perfil activo.
De esta forma, no necesitas repetir configuraciones de JPA, Hibernate, ni par√°metros comunes del datasource.

Por ejemplo, si en `src/test/resources/application.yml` tenemos:

````yml
spring:
  jpa:
    hibernate:
      ddl-auto: create-drop
    properties:
      hibernate:
        format_sql: true
        show_sql: false
````

Entonces estas configuraciones se mantendr√°n activas al ejecutar los tests con el perfil `test`.

## üê¨ Creando contenedor de base de datos MySQL para pruebas

En esta secci√≥n agregamos un nuevo servicio al archivo `compose.yml` que levantar√° un contenedor MySQL dedicado a las
pruebas de integraci√≥n.

Este contenedor ser√° utilizado √∫nicamente por el perfil `test` (definido en `application-test.yml`) para mantener
aislado el entorno de pruebas del entorno de desarrollo o producci√≥n.

````yml
services:
  s-mysql-test:
    image: mysql:8.0.41-debian
    container_name: c-mysql-test
    restart: unless-stopped
    ports:
      - '3307:3306'
    environment:
      MYSQL_ROOT_PASSWORD: magadiflo
      MYSQL_DATABASE: db_spring_rest_api_test
      MYSQL_USER: test_user
      MYSQL_PASSWORD: test_password
    networks:
      - docker-test-net
````

üß© Detalles importantes

- `ports: '3307:3306'` ‚Üí expone el puerto interno `3306` del contenedor en el `3307` de tu m√°quina local para evitar
  conflictos con tu MySQL de desarrollo.
- `MYSQL_DATABASE`, `MYSQL_USER`, `MYSQL_PASSWORD` ‚Üí las credenciales definidas en el archivo `application-test.yml`
  deben coincidir con las configuradas en este servicio del `compose.yml`.
- `restart: unless-stopped` ‚Üí reinicia el contenedor autom√°ticamente a menos que se detenga manualmente.
- `network: docker-test-net` ‚Üí permite que otros contenedores de test se comuniquen f√°cilmente si tuvieras un entorno
  m√°s complejo (por ejemplo, con Grafana, Tempo, etc.).

üí° Nota profesional
> En entornos empresariales, se recomienda `no compartir la base de datos de desarrollo` con las pruebas.
> Tener un contenedor `MySQL` exclusivo para el perfil `test` garantiza un entorno `aislado`, `reproducible` y sin
> efectos colaterales sobre datos reales.

### üê≥ Levantando contenedores

Ejecutamos el siguiente comando para levantar el contenedor correspondiente al perfil `test` definido en nuestro
archivo `compose.yml`.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\03.junit_y_mockito_2023\java-spring-test-suite (feature/spring-rest-api) 
$ docker compose -f ./docker/compose.yml up -d                                                                           
[+] Running 2/2                                                                                                          
 ‚úî Container c-mysql-test  Started                                                                                       
 ‚úî Container c-mysql       Running                                                                                        
````

üí° Aqu√≠ estamos levantando todos los servicios definidos en el archivo `compose.yml`, incluido nuestro contenedor de
pruebas `c-mysql-test`.

Una vez iniciado, verificamos que el contenedor de base de datos para nuestros tests de integraci√≥n se haya creado y
est√© en ejecuci√≥n correctamente:

````bash
docker container ls -a
CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                                         NAMES
d8d12fb0e1bf   mysql:8.0.41-debian   "docker-entrypoint.s‚Ä¶"   55 seconds ago   Up 54 seconds   0.0.0.0:3307->3306/tcp, [::]:3307->3306/tcp   c-mysql-test
d0d5997e6ff1   mysql:8.0.41-debian   "docker-entrypoint.s‚Ä¶"   10 days ago      Up 45 minutes   0.0.0.0:3306->3306/tcp, [::]:3306->3306/tcp   c-mysql 
````

‚úÖ Observa que ahora tenemos dos contenedores activos:

- `c-mysql` ‚Üí utilizado por la aplicaci√≥n principal (`dev` o `prod`).
- `c-mysql-test` ‚Üí utilizado exclusivamente para los tests de integraci√≥n bajo el perfil `test`.

Ahora podemos abrir `DBeaver` (o cualquier cliente SQL de tu preferencia) y verificar que la base de datos
`db_spring_rest_api_test` se haya creado correctamente.

Esto confirma que nuestro contenedor `c-mysql-test` est√° activo y que la base de datos est√° lista para recibir los tests
de integraci√≥n.

![06.png](assets/06.png)

